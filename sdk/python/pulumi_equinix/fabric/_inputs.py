# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from .. import _enums as _root_enums
from ._enums import *

__all__ = [
    'CloudRouterAccountArgs',
    'CloudRouterAccountArgsDict',
    'CloudRouterChangeLogArgs',
    'CloudRouterChangeLogArgsDict',
    'CloudRouterLocationArgs',
    'CloudRouterLocationArgsDict',
    'CloudRouterMarketplaceSubscriptionArgs',
    'CloudRouterMarketplaceSubscriptionArgsDict',
    'CloudRouterNotificationArgs',
    'CloudRouterNotificationArgsDict',
    'CloudRouterOrderArgs',
    'CloudRouterOrderArgsDict',
    'CloudRouterPackageArgs',
    'CloudRouterPackageArgsDict',
    'CloudRouterProjectArgs',
    'CloudRouterProjectArgsDict',
    'ConnectionASideArgs',
    'ConnectionASideArgsDict',
    'ConnectionASideAccessPointArgs',
    'ConnectionASideAccessPointArgsDict',
    'ConnectionASideAccessPointAccountArgs',
    'ConnectionASideAccessPointAccountArgsDict',
    'ConnectionASideAccessPointGatewayArgs',
    'ConnectionASideAccessPointGatewayArgsDict',
    'ConnectionASideAccessPointInterfaceArgs',
    'ConnectionASideAccessPointInterfaceArgsDict',
    'ConnectionASideAccessPointLinkProtocolArgs',
    'ConnectionASideAccessPointLinkProtocolArgsDict',
    'ConnectionASideAccessPointLocationArgs',
    'ConnectionASideAccessPointLocationArgsDict',
    'ConnectionASideAccessPointNetworkArgs',
    'ConnectionASideAccessPointNetworkArgsDict',
    'ConnectionASideAccessPointPortArgs',
    'ConnectionASideAccessPointPortArgsDict',
    'ConnectionASideAccessPointPortRedundancyArgs',
    'ConnectionASideAccessPointPortRedundancyArgsDict',
    'ConnectionASideAccessPointProfileArgs',
    'ConnectionASideAccessPointProfileArgsDict',
    'ConnectionASideAccessPointProfileAccessPointTypeConfigArgs',
    'ConnectionASideAccessPointProfileAccessPointTypeConfigArgsDict',
    'ConnectionASideAccessPointRouterArgs',
    'ConnectionASideAccessPointRouterArgsDict',
    'ConnectionASideAccessPointVirtualDeviceArgs',
    'ConnectionASideAccessPointVirtualDeviceArgsDict',
    'ConnectionASideAdditionalInfoArgs',
    'ConnectionASideAdditionalInfoArgsDict',
    'ConnectionASideServiceTokenArgs',
    'ConnectionASideServiceTokenArgsDict',
    'ConnectionAccountArgs',
    'ConnectionAccountArgsDict',
    'ConnectionChangeLogArgs',
    'ConnectionChangeLogArgsDict',
    'ConnectionNotificationArgs',
    'ConnectionNotificationArgsDict',
    'ConnectionOperationArgs',
    'ConnectionOperationArgsDict',
    'ConnectionOperationErrorArgs',
    'ConnectionOperationErrorArgsDict',
    'ConnectionOperationErrorAdditionalInfoArgs',
    'ConnectionOperationErrorAdditionalInfoArgsDict',
    'ConnectionOrderArgs',
    'ConnectionOrderArgsDict',
    'ConnectionProjectArgs',
    'ConnectionProjectArgsDict',
    'ConnectionRedundancyArgs',
    'ConnectionRedundancyArgsDict',
    'ConnectionRouteAggregationTimeoutsArgs',
    'ConnectionRouteAggregationTimeoutsArgsDict',
    'ConnectionZSideArgs',
    'ConnectionZSideArgsDict',
    'ConnectionZSideAccessPointArgs',
    'ConnectionZSideAccessPointArgsDict',
    'ConnectionZSideAccessPointAccountArgs',
    'ConnectionZSideAccessPointAccountArgsDict',
    'ConnectionZSideAccessPointGatewayArgs',
    'ConnectionZSideAccessPointGatewayArgsDict',
    'ConnectionZSideAccessPointInterfaceArgs',
    'ConnectionZSideAccessPointInterfaceArgsDict',
    'ConnectionZSideAccessPointLinkProtocolArgs',
    'ConnectionZSideAccessPointLinkProtocolArgsDict',
    'ConnectionZSideAccessPointLocationArgs',
    'ConnectionZSideAccessPointLocationArgsDict',
    'ConnectionZSideAccessPointNetworkArgs',
    'ConnectionZSideAccessPointNetworkArgsDict',
    'ConnectionZSideAccessPointPortArgs',
    'ConnectionZSideAccessPointPortArgsDict',
    'ConnectionZSideAccessPointPortRedundancyArgs',
    'ConnectionZSideAccessPointPortRedundancyArgsDict',
    'ConnectionZSideAccessPointProfileArgs',
    'ConnectionZSideAccessPointProfileArgsDict',
    'ConnectionZSideAccessPointProfileAccessPointTypeConfigArgs',
    'ConnectionZSideAccessPointProfileAccessPointTypeConfigArgsDict',
    'ConnectionZSideAccessPointRouterArgs',
    'ConnectionZSideAccessPointRouterArgsDict',
    'ConnectionZSideAccessPointVirtualDeviceArgs',
    'ConnectionZSideAccessPointVirtualDeviceArgsDict',
    'ConnectionZSideAdditionalInfoArgs',
    'ConnectionZSideAdditionalInfoArgsDict',
    'ConnectionZSideServiceTokenArgs',
    'ConnectionZSideServiceTokenArgsDict',
    'NetworkChangeArgs',
    'NetworkChangeArgsDict',
    'NetworkChangeLogArgs',
    'NetworkChangeLogArgsDict',
    'NetworkLocationArgs',
    'NetworkLocationArgsDict',
    'NetworkNotificationArgs',
    'NetworkNotificationArgsDict',
    'NetworkOperationArgs',
    'NetworkOperationArgsDict',
    'NetworkProjectArgs',
    'NetworkProjectArgsDict',
    'PrecisionTimeServiceAccountArgs',
    'PrecisionTimeServiceAccountArgsDict',
    'PrecisionTimeServiceChangeLogArgs',
    'PrecisionTimeServiceChangeLogArgsDict',
    'PrecisionTimeServiceConnectionArgs',
    'PrecisionTimeServiceConnectionArgsDict',
    'PrecisionTimeServiceIpv4Args',
    'PrecisionTimeServiceIpv4ArgsDict',
    'PrecisionTimeServiceNtpAdvancedConfigurationArgs',
    'PrecisionTimeServiceNtpAdvancedConfigurationArgsDict',
    'PrecisionTimeServiceOrderArgs',
    'PrecisionTimeServiceOrderArgsDict',
    'PrecisionTimeServicePackageArgs',
    'PrecisionTimeServicePackageArgsDict',
    'PrecisionTimeServicePrecisionTimePriceArgs',
    'PrecisionTimeServicePrecisionTimePriceArgsDict',
    'PrecisionTimeServicePrecisionTimePriceChargeArgs',
    'PrecisionTimeServicePrecisionTimePriceChargeArgsDict',
    'PrecisionTimeServiceProjectArgs',
    'PrecisionTimeServiceProjectArgsDict',
    'PrecisionTimeServicePtpAdvancedConfigurationArgs',
    'PrecisionTimeServicePtpAdvancedConfigurationArgsDict',
    'PrecisionTimeServiceTimeoutsArgs',
    'PrecisionTimeServiceTimeoutsArgsDict',
    'RouteAggregationChangeArgs',
    'RouteAggregationChangeArgsDict',
    'RouteAggregationChangeLogArgs',
    'RouteAggregationChangeLogArgsDict',
    'RouteAggregationProjectArgs',
    'RouteAggregationProjectArgsDict',
    'RouteAggregationRuleChangeArgs',
    'RouteAggregationRuleChangeArgsDict',
    'RouteAggregationRuleChangeLogArgs',
    'RouteAggregationRuleChangeLogArgsDict',
    'RouteAggregationRuleTimeoutsArgs',
    'RouteAggregationRuleTimeoutsArgsDict',
    'RouteAggregationTimeoutsArgs',
    'RouteAggregationTimeoutsArgsDict',
    'RouteFilterChangeArgs',
    'RouteFilterChangeArgsDict',
    'RouteFilterChangeLogArgs',
    'RouteFilterChangeLogArgsDict',
    'RouteFilterProjectArgs',
    'RouteFilterProjectArgsDict',
    'RouteFilterRuleChangeArgs',
    'RouteFilterRuleChangeArgsDict',
    'RouteFilterRuleChangeLogArgs',
    'RouteFilterRuleChangeLogArgsDict',
    'RoutingProtocolBfdArgs',
    'RoutingProtocolBfdArgsDict',
    'RoutingProtocolBgpIpv4Args',
    'RoutingProtocolBgpIpv4ArgsDict',
    'RoutingProtocolBgpIpv6Args',
    'RoutingProtocolBgpIpv6ArgsDict',
    'RoutingProtocolChangeArgs',
    'RoutingProtocolChangeArgsDict',
    'RoutingProtocolChangeLogArgs',
    'RoutingProtocolChangeLogArgsDict',
    'RoutingProtocolDirectIpv4Args',
    'RoutingProtocolDirectIpv4ArgsDict',
    'RoutingProtocolDirectIpv6Args',
    'RoutingProtocolDirectIpv6ArgsDict',
    'RoutingProtocolOperationArgs',
    'RoutingProtocolOperationArgsDict',
    'RoutingProtocolOperationErrorArgs',
    'RoutingProtocolOperationErrorArgsDict',
    'RoutingProtocolOperationErrorAdditionalInfoArgs',
    'RoutingProtocolOperationErrorAdditionalInfoArgsDict',
    'ServiceProfileAccessPointTypeConfigArgs',
    'ServiceProfileAccessPointTypeConfigArgsDict',
    'ServiceProfileAccessPointTypeConfigApiConfigArgs',
    'ServiceProfileAccessPointTypeConfigApiConfigArgsDict',
    'ServiceProfileAccessPointTypeConfigAuthenticationKeyArgs',
    'ServiceProfileAccessPointTypeConfigAuthenticationKeyArgsDict',
    'ServiceProfileAccessPointTypeConfigLinkProtocolConfigArgs',
    'ServiceProfileAccessPointTypeConfigLinkProtocolConfigArgsDict',
    'ServiceProfileAccountArgs',
    'ServiceProfileAccountArgsDict',
    'ServiceProfileChangeLogArgs',
    'ServiceProfileChangeLogArgsDict',
    'ServiceProfileCustomFieldArgs',
    'ServiceProfileCustomFieldArgsDict',
    'ServiceProfileMarketingInfoArgs',
    'ServiceProfileMarketingInfoArgsDict',
    'ServiceProfileMarketingInfoProcessStepArgs',
    'ServiceProfileMarketingInfoProcessStepArgsDict',
    'ServiceProfileMetroArgs',
    'ServiceProfileMetroArgsDict',
    'ServiceProfileNotificationArgs',
    'ServiceProfileNotificationArgsDict',
    'ServiceProfilePortArgs',
    'ServiceProfilePortArgsDict',
    'ServiceProfilePortLocationArgs',
    'ServiceProfilePortLocationArgsDict',
    'ServiceProfileProjectArgs',
    'ServiceProfileProjectArgsDict',
    'ServiceProfileVirtualDeviceArgs',
    'ServiceProfileVirtualDeviceArgsDict',
    'ServiceProfileVirtualDeviceLocationArgs',
    'ServiceProfileVirtualDeviceLocationArgsDict',
    'ServiceTokenAccountArgs',
    'ServiceTokenAccountArgsDict',
    'ServiceTokenChangeLogArgs',
    'ServiceTokenChangeLogArgsDict',
    'ServiceTokenNotificationArgs',
    'ServiceTokenNotificationArgsDict',
    'ServiceTokenProjectArgs',
    'ServiceTokenProjectArgsDict',
    'ServiceTokenServiceTokenConnectionArgs',
    'ServiceTokenServiceTokenConnectionArgsDict',
    'ServiceTokenServiceTokenConnectionASideArgs',
    'ServiceTokenServiceTokenConnectionASideArgsDict',
    'ServiceTokenServiceTokenConnectionASideAccessPointSelectorArgs',
    'ServiceTokenServiceTokenConnectionASideAccessPointSelectorArgsDict',
    'ServiceTokenServiceTokenConnectionASideAccessPointSelectorInterfaceArgs',
    'ServiceTokenServiceTokenConnectionASideAccessPointSelectorInterfaceArgsDict',
    'ServiceTokenServiceTokenConnectionASideAccessPointSelectorLinkProtocolArgs',
    'ServiceTokenServiceTokenConnectionASideAccessPointSelectorLinkProtocolArgsDict',
    'ServiceTokenServiceTokenConnectionASideAccessPointSelectorNetworkArgs',
    'ServiceTokenServiceTokenConnectionASideAccessPointSelectorNetworkArgsDict',
    'ServiceTokenServiceTokenConnectionASideAccessPointSelectorNetworkLocationArgs',
    'ServiceTokenServiceTokenConnectionASideAccessPointSelectorNetworkLocationArgsDict',
    'ServiceTokenServiceTokenConnectionASideAccessPointSelectorPortArgs',
    'ServiceTokenServiceTokenConnectionASideAccessPointSelectorPortArgsDict',
    'ServiceTokenServiceTokenConnectionASideAccessPointSelectorPortLocationArgs',
    'ServiceTokenServiceTokenConnectionASideAccessPointSelectorPortLocationArgsDict',
    'ServiceTokenServiceTokenConnectionASideAccessPointSelectorVirtualDeviceArgs',
    'ServiceTokenServiceTokenConnectionASideAccessPointSelectorVirtualDeviceArgsDict',
    'ServiceTokenServiceTokenConnectionZSideArgs',
    'ServiceTokenServiceTokenConnectionZSideArgsDict',
    'ServiceTokenServiceTokenConnectionZSideAccessPointSelectorArgs',
    'ServiceTokenServiceTokenConnectionZSideAccessPointSelectorArgsDict',
    'ServiceTokenServiceTokenConnectionZSideAccessPointSelectorInterfaceArgs',
    'ServiceTokenServiceTokenConnectionZSideAccessPointSelectorInterfaceArgsDict',
    'ServiceTokenServiceTokenConnectionZSideAccessPointSelectorLinkProtocolArgs',
    'ServiceTokenServiceTokenConnectionZSideAccessPointSelectorLinkProtocolArgsDict',
    'ServiceTokenServiceTokenConnectionZSideAccessPointSelectorNetworkArgs',
    'ServiceTokenServiceTokenConnectionZSideAccessPointSelectorNetworkArgsDict',
    'ServiceTokenServiceTokenConnectionZSideAccessPointSelectorNetworkLocationArgs',
    'ServiceTokenServiceTokenConnectionZSideAccessPointSelectorNetworkLocationArgsDict',
    'ServiceTokenServiceTokenConnectionZSideAccessPointSelectorPortArgs',
    'ServiceTokenServiceTokenConnectionZSideAccessPointSelectorPortArgsDict',
    'ServiceTokenServiceTokenConnectionZSideAccessPointSelectorPortLocationArgs',
    'ServiceTokenServiceTokenConnectionZSideAccessPointSelectorPortLocationArgsDict',
    'ServiceTokenServiceTokenConnectionZSideAccessPointSelectorVirtualDeviceArgs',
    'ServiceTokenServiceTokenConnectionZSideAccessPointSelectorVirtualDeviceArgsDict',
    'StreamAlertRuleChangeLogArgs',
    'StreamAlertRuleChangeLogArgsDict',
    'StreamAlertRuleResourceSelectorArgs',
    'StreamAlertRuleResourceSelectorArgsDict',
    'StreamAlertRuleTimeoutsArgs',
    'StreamAlertRuleTimeoutsArgsDict',
    'StreamAttachmentTimeoutsArgs',
    'StreamAttachmentTimeoutsArgsDict',
    'StreamChangeLogArgs',
    'StreamChangeLogArgsDict',
    'StreamProjectArgs',
    'StreamProjectArgsDict',
    'StreamSubscriptionChangeLogArgs',
    'StreamSubscriptionChangeLogArgsDict',
    'StreamSubscriptionEventSelectorArgs',
    'StreamSubscriptionEventSelectorArgsDict',
    'StreamSubscriptionMetricSelectorArgs',
    'StreamSubscriptionMetricSelectorArgsDict',
    'StreamSubscriptionSinkArgs',
    'StreamSubscriptionSinkArgsDict',
    'StreamSubscriptionSinkCredentialArgs',
    'StreamSubscriptionSinkCredentialArgsDict',
    'StreamSubscriptionSinkSettingsArgs',
    'StreamSubscriptionSinkSettingsArgsDict',
    'StreamSubscriptionTimeoutsArgs',
    'StreamSubscriptionTimeoutsArgsDict',
    'StreamTimeoutsArgs',
    'StreamTimeoutsArgsDict',
    'GetCloudRoutersFilterArgs',
    'GetCloudRoutersFilterArgsDict',
    'GetCloudRoutersPaginationArgs',
    'GetCloudRoutersPaginationArgsDict',
    'GetCloudRoutersSortArgs',
    'GetCloudRoutersSortArgsDict',
    'GetConnectionRouteAggregationsPaginationArgs',
    'GetConnectionRouteAggregationsPaginationArgsDict',
    'GetConnectionsFilterArgs',
    'GetConnectionsFilterArgsDict',
    'GetConnectionsPaginationArgs',
    'GetConnectionsPaginationArgsDict',
    'GetConnectionsSortArgs',
    'GetConnectionsSortArgsDict',
    'GetMetrosPaginationArgs',
    'GetMetrosPaginationArgsDict',
    'GetNetworksFilterArgs',
    'GetNetworksFilterArgsDict',
    'GetNetworksPaginationArgs',
    'GetNetworksPaginationArgsDict',
    'GetNetworksSortArgs',
    'GetNetworksSortArgsDict',
    'GetPortsFilterArgs',
    'GetPortsFilterArgsDict',
    'GetPrecisionTimeServiceNtpAdvancedConfigurationArgs',
    'GetPrecisionTimeServiceNtpAdvancedConfigurationArgsDict',
    'GetPrecisionTimeServiceProjectArgs',
    'GetPrecisionTimeServiceProjectArgsDict',
    'GetPrecisionTimeServicePtpAdvancedConfigurationArgs',
    'GetPrecisionTimeServicePtpAdvancedConfigurationArgsDict',
    'GetPrecisionTimeServicesFilterArgs',
    'GetPrecisionTimeServicesFilterArgsDict',
    'GetPrecisionTimeServicesPaginationArgs',
    'GetPrecisionTimeServicesPaginationArgsDict',
    'GetPrecisionTimeServicesSortArgs',
    'GetPrecisionTimeServicesSortArgsDict',
    'GetRouteAggregationRulesPaginationArgs',
    'GetRouteAggregationRulesPaginationArgsDict',
    'GetRouteAggregationsFilterArgs',
    'GetRouteAggregationsFilterArgsDict',
    'GetRouteAggregationsPaginationArgs',
    'GetRouteAggregationsPaginationArgsDict',
    'GetRouteAggregationsSortArgs',
    'GetRouteAggregationsSortArgsDict',
    'GetRouteFiltersFilterArgs',
    'GetRouteFiltersFilterArgsDict',
    'GetRouteFiltersPaginationArgs',
    'GetRouteFiltersPaginationArgsDict',
    'GetRouteFiltersSortArgs',
    'GetRouteFiltersSortArgsDict',
    'GetServiceProfilesFilterArgs',
    'GetServiceProfilesFilterArgsDict',
    'GetServiceProfilesPaginationArgs',
    'GetServiceProfilesPaginationArgsDict',
    'GetServiceProfilesSortArgs',
    'GetServiceProfilesSortArgsDict',
    'GetServiceTokensFilterArgs',
    'GetServiceTokensFilterArgsDict',
    'GetServiceTokensPaginationArgs',
    'GetServiceTokensPaginationArgsDict',
    'GetStreamAlertRulesPaginationArgs',
    'GetStreamAlertRulesPaginationArgsDict',
    'GetStreamAttachmentsFilterArgs',
    'GetStreamAttachmentsFilterArgsDict',
    'GetStreamAttachmentsPaginationArgs',
    'GetStreamAttachmentsPaginationArgsDict',
    'GetStreamAttachmentsSortArgs',
    'GetStreamAttachmentsSortArgsDict',
    'GetStreamSubscriptionsPaginationArgs',
    'GetStreamSubscriptionsPaginationArgsDict',
    'GetStreamsPaginationArgs',
    'GetStreamsPaginationArgsDict',
]

MYPY = False

if not MYPY:
    class CloudRouterAccountArgsDict(TypedDict):
        account_number: pulumi.Input[_builtins.int]
        """
        Account Number
        """
elif False:
    CloudRouterAccountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudRouterAccountArgs:
    def __init__(__self__, *,
                 account_number: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.int] account_number: Account Number
        """
        pulumi.set(__self__, "account_number", account_number)

    @_builtins.property
    @pulumi.getter(name="accountNumber")
    def account_number(self) -> pulumi.Input[_builtins.int]:
        """
        Account Number
        """
        return pulumi.get(self, "account_number")

    @account_number.setter
    def account_number(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "account_number", value)


if not MYPY:
    class CloudRouterChangeLogArgsDict(TypedDict):
        created_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        Created by User Key
        """
        created_by_email: NotRequired[pulumi.Input[_builtins.str]]
        """
        Created by User Email Address
        """
        created_by_full_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Created by User Full Name
        """
        created_date_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Created by Date and Time
        """
        deleted_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        Deleted by User Key
        """
        deleted_by_email: NotRequired[pulumi.Input[_builtins.str]]
        """
        Deleted by User Email Address
        """
        deleted_by_full_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Deleted by User Full Name
        """
        deleted_date_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Deleted by Date and Time
        """
        updated_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        Updated by User Key
        """
        updated_by_email: NotRequired[pulumi.Input[_builtins.str]]
        """
        Updated by User Email Address
        """
        updated_by_full_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Updated by User Full Name
        """
        updated_date_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Updated by Date and Time
        """
elif False:
    CloudRouterChangeLogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudRouterChangeLogArgs:
    def __init__(__self__, *,
                 created_by: Optional[pulumi.Input[_builtins.str]] = None,
                 created_by_email: Optional[pulumi.Input[_builtins.str]] = None,
                 created_by_full_name: Optional[pulumi.Input[_builtins.str]] = None,
                 created_date_time: Optional[pulumi.Input[_builtins.str]] = None,
                 deleted_by: Optional[pulumi.Input[_builtins.str]] = None,
                 deleted_by_email: Optional[pulumi.Input[_builtins.str]] = None,
                 deleted_by_full_name: Optional[pulumi.Input[_builtins.str]] = None,
                 deleted_date_time: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_by: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_by_email: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_by_full_name: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_date_time: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] created_by: Created by User Key
        :param pulumi.Input[_builtins.str] created_by_email: Created by User Email Address
        :param pulumi.Input[_builtins.str] created_by_full_name: Created by User Full Name
        :param pulumi.Input[_builtins.str] created_date_time: Created by Date and Time
        :param pulumi.Input[_builtins.str] deleted_by: Deleted by User Key
        :param pulumi.Input[_builtins.str] deleted_by_email: Deleted by User Email Address
        :param pulumi.Input[_builtins.str] deleted_by_full_name: Deleted by User Full Name
        :param pulumi.Input[_builtins.str] deleted_date_time: Deleted by Date and Time
        :param pulumi.Input[_builtins.str] updated_by: Updated by User Key
        :param pulumi.Input[_builtins.str] updated_by_email: Updated by User Email Address
        :param pulumi.Input[_builtins.str] updated_by_full_name: Updated by User Full Name
        :param pulumi.Input[_builtins.str] updated_date_time: Updated by Date and Time
        """
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if created_by_email is not None:
            pulumi.set(__self__, "created_by_email", created_by_email)
        if created_by_full_name is not None:
            pulumi.set(__self__, "created_by_full_name", created_by_full_name)
        if created_date_time is not None:
            pulumi.set(__self__, "created_date_time", created_date_time)
        if deleted_by is not None:
            pulumi.set(__self__, "deleted_by", deleted_by)
        if deleted_by_email is not None:
            pulumi.set(__self__, "deleted_by_email", deleted_by_email)
        if deleted_by_full_name is not None:
            pulumi.set(__self__, "deleted_by_full_name", deleted_by_full_name)
        if deleted_date_time is not None:
            pulumi.set(__self__, "deleted_date_time", deleted_date_time)
        if updated_by is not None:
            pulumi.set(__self__, "updated_by", updated_by)
        if updated_by_email is not None:
            pulumi.set(__self__, "updated_by_email", updated_by_email)
        if updated_by_full_name is not None:
            pulumi.set(__self__, "updated_by_full_name", updated_by_full_name)
        if updated_date_time is not None:
            pulumi.set(__self__, "updated_date_time", updated_date_time)

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Created by User Key
        """
        return pulumi.get(self, "created_by")

    @created_by.setter
    def created_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_by", value)

    @_builtins.property
    @pulumi.getter(name="createdByEmail")
    def created_by_email(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Created by User Email Address
        """
        return pulumi.get(self, "created_by_email")

    @created_by_email.setter
    def created_by_email(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_by_email", value)

    @_builtins.property
    @pulumi.getter(name="createdByFullName")
    def created_by_full_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Created by User Full Name
        """
        return pulumi.get(self, "created_by_full_name")

    @created_by_full_name.setter
    def created_by_full_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_by_full_name", value)

    @_builtins.property
    @pulumi.getter(name="createdDateTime")
    def created_date_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Created by Date and Time
        """
        return pulumi.get(self, "created_date_time")

    @created_date_time.setter
    def created_date_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_date_time", value)

    @_builtins.property
    @pulumi.getter(name="deletedBy")
    def deleted_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Deleted by User Key
        """
        return pulumi.get(self, "deleted_by")

    @deleted_by.setter
    def deleted_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deleted_by", value)

    @_builtins.property
    @pulumi.getter(name="deletedByEmail")
    def deleted_by_email(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Deleted by User Email Address
        """
        return pulumi.get(self, "deleted_by_email")

    @deleted_by_email.setter
    def deleted_by_email(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deleted_by_email", value)

    @_builtins.property
    @pulumi.getter(name="deletedByFullName")
    def deleted_by_full_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Deleted by User Full Name
        """
        return pulumi.get(self, "deleted_by_full_name")

    @deleted_by_full_name.setter
    def deleted_by_full_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deleted_by_full_name", value)

    @_builtins.property
    @pulumi.getter(name="deletedDateTime")
    def deleted_date_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Deleted by Date and Time
        """
        return pulumi.get(self, "deleted_date_time")

    @deleted_date_time.setter
    def deleted_date_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deleted_date_time", value)

    @_builtins.property
    @pulumi.getter(name="updatedBy")
    def updated_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Updated by User Key
        """
        return pulumi.get(self, "updated_by")

    @updated_by.setter
    def updated_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_by", value)

    @_builtins.property
    @pulumi.getter(name="updatedByEmail")
    def updated_by_email(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Updated by User Email Address
        """
        return pulumi.get(self, "updated_by_email")

    @updated_by_email.setter
    def updated_by_email(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_by_email", value)

    @_builtins.property
    @pulumi.getter(name="updatedByFullName")
    def updated_by_full_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Updated by User Full Name
        """
        return pulumi.get(self, "updated_by_full_name")

    @updated_by_full_name.setter
    def updated_by_full_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_by_full_name", value)

    @_builtins.property
    @pulumi.getter(name="updatedDateTime")
    def updated_date_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Updated by Date and Time
        """
        return pulumi.get(self, "updated_date_time")

    @updated_date_time.setter
    def updated_date_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_date_time", value)


if not MYPY:
    class CloudRouterLocationArgsDict(TypedDict):
        ibx: NotRequired[pulumi.Input[_builtins.str]]
        """
        IBX Code
        """
        metro_code: NotRequired[pulumi.Input[_builtins.str]]
        """
        Access point metro code
        """
        metro_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Access point metro name
        """
        region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Access point region
        """
elif False:
    CloudRouterLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudRouterLocationArgs:
    def __init__(__self__, *,
                 ibx: Optional[pulumi.Input[_builtins.str]] = None,
                 metro_code: Optional[pulumi.Input[_builtins.str]] = None,
                 metro_name: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ibx: IBX Code
        :param pulumi.Input[_builtins.str] metro_code: Access point metro code
        :param pulumi.Input[_builtins.str] metro_name: Access point metro name
        :param pulumi.Input[_builtins.str] region: Access point region
        """
        if ibx is not None:
            pulumi.set(__self__, "ibx", ibx)
        if metro_code is not None:
            pulumi.set(__self__, "metro_code", metro_code)
        if metro_name is not None:
            pulumi.set(__self__, "metro_name", metro_name)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def ibx(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IBX Code
        """
        return pulumi.get(self, "ibx")

    @ibx.setter
    def ibx(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ibx", value)

    @_builtins.property
    @pulumi.getter(name="metroCode")
    def metro_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Access point metro code
        """
        return pulumi.get(self, "metro_code")

    @metro_code.setter
    def metro_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metro_code", value)

    @_builtins.property
    @pulumi.getter(name="metroName")
    def metro_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Access point metro name
        """
        return pulumi.get(self, "metro_name")

    @metro_name.setter
    def metro_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metro_name", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Access point region
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)


if not MYPY:
    class CloudRouterMarketplaceSubscriptionArgsDict(TypedDict):
        uuid: pulumi.Input[_builtins.str]
        """
        Equinix-assigned Marketplace Subscription identifier
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Marketplace Subscription type like; AWS*MARKETPLACE*SUBSCRIPTION
        """
elif False:
    CloudRouterMarketplaceSubscriptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudRouterMarketplaceSubscriptionArgs:
    def __init__(__self__, *,
                 uuid: pulumi.Input[_builtins.str],
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] uuid: Equinix-assigned Marketplace Subscription identifier
        :param pulumi.Input[_builtins.str] type: Marketplace Subscription type like; AWS*MARKETPLACE*SUBSCRIPTION
        """
        pulumi.set(__self__, "uuid", uuid)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> pulumi.Input[_builtins.str]:
        """
        Equinix-assigned Marketplace Subscription identifier
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "uuid", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Marketplace Subscription type like; AWS*MARKETPLACE*SUBSCRIPTION
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class CloudRouterNotificationArgsDict(TypedDict):
        emails: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Array of contact emails
        """
        type: pulumi.Input[_builtins.str]
        """
        Notification Type - ALL,CONNECTION*APPROVAL,SALES*REP_NOTIFICATIONS, NOTIFICATIONS
        """
        send_interval: NotRequired[pulumi.Input[_builtins.str]]
        """
        Send interval
        """
elif False:
    CloudRouterNotificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudRouterNotificationArgs:
    def __init__(__self__, *,
                 emails: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 type: pulumi.Input[_builtins.str],
                 send_interval: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] emails: Array of contact emails
        :param pulumi.Input[_builtins.str] type: Notification Type - ALL,CONNECTION*APPROVAL,SALES*REP_NOTIFICATIONS, NOTIFICATIONS
        :param pulumi.Input[_builtins.str] send_interval: Send interval
        """
        pulumi.set(__self__, "emails", emails)
        pulumi.set(__self__, "type", type)
        if send_interval is not None:
            pulumi.set(__self__, "send_interval", send_interval)

    @_builtins.property
    @pulumi.getter
    def emails(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Array of contact emails
        """
        return pulumi.get(self, "emails")

    @emails.setter
    def emails(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "emails", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Notification Type - ALL,CONNECTION*APPROVAL,SALES*REP_NOTIFICATIONS, NOTIFICATIONS
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="sendInterval")
    def send_interval(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Send interval
        """
        return pulumi.get(self, "send_interval")

    @send_interval.setter
    def send_interval(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "send_interval", value)


if not MYPY:
    class CloudRouterOrderArgsDict(TypedDict):
        billing_tier: NotRequired[pulumi.Input[_builtins.str]]
        """
        Billing tier for connection bandwidth
        """
        order_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Order Identification
        """
        order_number: NotRequired[pulumi.Input[_builtins.str]]
        """
        Order Reference Number
        """
        purchase_order_number: NotRequired[pulumi.Input[_builtins.str]]
        """
        Purchase order number
        """
        term_length: NotRequired[pulumi.Input[_builtins.int]]
        """
        Term length in months; valid values are 1, 12, 24, 36 where 1 is the default value (for on-demand case)
        """
elif False:
    CloudRouterOrderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudRouterOrderArgs:
    def __init__(__self__, *,
                 billing_tier: Optional[pulumi.Input[_builtins.str]] = None,
                 order_id: Optional[pulumi.Input[_builtins.str]] = None,
                 order_number: Optional[pulumi.Input[_builtins.str]] = None,
                 purchase_order_number: Optional[pulumi.Input[_builtins.str]] = None,
                 term_length: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] billing_tier: Billing tier for connection bandwidth
        :param pulumi.Input[_builtins.str] order_id: Order Identification
        :param pulumi.Input[_builtins.str] order_number: Order Reference Number
        :param pulumi.Input[_builtins.str] purchase_order_number: Purchase order number
        :param pulumi.Input[_builtins.int] term_length: Term length in months; valid values are 1, 12, 24, 36 where 1 is the default value (for on-demand case)
        """
        if billing_tier is not None:
            pulumi.set(__self__, "billing_tier", billing_tier)
        if order_id is not None:
            pulumi.set(__self__, "order_id", order_id)
        if order_number is not None:
            pulumi.set(__self__, "order_number", order_number)
        if purchase_order_number is not None:
            pulumi.set(__self__, "purchase_order_number", purchase_order_number)
        if term_length is not None:
            pulumi.set(__self__, "term_length", term_length)

    @_builtins.property
    @pulumi.getter(name="billingTier")
    def billing_tier(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Billing tier for connection bandwidth
        """
        return pulumi.get(self, "billing_tier")

    @billing_tier.setter
    def billing_tier(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "billing_tier", value)

    @_builtins.property
    @pulumi.getter(name="orderId")
    def order_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Order Identification
        """
        return pulumi.get(self, "order_id")

    @order_id.setter
    def order_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "order_id", value)

    @_builtins.property
    @pulumi.getter(name="orderNumber")
    def order_number(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Order Reference Number
        """
        return pulumi.get(self, "order_number")

    @order_number.setter
    def order_number(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "order_number", value)

    @_builtins.property
    @pulumi.getter(name="purchaseOrderNumber")
    def purchase_order_number(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Purchase order number
        """
        return pulumi.get(self, "purchase_order_number")

    @purchase_order_number.setter
    def purchase_order_number(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "purchase_order_number", value)

    @_builtins.property
    @pulumi.getter(name="termLength")
    def term_length(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Term length in months; valid values are 1, 12, 24, 36 where 1 is the default value (for on-demand case)
        """
        return pulumi.get(self, "term_length")

    @term_length.setter
    def term_length(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "term_length", value)


if not MYPY:
    class CloudRouterPackageArgsDict(TypedDict):
        code: pulumi.Input[_builtins.str]
        """
        Fabric Cloud Router package code
        """
elif False:
    CloudRouterPackageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudRouterPackageArgs:
    def __init__(__self__, *,
                 code: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] code: Fabric Cloud Router package code
        """
        pulumi.set(__self__, "code", code)

    @_builtins.property
    @pulumi.getter
    def code(self) -> pulumi.Input[_builtins.str]:
        """
        Fabric Cloud Router package code
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "code", value)


if not MYPY:
    class CloudRouterProjectArgsDict(TypedDict):
        href: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unique Resource URL
        """
        project_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Project Id
        """
elif False:
    CloudRouterProjectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudRouterProjectArgs:
    def __init__(__self__, *,
                 href: Optional[pulumi.Input[_builtins.str]] = None,
                 project_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] href: Unique Resource URL
        :param pulumi.Input[_builtins.str] project_id: Project Id
        """
        if href is not None:
            pulumi.set(__self__, "href", href)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)

    @_builtins.property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unique Resource URL
        """
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "href", value)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Project Id
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "project_id", value)


if not MYPY:
    class ConnectionASideArgsDict(TypedDict):
        access_point: NotRequired[pulumi.Input['ConnectionASideAccessPointArgsDict']]
        """
        Point of access details
        """
        additional_info: NotRequired[pulumi.Input[Sequence[pulumi.Input['ConnectionASideAdditionalInfoArgsDict']]]]
        """
        Connection side additional information
        """
        service_token: NotRequired[pulumi.Input['ConnectionASideServiceTokenArgsDict']]
        """
        For service token based connections, Service tokens authorize users to access protected resources and services. Resource owners can distribute the tokens to trusted partners and vendors, allowing selected third parties to work directly with Equinix network assets
        """
elif False:
    ConnectionASideArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionASideArgs:
    def __init__(__self__, *,
                 access_point: Optional[pulumi.Input['ConnectionASideAccessPointArgs']] = None,
                 additional_info: Optional[pulumi.Input[Sequence[pulumi.Input['ConnectionASideAdditionalInfoArgs']]]] = None,
                 service_token: Optional[pulumi.Input['ConnectionASideServiceTokenArgs']] = None):
        """
        :param pulumi.Input['ConnectionASideAccessPointArgs'] access_point: Point of access details
        :param pulumi.Input[Sequence[pulumi.Input['ConnectionASideAdditionalInfoArgs']]] additional_info: Connection side additional information
        :param pulumi.Input['ConnectionASideServiceTokenArgs'] service_token: For service token based connections, Service tokens authorize users to access protected resources and services. Resource owners can distribute the tokens to trusted partners and vendors, allowing selected third parties to work directly with Equinix network assets
        """
        if access_point is not None:
            pulumi.set(__self__, "access_point", access_point)
        if additional_info is not None:
            pulumi.set(__self__, "additional_info", additional_info)
        if service_token is not None:
            pulumi.set(__self__, "service_token", service_token)

    @_builtins.property
    @pulumi.getter(name="accessPoint")
    def access_point(self) -> Optional[pulumi.Input['ConnectionASideAccessPointArgs']]:
        """
        Point of access details
        """
        return pulumi.get(self, "access_point")

    @access_point.setter
    def access_point(self, value: Optional[pulumi.Input['ConnectionASideAccessPointArgs']]):
        pulumi.set(self, "access_point", value)

    @_builtins.property
    @pulumi.getter(name="additionalInfo")
    def additional_info(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ConnectionASideAdditionalInfoArgs']]]]:
        """
        Connection side additional information
        """
        return pulumi.get(self, "additional_info")

    @additional_info.setter
    def additional_info(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ConnectionASideAdditionalInfoArgs']]]]):
        pulumi.set(self, "additional_info", value)

    @_builtins.property
    @pulumi.getter(name="serviceToken")
    def service_token(self) -> Optional[pulumi.Input['ConnectionASideServiceTokenArgs']]:
        """
        For service token based connections, Service tokens authorize users to access protected resources and services. Resource owners can distribute the tokens to trusted partners and vendors, allowing selected third parties to work directly with Equinix network assets
        """
        return pulumi.get(self, "service_token")

    @service_token.setter
    def service_token(self, value: Optional[pulumi.Input['ConnectionASideServiceTokenArgs']]):
        pulumi.set(self, "service_token", value)


if not MYPY:
    class ConnectionASideAccessPointArgsDict(TypedDict):
        account: NotRequired[pulumi.Input['ConnectionASideAccessPointAccountArgsDict']]
        """
        Account
        """
        authentication_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Authentication key for provider based connections or Metal-Fabric Integration connections
        """
        gateway: NotRequired[pulumi.Input['ConnectionASideAccessPointGatewayArgsDict']]
        """
        **Deprecated** `gateway` Use `router` attribute instead
        """
        interface: NotRequired[pulumi.Input['ConnectionASideAccessPointInterfaceArgsDict']]
        """
        Virtual device interface
        """
        link_protocol: NotRequired[pulumi.Input['ConnectionASideAccessPointLinkProtocolArgsDict']]
        """
        Connection link protocol
        """
        location: NotRequired[pulumi.Input['ConnectionASideAccessPointLocationArgsDict']]
        """
        Access point location
        """
        network: NotRequired[pulumi.Input['ConnectionASideAccessPointNetworkArgsDict']]
        """
        network access point information
        """
        peering_type: NotRequired[pulumi.Input[Union[_builtins.str, 'AccessPointPeeringType']]]
        """
        Peering Type- PRIVATE,MICROSOFT,PUBLIC, MANUAL
        """
        port: NotRequired[pulumi.Input['ConnectionASideAccessPointPortArgsDict']]
        """
        Port access point information
        """
        profile: NotRequired[pulumi.Input['ConnectionASideAccessPointProfileArgsDict']]
        """
        Service Profile
        """
        provider_connection_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Provider assigned Connection Id
        """
        router: NotRequired[pulumi.Input['ConnectionASideAccessPointRouterArgsDict']]
        """
        Cloud Router access point information that replaces `gateway`
        """
        seller_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Access point seller region
        """
        type: NotRequired[pulumi.Input[Union[_builtins.str, 'AccessPointType']]]
        """
        Access point type - COLO, VD, VG, SP, IGW, SUBNET, CLOUD*ROUTER, NETWORK, METAL*NETWORK
        """
        virtual_device: NotRequired[pulumi.Input['ConnectionASideAccessPointVirtualDeviceArgsDict']]
        """
        Virtual device
        """
elif False:
    ConnectionASideAccessPointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionASideAccessPointArgs:
    def __init__(__self__, *,
                 account: Optional[pulumi.Input['ConnectionASideAccessPointAccountArgs']] = None,
                 authentication_key: Optional[pulumi.Input[_builtins.str]] = None,
                 gateway: Optional[pulumi.Input['ConnectionASideAccessPointGatewayArgs']] = None,
                 interface: Optional[pulumi.Input['ConnectionASideAccessPointInterfaceArgs']] = None,
                 link_protocol: Optional[pulumi.Input['ConnectionASideAccessPointLinkProtocolArgs']] = None,
                 location: Optional[pulumi.Input['ConnectionASideAccessPointLocationArgs']] = None,
                 network: Optional[pulumi.Input['ConnectionASideAccessPointNetworkArgs']] = None,
                 peering_type: Optional[pulumi.Input[Union[_builtins.str, 'AccessPointPeeringType']]] = None,
                 port: Optional[pulumi.Input['ConnectionASideAccessPointPortArgs']] = None,
                 profile: Optional[pulumi.Input['ConnectionASideAccessPointProfileArgs']] = None,
                 provider_connection_id: Optional[pulumi.Input[_builtins.str]] = None,
                 router: Optional[pulumi.Input['ConnectionASideAccessPointRouterArgs']] = None,
                 seller_region: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[Union[_builtins.str, 'AccessPointType']]] = None,
                 virtual_device: Optional[pulumi.Input['ConnectionASideAccessPointVirtualDeviceArgs']] = None):
        """
        :param pulumi.Input['ConnectionASideAccessPointAccountArgs'] account: Account
        :param pulumi.Input[_builtins.str] authentication_key: Authentication key for provider based connections or Metal-Fabric Integration connections
        :param pulumi.Input['ConnectionASideAccessPointGatewayArgs'] gateway: **Deprecated** `gateway` Use `router` attribute instead
        :param pulumi.Input['ConnectionASideAccessPointInterfaceArgs'] interface: Virtual device interface
        :param pulumi.Input['ConnectionASideAccessPointLinkProtocolArgs'] link_protocol: Connection link protocol
        :param pulumi.Input['ConnectionASideAccessPointLocationArgs'] location: Access point location
        :param pulumi.Input['ConnectionASideAccessPointNetworkArgs'] network: network access point information
        :param pulumi.Input[Union[_builtins.str, 'AccessPointPeeringType']] peering_type: Peering Type- PRIVATE,MICROSOFT,PUBLIC, MANUAL
        :param pulumi.Input['ConnectionASideAccessPointPortArgs'] port: Port access point information
        :param pulumi.Input['ConnectionASideAccessPointProfileArgs'] profile: Service Profile
        :param pulumi.Input[_builtins.str] provider_connection_id: Provider assigned Connection Id
        :param pulumi.Input['ConnectionASideAccessPointRouterArgs'] router: Cloud Router access point information that replaces `gateway`
        :param pulumi.Input[_builtins.str] seller_region: Access point seller region
        :param pulumi.Input[Union[_builtins.str, 'AccessPointType']] type: Access point type - COLO, VD, VG, SP, IGW, SUBNET, CLOUD*ROUTER, NETWORK, METAL*NETWORK
        :param pulumi.Input['ConnectionASideAccessPointVirtualDeviceArgs'] virtual_device: Virtual device
        """
        if account is not None:
            pulumi.set(__self__, "account", account)
        if authentication_key is not None:
            pulumi.set(__self__, "authentication_key", authentication_key)
        if gateway is not None:
            warnings.warn("""use router attribute instead; gateway is no longer a part of the supported backend""", DeprecationWarning)
            pulumi.log.warn("""gateway is deprecated: use router attribute instead; gateway is no longer a part of the supported backend""")
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if interface is not None:
            pulumi.set(__self__, "interface", interface)
        if link_protocol is not None:
            pulumi.set(__self__, "link_protocol", link_protocol)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if peering_type is not None:
            pulumi.set(__self__, "peering_type", peering_type)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if profile is not None:
            pulumi.set(__self__, "profile", profile)
        if provider_connection_id is not None:
            pulumi.set(__self__, "provider_connection_id", provider_connection_id)
        if router is not None:
            pulumi.set(__self__, "router", router)
        if seller_region is not None:
            pulumi.set(__self__, "seller_region", seller_region)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if virtual_device is not None:
            pulumi.set(__self__, "virtual_device", virtual_device)

    @_builtins.property
    @pulumi.getter
    def account(self) -> Optional[pulumi.Input['ConnectionASideAccessPointAccountArgs']]:
        """
        Account
        """
        return pulumi.get(self, "account")

    @account.setter
    def account(self, value: Optional[pulumi.Input['ConnectionASideAccessPointAccountArgs']]):
        pulumi.set(self, "account", value)

    @_builtins.property
    @pulumi.getter(name="authenticationKey")
    def authentication_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Authentication key for provider based connections or Metal-Fabric Integration connections
        """
        return pulumi.get(self, "authentication_key")

    @authentication_key.setter
    def authentication_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "authentication_key", value)

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""use router attribute instead; gateway is no longer a part of the supported backend""")
    def gateway(self) -> Optional[pulumi.Input['ConnectionASideAccessPointGatewayArgs']]:
        """
        **Deprecated** `gateway` Use `router` attribute instead
        """
        return pulumi.get(self, "gateway")

    @gateway.setter
    def gateway(self, value: Optional[pulumi.Input['ConnectionASideAccessPointGatewayArgs']]):
        pulumi.set(self, "gateway", value)

    @_builtins.property
    @pulumi.getter
    def interface(self) -> Optional[pulumi.Input['ConnectionASideAccessPointInterfaceArgs']]:
        """
        Virtual device interface
        """
        return pulumi.get(self, "interface")

    @interface.setter
    def interface(self, value: Optional[pulumi.Input['ConnectionASideAccessPointInterfaceArgs']]):
        pulumi.set(self, "interface", value)

    @_builtins.property
    @pulumi.getter(name="linkProtocol")
    def link_protocol(self) -> Optional[pulumi.Input['ConnectionASideAccessPointLinkProtocolArgs']]:
        """
        Connection link protocol
        """
        return pulumi.get(self, "link_protocol")

    @link_protocol.setter
    def link_protocol(self, value: Optional[pulumi.Input['ConnectionASideAccessPointLinkProtocolArgs']]):
        pulumi.set(self, "link_protocol", value)

    @_builtins.property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input['ConnectionASideAccessPointLocationArgs']]:
        """
        Access point location
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input['ConnectionASideAccessPointLocationArgs']]):
        pulumi.set(self, "location", value)

    @_builtins.property
    @pulumi.getter
    def network(self) -> Optional[pulumi.Input['ConnectionASideAccessPointNetworkArgs']]:
        """
        network access point information
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: Optional[pulumi.Input['ConnectionASideAccessPointNetworkArgs']]):
        pulumi.set(self, "network", value)

    @_builtins.property
    @pulumi.getter(name="peeringType")
    def peering_type(self) -> Optional[pulumi.Input[Union[_builtins.str, 'AccessPointPeeringType']]]:
        """
        Peering Type- PRIVATE,MICROSOFT,PUBLIC, MANUAL
        """
        return pulumi.get(self, "peering_type")

    @peering_type.setter
    def peering_type(self, value: Optional[pulumi.Input[Union[_builtins.str, 'AccessPointPeeringType']]]):
        pulumi.set(self, "peering_type", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input['ConnectionASideAccessPointPortArgs']]:
        """
        Port access point information
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input['ConnectionASideAccessPointPortArgs']]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def profile(self) -> Optional[pulumi.Input['ConnectionASideAccessPointProfileArgs']]:
        """
        Service Profile
        """
        return pulumi.get(self, "profile")

    @profile.setter
    def profile(self, value: Optional[pulumi.Input['ConnectionASideAccessPointProfileArgs']]):
        pulumi.set(self, "profile", value)

    @_builtins.property
    @pulumi.getter(name="providerConnectionId")
    def provider_connection_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Provider assigned Connection Id
        """
        return pulumi.get(self, "provider_connection_id")

    @provider_connection_id.setter
    def provider_connection_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "provider_connection_id", value)

    @_builtins.property
    @pulumi.getter
    def router(self) -> Optional[pulumi.Input['ConnectionASideAccessPointRouterArgs']]:
        """
        Cloud Router access point information that replaces `gateway`
        """
        return pulumi.get(self, "router")

    @router.setter
    def router(self, value: Optional[pulumi.Input['ConnectionASideAccessPointRouterArgs']]):
        pulumi.set(self, "router", value)

    @_builtins.property
    @pulumi.getter(name="sellerRegion")
    def seller_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Access point seller region
        """
        return pulumi.get(self, "seller_region")

    @seller_region.setter
    def seller_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "seller_region", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[Union[_builtins.str, 'AccessPointType']]]:
        """
        Access point type - COLO, VD, VG, SP, IGW, SUBNET, CLOUD*ROUTER, NETWORK, METAL*NETWORK
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[Union[_builtins.str, 'AccessPointType']]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="virtualDevice")
    def virtual_device(self) -> Optional[pulumi.Input['ConnectionASideAccessPointVirtualDeviceArgs']]:
        """
        Virtual device
        """
        return pulumi.get(self, "virtual_device")

    @virtual_device.setter
    def virtual_device(self, value: Optional[pulumi.Input['ConnectionASideAccessPointVirtualDeviceArgs']]):
        pulumi.set(self, "virtual_device", value)


if not MYPY:
    class ConnectionASideAccessPointAccountArgsDict(TypedDict):
        account_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Legal name of the accountholder.
        """
        account_number: NotRequired[pulumi.Input[_builtins.int]]
        """
        Equinix-assigned account number.
        """
        global_cust_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Equinix-assigned ID of the subscriber's parent organization.
        """
        global_org_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Equinix-assigned ID of the subscriber's parent organization.
        """
        global_organization_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Equinix-assigned name of the subscriber's parent organization.
        """
        org_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        Equinix-assigned ID of the subscriber's organization.
        """
        organization_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Equinix-assigned name of the subscriber's organization.
        """
        ucm_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Enterprise datastore id
        """
elif False:
    ConnectionASideAccessPointAccountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionASideAccessPointAccountArgs:
    def __init__(__self__, *,
                 account_name: Optional[pulumi.Input[_builtins.str]] = None,
                 account_number: Optional[pulumi.Input[_builtins.int]] = None,
                 global_cust_id: Optional[pulumi.Input[_builtins.str]] = None,
                 global_org_id: Optional[pulumi.Input[_builtins.str]] = None,
                 global_organization_name: Optional[pulumi.Input[_builtins.str]] = None,
                 org_id: Optional[pulumi.Input[_builtins.int]] = None,
                 organization_name: Optional[pulumi.Input[_builtins.str]] = None,
                 ucm_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] account_name: Legal name of the accountholder.
        :param pulumi.Input[_builtins.int] account_number: Equinix-assigned account number.
        :param pulumi.Input[_builtins.str] global_cust_id: Equinix-assigned ID of the subscriber's parent organization.
        :param pulumi.Input[_builtins.str] global_org_id: Equinix-assigned ID of the subscriber's parent organization.
        :param pulumi.Input[_builtins.str] global_organization_name: Equinix-assigned name of the subscriber's parent organization.
        :param pulumi.Input[_builtins.int] org_id: Equinix-assigned ID of the subscriber's organization.
        :param pulumi.Input[_builtins.str] organization_name: Equinix-assigned name of the subscriber's organization.
        :param pulumi.Input[_builtins.str] ucm_id: Enterprise datastore id
        """
        if account_name is not None:
            pulumi.set(__self__, "account_name", account_name)
        if account_number is not None:
            pulumi.set(__self__, "account_number", account_number)
        if global_cust_id is not None:
            pulumi.set(__self__, "global_cust_id", global_cust_id)
        if global_org_id is not None:
            pulumi.set(__self__, "global_org_id", global_org_id)
        if global_organization_name is not None:
            pulumi.set(__self__, "global_organization_name", global_organization_name)
        if org_id is not None:
            pulumi.set(__self__, "org_id", org_id)
        if organization_name is not None:
            pulumi.set(__self__, "organization_name", organization_name)
        if ucm_id is not None:
            pulumi.set(__self__, "ucm_id", ucm_id)

    @_builtins.property
    @pulumi.getter(name="accountName")
    def account_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Legal name of the accountholder.
        """
        return pulumi.get(self, "account_name")

    @account_name.setter
    def account_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "account_name", value)

    @_builtins.property
    @pulumi.getter(name="accountNumber")
    def account_number(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Equinix-assigned account number.
        """
        return pulumi.get(self, "account_number")

    @account_number.setter
    def account_number(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "account_number", value)

    @_builtins.property
    @pulumi.getter(name="globalCustId")
    def global_cust_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Equinix-assigned ID of the subscriber's parent organization.
        """
        return pulumi.get(self, "global_cust_id")

    @global_cust_id.setter
    def global_cust_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "global_cust_id", value)

    @_builtins.property
    @pulumi.getter(name="globalOrgId")
    def global_org_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Equinix-assigned ID of the subscriber's parent organization.
        """
        return pulumi.get(self, "global_org_id")

    @global_org_id.setter
    def global_org_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "global_org_id", value)

    @_builtins.property
    @pulumi.getter(name="globalOrganizationName")
    def global_organization_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Equinix-assigned name of the subscriber's parent organization.
        """
        return pulumi.get(self, "global_organization_name")

    @global_organization_name.setter
    def global_organization_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "global_organization_name", value)

    @_builtins.property
    @pulumi.getter(name="orgId")
    def org_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Equinix-assigned ID of the subscriber's organization.
        """
        return pulumi.get(self, "org_id")

    @org_id.setter
    def org_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "org_id", value)

    @_builtins.property
    @pulumi.getter(name="organizationName")
    def organization_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Equinix-assigned name of the subscriber's organization.
        """
        return pulumi.get(self, "organization_name")

    @organization_name.setter
    def organization_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "organization_name", value)

    @_builtins.property
    @pulumi.getter(name="ucmId")
    def ucm_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Enterprise datastore id
        """
        return pulumi.get(self, "ucm_id")

    @ucm_id.setter
    def ucm_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ucm_id", value)


if not MYPY:
    class ConnectionASideAccessPointGatewayArgsDict(TypedDict):
        href: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unique Resource Identifier
        """
        uuid: NotRequired[pulumi.Input[_builtins.str]]
        """
        Equinix-assigned virtual gateway identifier
        """
elif False:
    ConnectionASideAccessPointGatewayArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionASideAccessPointGatewayArgs:
    def __init__(__self__, *,
                 href: Optional[pulumi.Input[_builtins.str]] = None,
                 uuid: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] href: Unique Resource Identifier
        :param pulumi.Input[_builtins.str] uuid: Equinix-assigned virtual gateway identifier
        """
        if href is not None:
            pulumi.set(__self__, "href", href)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unique Resource Identifier
        """
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "href", value)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Equinix-assigned virtual gateway identifier
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class ConnectionASideAccessPointInterfaceArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.int]]
        """
        id
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Interface type
        """
        uuid: NotRequired[pulumi.Input[_builtins.str]]
        """
        Equinix-assigned interface identifier
        """
elif False:
    ConnectionASideAccessPointInterfaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionASideAccessPointInterfaceArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.int]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 uuid: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] id: id
        :param pulumi.Input[_builtins.str] type: Interface type
        :param pulumi.Input[_builtins.str] uuid: Equinix-assigned interface identifier
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        id
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Interface type
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Equinix-assigned interface identifier
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class ConnectionASideAccessPointLinkProtocolArgsDict(TypedDict):
        type: NotRequired[pulumi.Input[Union[_builtins.str, 'AccessPointLinkProtocolType']]]
        """
        Type of the link protocol - UNTAGGED, DOT1Q, QINQ, EVPN_VXLAN
        """
        vlan_c_tag: NotRequired[pulumi.Input[_builtins.int]]
        """
        Vlan Customer Tag information, vlanCTag value specified for QINQ connections
        """
        vlan_s_tag: NotRequired[pulumi.Input[_builtins.int]]
        """
        Vlan Provider Tag information, vlanSTag value specified for QINQ connections
        """
        vlan_tag: NotRequired[pulumi.Input[_builtins.int]]
        """
        Vlan Tag information, vlanTag value specified for DOT1Q connections
        """
elif False:
    ConnectionASideAccessPointLinkProtocolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionASideAccessPointLinkProtocolArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[Union[_builtins.str, 'AccessPointLinkProtocolType']]] = None,
                 vlan_c_tag: Optional[pulumi.Input[_builtins.int]] = None,
                 vlan_s_tag: Optional[pulumi.Input[_builtins.int]] = None,
                 vlan_tag: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[Union[_builtins.str, 'AccessPointLinkProtocolType']] type: Type of the link protocol - UNTAGGED, DOT1Q, QINQ, EVPN_VXLAN
        :param pulumi.Input[_builtins.int] vlan_c_tag: Vlan Customer Tag information, vlanCTag value specified for QINQ connections
        :param pulumi.Input[_builtins.int] vlan_s_tag: Vlan Provider Tag information, vlanSTag value specified for QINQ connections
        :param pulumi.Input[_builtins.int] vlan_tag: Vlan Tag information, vlanTag value specified for DOT1Q connections
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if vlan_c_tag is not None:
            pulumi.set(__self__, "vlan_c_tag", vlan_c_tag)
        if vlan_s_tag is not None:
            pulumi.set(__self__, "vlan_s_tag", vlan_s_tag)
        if vlan_tag is not None:
            pulumi.set(__self__, "vlan_tag", vlan_tag)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[Union[_builtins.str, 'AccessPointLinkProtocolType']]]:
        """
        Type of the link protocol - UNTAGGED, DOT1Q, QINQ, EVPN_VXLAN
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[Union[_builtins.str, 'AccessPointLinkProtocolType']]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="vlanCTag")
    def vlan_c_tag(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Vlan Customer Tag information, vlanCTag value specified for QINQ connections
        """
        return pulumi.get(self, "vlan_c_tag")

    @vlan_c_tag.setter
    def vlan_c_tag(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "vlan_c_tag", value)

    @_builtins.property
    @pulumi.getter(name="vlanSTag")
    def vlan_s_tag(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Vlan Provider Tag information, vlanSTag value specified for QINQ connections
        """
        return pulumi.get(self, "vlan_s_tag")

    @vlan_s_tag.setter
    def vlan_s_tag(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "vlan_s_tag", value)

    @_builtins.property
    @pulumi.getter(name="vlanTag")
    def vlan_tag(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Vlan Tag information, vlanTag value specified for DOT1Q connections
        """
        return pulumi.get(self, "vlan_tag")

    @vlan_tag.setter
    def vlan_tag(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "vlan_tag", value)


if not MYPY:
    class ConnectionASideAccessPointLocationArgsDict(TypedDict):
        ibx: NotRequired[pulumi.Input[_builtins.str]]
        """
        IBX Code
        """
        metro_code: NotRequired[pulumi.Input[Union[_builtins.str, '_root_enums.Metro']]]
        """
        Access point metro code
        """
        metro_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Access point metro name
        """
        region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Access point region
        """
elif False:
    ConnectionASideAccessPointLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionASideAccessPointLocationArgs:
    def __init__(__self__, *,
                 ibx: Optional[pulumi.Input[_builtins.str]] = None,
                 metro_code: Optional[pulumi.Input[Union[_builtins.str, '_root_enums.Metro']]] = None,
                 metro_name: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ibx: IBX Code
        :param pulumi.Input[Union[_builtins.str, '_root_enums.Metro']] metro_code: Access point metro code
        :param pulumi.Input[_builtins.str] metro_name: Access point metro name
        :param pulumi.Input[_builtins.str] region: Access point region
        """
        if ibx is not None:
            pulumi.set(__self__, "ibx", ibx)
        if metro_code is not None:
            pulumi.set(__self__, "metro_code", metro_code)
        if metro_name is not None:
            pulumi.set(__self__, "metro_name", metro_name)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def ibx(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IBX Code
        """
        return pulumi.get(self, "ibx")

    @ibx.setter
    def ibx(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ibx", value)

    @_builtins.property
    @pulumi.getter(name="metroCode")
    def metro_code(self) -> Optional[pulumi.Input[Union[_builtins.str, '_root_enums.Metro']]]:
        """
        Access point metro code
        """
        return pulumi.get(self, "metro_code")

    @metro_code.setter
    def metro_code(self, value: Optional[pulumi.Input[Union[_builtins.str, '_root_enums.Metro']]]):
        pulumi.set(self, "metro_code", value)

    @_builtins.property
    @pulumi.getter(name="metroName")
    def metro_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Access point metro name
        """
        return pulumi.get(self, "metro_name")

    @metro_name.setter
    def metro_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metro_name", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Access point region
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)


if not MYPY:
    class ConnectionASideAccessPointNetworkArgsDict(TypedDict):
        uuid: pulumi.Input[_builtins.str]
        """
        Equinix-assigned Network identifier
        """
        href: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unique Resource Identifier
        """
elif False:
    ConnectionASideAccessPointNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionASideAccessPointNetworkArgs:
    def __init__(__self__, *,
                 uuid: pulumi.Input[_builtins.str],
                 href: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] uuid: Equinix-assigned Network identifier
        :param pulumi.Input[_builtins.str] href: Unique Resource Identifier
        """
        pulumi.set(__self__, "uuid", uuid)
        if href is not None:
            pulumi.set(__self__, "href", href)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> pulumi.Input[_builtins.str]:
        """
        Equinix-assigned Network identifier
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "uuid", value)

    @_builtins.property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unique Resource Identifier
        """
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "href", value)


if not MYPY:
    class ConnectionASideAccessPointPortArgsDict(TypedDict):
        href: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unique Resource Identifier
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Port name
        """
        redundancy: NotRequired[pulumi.Input['ConnectionASideAccessPointPortRedundancyArgsDict']]
        """
        Redundancy Information
        """
        uuid: NotRequired[pulumi.Input[_builtins.str]]
        """
        Equinix-assigned Port identifier
        """
elif False:
    ConnectionASideAccessPointPortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionASideAccessPointPortArgs:
    def __init__(__self__, *,
                 href: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 redundancy: Optional[pulumi.Input['ConnectionASideAccessPointPortRedundancyArgs']] = None,
                 uuid: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] href: Unique Resource Identifier
        :param pulumi.Input[_builtins.str] name: Port name
        :param pulumi.Input['ConnectionASideAccessPointPortRedundancyArgs'] redundancy: Redundancy Information
        :param pulumi.Input[_builtins.str] uuid: Equinix-assigned Port identifier
        """
        if href is not None:
            pulumi.set(__self__, "href", href)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if redundancy is not None:
            pulumi.set(__self__, "redundancy", redundancy)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unique Resource Identifier
        """
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "href", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Port name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def redundancy(self) -> Optional[pulumi.Input['ConnectionASideAccessPointPortRedundancyArgs']]:
        """
        Redundancy Information
        """
        return pulumi.get(self, "redundancy")

    @redundancy.setter
    def redundancy(self, value: Optional[pulumi.Input['ConnectionASideAccessPointPortRedundancyArgs']]):
        pulumi.set(self, "redundancy", value)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Equinix-assigned Port identifier
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class ConnectionASideAccessPointPortRedundancyArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Access point redundancy
        """
        group: NotRequired[pulumi.Input[_builtins.str]]
        """
        Port redundancy group
        """
        priority: NotRequired[pulumi.Input[_builtins.str]]
        """
        Priority type-Primary or Secondary
        """
elif False:
    ConnectionASideAccessPointPortRedundancyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionASideAccessPointPortRedundancyArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 group: Optional[pulumi.Input[_builtins.str]] = None,
                 priority: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Access point redundancy
        :param pulumi.Input[_builtins.str] group: Port redundancy group
        :param pulumi.Input[_builtins.str] priority: Priority type-Primary or Secondary
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Access point redundancy
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Port redundancy group
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Priority type-Primary or Secondary
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "priority", value)


if not MYPY:
    class ConnectionASideAccessPointProfileArgsDict(TypedDict):
        type: pulumi.Input[Union[_builtins.str, 'ProfileType']]
        """
        Service profile type - L2*PROFILE, L3*PROFILE, ECIA*PROFILE, ECMC*PROFILE, IA_PROFILE
        """
        uuid: pulumi.Input[_builtins.str]
        """
        Equinix assigned service profile identifier
        """
        access_point_type_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['ConnectionASideAccessPointProfileAccessPointTypeConfigArgsDict']]]]
        """
        Access point config information
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        User-provided service description
        """
        href: NotRequired[pulumi.Input[_builtins.str]]
        """
        Service Profile URI response attribute
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Customer-assigned service profile name
        """
elif False:
    ConnectionASideAccessPointProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionASideAccessPointProfileArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[Union[_builtins.str, 'ProfileType']],
                 uuid: pulumi.Input[_builtins.str],
                 access_point_type_configs: Optional[pulumi.Input[Sequence[pulumi.Input['ConnectionASideAccessPointProfileAccessPointTypeConfigArgs']]]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 href: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Union[_builtins.str, 'ProfileType']] type: Service profile type - L2*PROFILE, L3*PROFILE, ECIA*PROFILE, ECMC*PROFILE, IA_PROFILE
        :param pulumi.Input[_builtins.str] uuid: Equinix assigned service profile identifier
        :param pulumi.Input[Sequence[pulumi.Input['ConnectionASideAccessPointProfileAccessPointTypeConfigArgs']]] access_point_type_configs: Access point config information
        :param pulumi.Input[_builtins.str] description: User-provided service description
        :param pulumi.Input[_builtins.str] href: Service Profile URI response attribute
        :param pulumi.Input[_builtins.str] name: Customer-assigned service profile name
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "uuid", uuid)
        if access_point_type_configs is not None:
            pulumi.set(__self__, "access_point_type_configs", access_point_type_configs)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if href is not None:
            pulumi.set(__self__, "href", href)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[Union[_builtins.str, 'ProfileType']]:
        """
        Service profile type - L2*PROFILE, L3*PROFILE, ECIA*PROFILE, ECMC*PROFILE, IA_PROFILE
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[Union[_builtins.str, 'ProfileType']]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> pulumi.Input[_builtins.str]:
        """
        Equinix assigned service profile identifier
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "uuid", value)

    @_builtins.property
    @pulumi.getter(name="accessPointTypeConfigs")
    def access_point_type_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ConnectionASideAccessPointProfileAccessPointTypeConfigArgs']]]]:
        """
        Access point config information
        """
        return pulumi.get(self, "access_point_type_configs")

    @access_point_type_configs.setter
    def access_point_type_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ConnectionASideAccessPointProfileAccessPointTypeConfigArgs']]]]):
        pulumi.set(self, "access_point_type_configs", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        User-provided service description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Service Profile URI response attribute
        """
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "href", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Customer-assigned service profile name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ConnectionASideAccessPointProfileAccessPointTypeConfigArgsDict(TypedDict):
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type of access point type config - VD, COLO
        """
        uuid: NotRequired[pulumi.Input[_builtins.str]]
        """
        Equinix-assigned access point type config identifier
        """
elif False:
    ConnectionASideAccessPointProfileAccessPointTypeConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionASideAccessPointProfileAccessPointTypeConfigArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 uuid: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Type of access point type config - VD, COLO
        :param pulumi.Input[_builtins.str] uuid: Equinix-assigned access point type config identifier
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type of access point type config - VD, COLO
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Equinix-assigned access point type config identifier
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class ConnectionASideAccessPointRouterArgsDict(TypedDict):
        href: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unique Resource Identifier
        """
        uuid: NotRequired[pulumi.Input[_builtins.str]]
        """
        Equinix-assigned virtual gateway identifier
        """
elif False:
    ConnectionASideAccessPointRouterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionASideAccessPointRouterArgs:
    def __init__(__self__, *,
                 href: Optional[pulumi.Input[_builtins.str]] = None,
                 uuid: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] href: Unique Resource Identifier
        :param pulumi.Input[_builtins.str] uuid: Equinix-assigned virtual gateway identifier
        """
        if href is not None:
            pulumi.set(__self__, "href", href)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unique Resource Identifier
        """
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "href", value)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Equinix-assigned virtual gateway identifier
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class ConnectionASideAccessPointVirtualDeviceArgsDict(TypedDict):
        uuid: pulumi.Input[_builtins.str]
        """
        Equinix-assigned Virtual Device identifier
        """
        href: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unique Resource Identifier
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Customer-assigned Virtual Device Name
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Virtual Device type
        """
elif False:
    ConnectionASideAccessPointVirtualDeviceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionASideAccessPointVirtualDeviceArgs:
    def __init__(__self__, *,
                 uuid: pulumi.Input[_builtins.str],
                 href: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] uuid: Equinix-assigned Virtual Device identifier
        :param pulumi.Input[_builtins.str] href: Unique Resource Identifier
        :param pulumi.Input[_builtins.str] name: Customer-assigned Virtual Device Name
        :param pulumi.Input[_builtins.str] type: Virtual Device type
        """
        pulumi.set(__self__, "uuid", uuid)
        if href is not None:
            pulumi.set(__self__, "href", href)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> pulumi.Input[_builtins.str]:
        """
        Equinix-assigned Virtual Device identifier
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "uuid", value)

    @_builtins.property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unique Resource Identifier
        """
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "href", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Customer-assigned Virtual Device Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Virtual Device type
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ConnectionASideAdditionalInfoArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Additional information key
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Additional information value
        """
elif False:
    ConnectionASideAdditionalInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionASideAdditionalInfoArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: Additional information key
        :param pulumi.Input[_builtins.str] value: Additional information value
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Additional information key
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Additional information value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ConnectionASideServiceTokenArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Service token description
        """
        href: NotRequired[pulumi.Input[_builtins.str]]
        """
        An absolute URL that is the subject of the link's context
        """
        type: NotRequired[pulumi.Input[Union[_builtins.str, 'ServiceTokenType']]]
        """
        Token type - VC_TOKEN
        """
        uuid: NotRequired[pulumi.Input[_builtins.str]]
        """
        Equinix-assigned service token identifier
        """
elif False:
    ConnectionASideServiceTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionASideServiceTokenArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 href: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[Union[_builtins.str, 'ServiceTokenType']]] = None,
                 uuid: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: Service token description
        :param pulumi.Input[_builtins.str] href: An absolute URL that is the subject of the link's context
        :param pulumi.Input[Union[_builtins.str, 'ServiceTokenType']] type: Token type - VC_TOKEN
        :param pulumi.Input[_builtins.str] uuid: Equinix-assigned service token identifier
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if href is not None:
            pulumi.set(__self__, "href", href)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Service token description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An absolute URL that is the subject of the link's context
        """
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "href", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[Union[_builtins.str, 'ServiceTokenType']]]:
        """
        Token type - VC_TOKEN
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[Union[_builtins.str, 'ServiceTokenType']]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Equinix-assigned service token identifier
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class ConnectionAccountArgsDict(TypedDict):
        account_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Legal name of the accountholder.
        """
        account_number: NotRequired[pulumi.Input[_builtins.int]]
        """
        Equinix-assigned account number.
        """
        global_cust_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Equinix-assigned ID of the subscriber's parent organization.
        """
        global_org_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Equinix-assigned ID of the subscriber's parent organization.
        """
        global_organization_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Equinix-assigned name of the subscriber's parent organization.
        """
        org_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        Equinix-assigned ID of the subscriber's organization.
        """
        organization_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Equinix-assigned name of the subscriber's organization.
        """
        ucm_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Enterprise datastore id
        """
elif False:
    ConnectionAccountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionAccountArgs:
    def __init__(__self__, *,
                 account_name: Optional[pulumi.Input[_builtins.str]] = None,
                 account_number: Optional[pulumi.Input[_builtins.int]] = None,
                 global_cust_id: Optional[pulumi.Input[_builtins.str]] = None,
                 global_org_id: Optional[pulumi.Input[_builtins.str]] = None,
                 global_organization_name: Optional[pulumi.Input[_builtins.str]] = None,
                 org_id: Optional[pulumi.Input[_builtins.int]] = None,
                 organization_name: Optional[pulumi.Input[_builtins.str]] = None,
                 ucm_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] account_name: Legal name of the accountholder.
        :param pulumi.Input[_builtins.int] account_number: Equinix-assigned account number.
        :param pulumi.Input[_builtins.str] global_cust_id: Equinix-assigned ID of the subscriber's parent organization.
        :param pulumi.Input[_builtins.str] global_org_id: Equinix-assigned ID of the subscriber's parent organization.
        :param pulumi.Input[_builtins.str] global_organization_name: Equinix-assigned name of the subscriber's parent organization.
        :param pulumi.Input[_builtins.int] org_id: Equinix-assigned ID of the subscriber's organization.
        :param pulumi.Input[_builtins.str] organization_name: Equinix-assigned name of the subscriber's organization.
        :param pulumi.Input[_builtins.str] ucm_id: Enterprise datastore id
        """
        if account_name is not None:
            pulumi.set(__self__, "account_name", account_name)
        if account_number is not None:
            pulumi.set(__self__, "account_number", account_number)
        if global_cust_id is not None:
            pulumi.set(__self__, "global_cust_id", global_cust_id)
        if global_org_id is not None:
            pulumi.set(__self__, "global_org_id", global_org_id)
        if global_organization_name is not None:
            pulumi.set(__self__, "global_organization_name", global_organization_name)
        if org_id is not None:
            pulumi.set(__self__, "org_id", org_id)
        if organization_name is not None:
            pulumi.set(__self__, "organization_name", organization_name)
        if ucm_id is not None:
            pulumi.set(__self__, "ucm_id", ucm_id)

    @_builtins.property
    @pulumi.getter(name="accountName")
    def account_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Legal name of the accountholder.
        """
        return pulumi.get(self, "account_name")

    @account_name.setter
    def account_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "account_name", value)

    @_builtins.property
    @pulumi.getter(name="accountNumber")
    def account_number(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Equinix-assigned account number.
        """
        return pulumi.get(self, "account_number")

    @account_number.setter
    def account_number(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "account_number", value)

    @_builtins.property
    @pulumi.getter(name="globalCustId")
    def global_cust_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Equinix-assigned ID of the subscriber's parent organization.
        """
        return pulumi.get(self, "global_cust_id")

    @global_cust_id.setter
    def global_cust_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "global_cust_id", value)

    @_builtins.property
    @pulumi.getter(name="globalOrgId")
    def global_org_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Equinix-assigned ID of the subscriber's parent organization.
        """
        return pulumi.get(self, "global_org_id")

    @global_org_id.setter
    def global_org_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "global_org_id", value)

    @_builtins.property
    @pulumi.getter(name="globalOrganizationName")
    def global_organization_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Equinix-assigned name of the subscriber's parent organization.
        """
        return pulumi.get(self, "global_organization_name")

    @global_organization_name.setter
    def global_organization_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "global_organization_name", value)

    @_builtins.property
    @pulumi.getter(name="orgId")
    def org_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Equinix-assigned ID of the subscriber's organization.
        """
        return pulumi.get(self, "org_id")

    @org_id.setter
    def org_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "org_id", value)

    @_builtins.property
    @pulumi.getter(name="organizationName")
    def organization_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Equinix-assigned name of the subscriber's organization.
        """
        return pulumi.get(self, "organization_name")

    @organization_name.setter
    def organization_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "organization_name", value)

    @_builtins.property
    @pulumi.getter(name="ucmId")
    def ucm_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Enterprise datastore id
        """
        return pulumi.get(self, "ucm_id")

    @ucm_id.setter
    def ucm_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ucm_id", value)


if not MYPY:
    class ConnectionChangeLogArgsDict(TypedDict):
        created_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        Created by User Key
        """
        created_by_email: NotRequired[pulumi.Input[_builtins.str]]
        """
        Created by User Email Address
        """
        created_by_full_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Created by User Full Name
        """
        created_date_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Created by Date and Time
        """
        deleted_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        Deleted by User Key
        """
        deleted_by_email: NotRequired[pulumi.Input[_builtins.str]]
        """
        Deleted by User Email Address
        """
        deleted_by_full_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Deleted by User Full Name
        """
        deleted_date_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Deleted by Date and Time
        """
        updated_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        Updated by User Key
        """
        updated_by_email: NotRequired[pulumi.Input[_builtins.str]]
        """
        Updated by User Email Address
        """
        updated_by_full_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Updated by User Full Name
        """
        updated_date_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Updated by Date and Time
        """
elif False:
    ConnectionChangeLogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionChangeLogArgs:
    def __init__(__self__, *,
                 created_by: Optional[pulumi.Input[_builtins.str]] = None,
                 created_by_email: Optional[pulumi.Input[_builtins.str]] = None,
                 created_by_full_name: Optional[pulumi.Input[_builtins.str]] = None,
                 created_date_time: Optional[pulumi.Input[_builtins.str]] = None,
                 deleted_by: Optional[pulumi.Input[_builtins.str]] = None,
                 deleted_by_email: Optional[pulumi.Input[_builtins.str]] = None,
                 deleted_by_full_name: Optional[pulumi.Input[_builtins.str]] = None,
                 deleted_date_time: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_by: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_by_email: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_by_full_name: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_date_time: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] created_by: Created by User Key
        :param pulumi.Input[_builtins.str] created_by_email: Created by User Email Address
        :param pulumi.Input[_builtins.str] created_by_full_name: Created by User Full Name
        :param pulumi.Input[_builtins.str] created_date_time: Created by Date and Time
        :param pulumi.Input[_builtins.str] deleted_by: Deleted by User Key
        :param pulumi.Input[_builtins.str] deleted_by_email: Deleted by User Email Address
        :param pulumi.Input[_builtins.str] deleted_by_full_name: Deleted by User Full Name
        :param pulumi.Input[_builtins.str] deleted_date_time: Deleted by Date and Time
        :param pulumi.Input[_builtins.str] updated_by: Updated by User Key
        :param pulumi.Input[_builtins.str] updated_by_email: Updated by User Email Address
        :param pulumi.Input[_builtins.str] updated_by_full_name: Updated by User Full Name
        :param pulumi.Input[_builtins.str] updated_date_time: Updated by Date and Time
        """
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if created_by_email is not None:
            pulumi.set(__self__, "created_by_email", created_by_email)
        if created_by_full_name is not None:
            pulumi.set(__self__, "created_by_full_name", created_by_full_name)
        if created_date_time is not None:
            pulumi.set(__self__, "created_date_time", created_date_time)
        if deleted_by is not None:
            pulumi.set(__self__, "deleted_by", deleted_by)
        if deleted_by_email is not None:
            pulumi.set(__self__, "deleted_by_email", deleted_by_email)
        if deleted_by_full_name is not None:
            pulumi.set(__self__, "deleted_by_full_name", deleted_by_full_name)
        if deleted_date_time is not None:
            pulumi.set(__self__, "deleted_date_time", deleted_date_time)
        if updated_by is not None:
            pulumi.set(__self__, "updated_by", updated_by)
        if updated_by_email is not None:
            pulumi.set(__self__, "updated_by_email", updated_by_email)
        if updated_by_full_name is not None:
            pulumi.set(__self__, "updated_by_full_name", updated_by_full_name)
        if updated_date_time is not None:
            pulumi.set(__self__, "updated_date_time", updated_date_time)

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Created by User Key
        """
        return pulumi.get(self, "created_by")

    @created_by.setter
    def created_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_by", value)

    @_builtins.property
    @pulumi.getter(name="createdByEmail")
    def created_by_email(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Created by User Email Address
        """
        return pulumi.get(self, "created_by_email")

    @created_by_email.setter
    def created_by_email(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_by_email", value)

    @_builtins.property
    @pulumi.getter(name="createdByFullName")
    def created_by_full_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Created by User Full Name
        """
        return pulumi.get(self, "created_by_full_name")

    @created_by_full_name.setter
    def created_by_full_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_by_full_name", value)

    @_builtins.property
    @pulumi.getter(name="createdDateTime")
    def created_date_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Created by Date and Time
        """
        return pulumi.get(self, "created_date_time")

    @created_date_time.setter
    def created_date_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_date_time", value)

    @_builtins.property
    @pulumi.getter(name="deletedBy")
    def deleted_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Deleted by User Key
        """
        return pulumi.get(self, "deleted_by")

    @deleted_by.setter
    def deleted_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deleted_by", value)

    @_builtins.property
    @pulumi.getter(name="deletedByEmail")
    def deleted_by_email(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Deleted by User Email Address
        """
        return pulumi.get(self, "deleted_by_email")

    @deleted_by_email.setter
    def deleted_by_email(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deleted_by_email", value)

    @_builtins.property
    @pulumi.getter(name="deletedByFullName")
    def deleted_by_full_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Deleted by User Full Name
        """
        return pulumi.get(self, "deleted_by_full_name")

    @deleted_by_full_name.setter
    def deleted_by_full_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deleted_by_full_name", value)

    @_builtins.property
    @pulumi.getter(name="deletedDateTime")
    def deleted_date_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Deleted by Date and Time
        """
        return pulumi.get(self, "deleted_date_time")

    @deleted_date_time.setter
    def deleted_date_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deleted_date_time", value)

    @_builtins.property
    @pulumi.getter(name="updatedBy")
    def updated_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Updated by User Key
        """
        return pulumi.get(self, "updated_by")

    @updated_by.setter
    def updated_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_by", value)

    @_builtins.property
    @pulumi.getter(name="updatedByEmail")
    def updated_by_email(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Updated by User Email Address
        """
        return pulumi.get(self, "updated_by_email")

    @updated_by_email.setter
    def updated_by_email(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_by_email", value)

    @_builtins.property
    @pulumi.getter(name="updatedByFullName")
    def updated_by_full_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Updated by User Full Name
        """
        return pulumi.get(self, "updated_by_full_name")

    @updated_by_full_name.setter
    def updated_by_full_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_by_full_name", value)

    @_builtins.property
    @pulumi.getter(name="updatedDateTime")
    def updated_date_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Updated by Date and Time
        """
        return pulumi.get(self, "updated_date_time")

    @updated_date_time.setter
    def updated_date_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_date_time", value)


if not MYPY:
    class ConnectionNotificationArgsDict(TypedDict):
        emails: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Array of contact emails
        """
        type: pulumi.Input[Union[_builtins.str, 'NotificationsType']]
        """
        Notification Type - ALL,CONNECTION*APPROVAL,SALES*REP_NOTIFICATIONS, NOTIFICATIONS
        """
        send_interval: NotRequired[pulumi.Input[_builtins.str]]
        """
        Send interval
        """
elif False:
    ConnectionNotificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionNotificationArgs:
    def __init__(__self__, *,
                 emails: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 type: pulumi.Input[Union[_builtins.str, 'NotificationsType']],
                 send_interval: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] emails: Array of contact emails
        :param pulumi.Input[Union[_builtins.str, 'NotificationsType']] type: Notification Type - ALL,CONNECTION*APPROVAL,SALES*REP_NOTIFICATIONS, NOTIFICATIONS
        :param pulumi.Input[_builtins.str] send_interval: Send interval
        """
        pulumi.set(__self__, "emails", emails)
        pulumi.set(__self__, "type", type)
        if send_interval is not None:
            pulumi.set(__self__, "send_interval", send_interval)

    @_builtins.property
    @pulumi.getter
    def emails(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Array of contact emails
        """
        return pulumi.get(self, "emails")

    @emails.setter
    def emails(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "emails", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[Union[_builtins.str, 'NotificationsType']]:
        """
        Notification Type - ALL,CONNECTION*APPROVAL,SALES*REP_NOTIFICATIONS, NOTIFICATIONS
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[Union[_builtins.str, 'NotificationsType']]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="sendInterval")
    def send_interval(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Send interval
        """
        return pulumi.get(self, "send_interval")

    @send_interval.setter
    def send_interval(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "send_interval", value)


if not MYPY:
    class ConnectionOperationArgsDict(TypedDict):
        equinix_status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Connection status
        """
        errors: NotRequired[pulumi.Input[Sequence[pulumi.Input['ConnectionOperationErrorArgsDict']]]]
        """
        Errors occurred
        """
        provider_status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Connection provider readiness status
        """
elif False:
    ConnectionOperationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionOperationArgs:
    def __init__(__self__, *,
                 equinix_status: Optional[pulumi.Input[_builtins.str]] = None,
                 errors: Optional[pulumi.Input[Sequence[pulumi.Input['ConnectionOperationErrorArgs']]]] = None,
                 provider_status: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] equinix_status: Connection status
        :param pulumi.Input[Sequence[pulumi.Input['ConnectionOperationErrorArgs']]] errors: Errors occurred
        :param pulumi.Input[_builtins.str] provider_status: Connection provider readiness status
        """
        if equinix_status is not None:
            pulumi.set(__self__, "equinix_status", equinix_status)
        if errors is not None:
            pulumi.set(__self__, "errors", errors)
        if provider_status is not None:
            pulumi.set(__self__, "provider_status", provider_status)

    @_builtins.property
    @pulumi.getter(name="equinixStatus")
    def equinix_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Connection status
        """
        return pulumi.get(self, "equinix_status")

    @equinix_status.setter
    def equinix_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "equinix_status", value)

    @_builtins.property
    @pulumi.getter
    def errors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ConnectionOperationErrorArgs']]]]:
        """
        Errors occurred
        """
        return pulumi.get(self, "errors")

    @errors.setter
    def errors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ConnectionOperationErrorArgs']]]]):
        pulumi.set(self, "errors", value)

    @_builtins.property
    @pulumi.getter(name="providerStatus")
    def provider_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Connection provider readiness status
        """
        return pulumi.get(self, "provider_status")

    @provider_status.setter
    def provider_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "provider_status", value)


if not MYPY:
    class ConnectionOperationErrorArgsDict(TypedDict):
        additional_info: NotRequired[pulumi.Input[Sequence[pulumi.Input['ConnectionOperationErrorAdditionalInfoArgsDict']]]]
        """
        Pricing error additional Info
        """
        correlation_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        CorrelationId
        """
        details: NotRequired[pulumi.Input[_builtins.str]]
        """
        Details
        """
        error_code: NotRequired[pulumi.Input[_builtins.str]]
        """
        Error  code
        """
        error_message: NotRequired[pulumi.Input[_builtins.str]]
        """
        Error Message
        """
        help: NotRequired[pulumi.Input[_builtins.str]]
        """
        Help
        """
elif False:
    ConnectionOperationErrorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionOperationErrorArgs:
    def __init__(__self__, *,
                 additional_info: Optional[pulumi.Input[Sequence[pulumi.Input['ConnectionOperationErrorAdditionalInfoArgs']]]] = None,
                 correlation_id: Optional[pulumi.Input[_builtins.str]] = None,
                 details: Optional[pulumi.Input[_builtins.str]] = None,
                 error_code: Optional[pulumi.Input[_builtins.str]] = None,
                 error_message: Optional[pulumi.Input[_builtins.str]] = None,
                 help: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ConnectionOperationErrorAdditionalInfoArgs']]] additional_info: Pricing error additional Info
        :param pulumi.Input[_builtins.str] correlation_id: CorrelationId
        :param pulumi.Input[_builtins.str] details: Details
        :param pulumi.Input[_builtins.str] error_code: Error  code
        :param pulumi.Input[_builtins.str] error_message: Error Message
        :param pulumi.Input[_builtins.str] help: Help
        """
        if additional_info is not None:
            pulumi.set(__self__, "additional_info", additional_info)
        if correlation_id is not None:
            pulumi.set(__self__, "correlation_id", correlation_id)
        if details is not None:
            pulumi.set(__self__, "details", details)
        if error_code is not None:
            pulumi.set(__self__, "error_code", error_code)
        if error_message is not None:
            pulumi.set(__self__, "error_message", error_message)
        if help is not None:
            pulumi.set(__self__, "help", help)

    @_builtins.property
    @pulumi.getter(name="additionalInfo")
    def additional_info(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ConnectionOperationErrorAdditionalInfoArgs']]]]:
        """
        Pricing error additional Info
        """
        return pulumi.get(self, "additional_info")

    @additional_info.setter
    def additional_info(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ConnectionOperationErrorAdditionalInfoArgs']]]]):
        pulumi.set(self, "additional_info", value)

    @_builtins.property
    @pulumi.getter(name="correlationId")
    def correlation_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        CorrelationId
        """
        return pulumi.get(self, "correlation_id")

    @correlation_id.setter
    def correlation_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "correlation_id", value)

    @_builtins.property
    @pulumi.getter
    def details(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Details
        """
        return pulumi.get(self, "details")

    @details.setter
    def details(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "details", value)

    @_builtins.property
    @pulumi.getter(name="errorCode")
    def error_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Error  code
        """
        return pulumi.get(self, "error_code")

    @error_code.setter
    def error_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "error_code", value)

    @_builtins.property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Error Message
        """
        return pulumi.get(self, "error_message")

    @error_message.setter
    def error_message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "error_message", value)

    @_builtins.property
    @pulumi.getter
    def help(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Help
        """
        return pulumi.get(self, "help")

    @help.setter
    def help(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "help", value)


if not MYPY:
    class ConnectionOperationErrorAdditionalInfoArgsDict(TypedDict):
        property: NotRequired[pulumi.Input[_builtins.str]]
        """
        Property at which the error potentially occurred
        """
        reason: NotRequired[pulumi.Input[_builtins.str]]
        """
        Reason for the error
        """
elif False:
    ConnectionOperationErrorAdditionalInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionOperationErrorAdditionalInfoArgs:
    def __init__(__self__, *,
                 property: Optional[pulumi.Input[_builtins.str]] = None,
                 reason: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] property: Property at which the error potentially occurred
        :param pulumi.Input[_builtins.str] reason: Reason for the error
        """
        if property is not None:
            pulumi.set(__self__, "property", property)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @_builtins.property
    @pulumi.getter
    def property(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Property at which the error potentially occurred
        """
        return pulumi.get(self, "property")

    @property.setter
    def property(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "property", value)

    @_builtins.property
    @pulumi.getter
    def reason(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Reason for the error
        """
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "reason", value)


if not MYPY:
    class ConnectionOrderArgsDict(TypedDict):
        billing_tier: NotRequired[pulumi.Input[_builtins.str]]
        """
        Billing tier for connection bandwidth
        """
        order_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Order Identification
        """
        order_number: NotRequired[pulumi.Input[_builtins.str]]
        """
        Order Reference Number
        """
        purchase_order_number: NotRequired[pulumi.Input[_builtins.str]]
        """
        Purchase order number
        """
        term_length: NotRequired[pulumi.Input[_builtins.int]]
        """
        Term length in months; valid values are 1, 12, 24, 36 where 1 is the default value (for on-demand case)
        """
elif False:
    ConnectionOrderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionOrderArgs:
    def __init__(__self__, *,
                 billing_tier: Optional[pulumi.Input[_builtins.str]] = None,
                 order_id: Optional[pulumi.Input[_builtins.str]] = None,
                 order_number: Optional[pulumi.Input[_builtins.str]] = None,
                 purchase_order_number: Optional[pulumi.Input[_builtins.str]] = None,
                 term_length: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] billing_tier: Billing tier for connection bandwidth
        :param pulumi.Input[_builtins.str] order_id: Order Identification
        :param pulumi.Input[_builtins.str] order_number: Order Reference Number
        :param pulumi.Input[_builtins.str] purchase_order_number: Purchase order number
        :param pulumi.Input[_builtins.int] term_length: Term length in months; valid values are 1, 12, 24, 36 where 1 is the default value (for on-demand case)
        """
        if billing_tier is not None:
            pulumi.set(__self__, "billing_tier", billing_tier)
        if order_id is not None:
            pulumi.set(__self__, "order_id", order_id)
        if order_number is not None:
            pulumi.set(__self__, "order_number", order_number)
        if purchase_order_number is not None:
            pulumi.set(__self__, "purchase_order_number", purchase_order_number)
        if term_length is not None:
            pulumi.set(__self__, "term_length", term_length)

    @_builtins.property
    @pulumi.getter(name="billingTier")
    def billing_tier(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Billing tier for connection bandwidth
        """
        return pulumi.get(self, "billing_tier")

    @billing_tier.setter
    def billing_tier(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "billing_tier", value)

    @_builtins.property
    @pulumi.getter(name="orderId")
    def order_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Order Identification
        """
        return pulumi.get(self, "order_id")

    @order_id.setter
    def order_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "order_id", value)

    @_builtins.property
    @pulumi.getter(name="orderNumber")
    def order_number(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Order Reference Number
        """
        return pulumi.get(self, "order_number")

    @order_number.setter
    def order_number(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "order_number", value)

    @_builtins.property
    @pulumi.getter(name="purchaseOrderNumber")
    def purchase_order_number(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Purchase order number
        """
        return pulumi.get(self, "purchase_order_number")

    @purchase_order_number.setter
    def purchase_order_number(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "purchase_order_number", value)

    @_builtins.property
    @pulumi.getter(name="termLength")
    def term_length(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Term length in months; valid values are 1, 12, 24, 36 where 1 is the default value (for on-demand case)
        """
        return pulumi.get(self, "term_length")

    @term_length.setter
    def term_length(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "term_length", value)


if not MYPY:
    class ConnectionProjectArgsDict(TypedDict):
        href: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unique Resource URL
        """
        project_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Project Id
        """
elif False:
    ConnectionProjectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionProjectArgs:
    def __init__(__self__, *,
                 href: Optional[pulumi.Input[_builtins.str]] = None,
                 project_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] href: Unique Resource URL
        :param pulumi.Input[_builtins.str] project_id: Project Id
        """
        if href is not None:
            pulumi.set(__self__, "href", href)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)

    @_builtins.property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unique Resource URL
        """
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "href", value)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Project Id
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "project_id", value)


if not MYPY:
    class ConnectionRedundancyArgsDict(TypedDict):
        group: NotRequired[pulumi.Input[_builtins.str]]
        """
        Redundancy group identifier (Use the redundancy.0.group UUID of primary connection; e.g. one(equinix*fabric*connection.primary*port*connection.redundancy).group or equinix*fabric*connection.primary*port*connection.redundancy.0.group)
        """
        priority: NotRequired[pulumi.Input[_builtins.str]]
        """
        Connection priority in redundancy group - PRIMARY, SECONDARY
        """
elif False:
    ConnectionRedundancyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionRedundancyArgs:
    def __init__(__self__, *,
                 group: Optional[pulumi.Input[_builtins.str]] = None,
                 priority: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] group: Redundancy group identifier (Use the redundancy.0.group UUID of primary connection; e.g. one(equinix*fabric*connection.primary*port*connection.redundancy).group or equinix*fabric*connection.primary*port*connection.redundancy.0.group)
        :param pulumi.Input[_builtins.str] priority: Connection priority in redundancy group - PRIMARY, SECONDARY
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)

    @_builtins.property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Redundancy group identifier (Use the redundancy.0.group UUID of primary connection; e.g. one(equinix*fabric*connection.primary*port*connection.redundancy).group or equinix*fabric*connection.primary*port*connection.redundancy.0.group)
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Connection priority in redundancy group - PRIMARY, SECONDARY
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "priority", value)


if not MYPY:
    class ConnectionRouteAggregationTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        read: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    ConnectionRouteAggregationTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionRouteAggregationTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 read: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if read is not None:
            pulumi.set(__self__, "read", read)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def read(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @read.setter
    def read(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "read", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class ConnectionZSideArgsDict(TypedDict):
        access_point: NotRequired[pulumi.Input['ConnectionZSideAccessPointArgsDict']]
        """
        Point of access details
        """
        additional_info: NotRequired[pulumi.Input[Sequence[pulumi.Input['ConnectionZSideAdditionalInfoArgsDict']]]]
        """
        Connection side additional information
        """
        service_token: NotRequired[pulumi.Input['ConnectionZSideServiceTokenArgsDict']]
        """
        For service token based connections, Service tokens authorize users to access protected resources and services. Resource owners can distribute the tokens to trusted partners and vendors, allowing selected third parties to work directly with Equinix network assets
        """
elif False:
    ConnectionZSideArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionZSideArgs:
    def __init__(__self__, *,
                 access_point: Optional[pulumi.Input['ConnectionZSideAccessPointArgs']] = None,
                 additional_info: Optional[pulumi.Input[Sequence[pulumi.Input['ConnectionZSideAdditionalInfoArgs']]]] = None,
                 service_token: Optional[pulumi.Input['ConnectionZSideServiceTokenArgs']] = None):
        """
        :param pulumi.Input['ConnectionZSideAccessPointArgs'] access_point: Point of access details
        :param pulumi.Input[Sequence[pulumi.Input['ConnectionZSideAdditionalInfoArgs']]] additional_info: Connection side additional information
        :param pulumi.Input['ConnectionZSideServiceTokenArgs'] service_token: For service token based connections, Service tokens authorize users to access protected resources and services. Resource owners can distribute the tokens to trusted partners and vendors, allowing selected third parties to work directly with Equinix network assets
        """
        if access_point is not None:
            pulumi.set(__self__, "access_point", access_point)
        if additional_info is not None:
            pulumi.set(__self__, "additional_info", additional_info)
        if service_token is not None:
            pulumi.set(__self__, "service_token", service_token)

    @_builtins.property
    @pulumi.getter(name="accessPoint")
    def access_point(self) -> Optional[pulumi.Input['ConnectionZSideAccessPointArgs']]:
        """
        Point of access details
        """
        return pulumi.get(self, "access_point")

    @access_point.setter
    def access_point(self, value: Optional[pulumi.Input['ConnectionZSideAccessPointArgs']]):
        pulumi.set(self, "access_point", value)

    @_builtins.property
    @pulumi.getter(name="additionalInfo")
    def additional_info(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ConnectionZSideAdditionalInfoArgs']]]]:
        """
        Connection side additional information
        """
        return pulumi.get(self, "additional_info")

    @additional_info.setter
    def additional_info(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ConnectionZSideAdditionalInfoArgs']]]]):
        pulumi.set(self, "additional_info", value)

    @_builtins.property
    @pulumi.getter(name="serviceToken")
    def service_token(self) -> Optional[pulumi.Input['ConnectionZSideServiceTokenArgs']]:
        """
        For service token based connections, Service tokens authorize users to access protected resources and services. Resource owners can distribute the tokens to trusted partners and vendors, allowing selected third parties to work directly with Equinix network assets
        """
        return pulumi.get(self, "service_token")

    @service_token.setter
    def service_token(self, value: Optional[pulumi.Input['ConnectionZSideServiceTokenArgs']]):
        pulumi.set(self, "service_token", value)


if not MYPY:
    class ConnectionZSideAccessPointArgsDict(TypedDict):
        account: NotRequired[pulumi.Input['ConnectionZSideAccessPointAccountArgsDict']]
        """
        Account
        """
        authentication_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Authentication key for provider based connections or Metal-Fabric Integration connections
        """
        gateway: NotRequired[pulumi.Input['ConnectionZSideAccessPointGatewayArgsDict']]
        """
        **Deprecated** `gateway` Use `router` attribute instead
        """
        interface: NotRequired[pulumi.Input['ConnectionZSideAccessPointInterfaceArgsDict']]
        """
        Virtual device interface
        """
        link_protocol: NotRequired[pulumi.Input['ConnectionZSideAccessPointLinkProtocolArgsDict']]
        """
        Connection link protocol
        """
        location: NotRequired[pulumi.Input['ConnectionZSideAccessPointLocationArgsDict']]
        """
        Access point location
        """
        network: NotRequired[pulumi.Input['ConnectionZSideAccessPointNetworkArgsDict']]
        """
        network access point information
        """
        peering_type: NotRequired[pulumi.Input[Union[_builtins.str, 'AccessPointPeeringType']]]
        """
        Peering Type- PRIVATE,MICROSOFT,PUBLIC, MANUAL
        """
        port: NotRequired[pulumi.Input['ConnectionZSideAccessPointPortArgsDict']]
        """
        Port access point information
        """
        profile: NotRequired[pulumi.Input['ConnectionZSideAccessPointProfileArgsDict']]
        """
        Service Profile
        """
        provider_connection_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Provider assigned Connection Id
        """
        router: NotRequired[pulumi.Input['ConnectionZSideAccessPointRouterArgsDict']]
        """
        Cloud Router access point information that replaces `gateway`
        """
        seller_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Access point seller region
        """
        type: NotRequired[pulumi.Input[Union[_builtins.str, 'AccessPointType']]]
        """
        Access point type - COLO, VD, VG, SP, IGW, SUBNET, CLOUD*ROUTER, NETWORK, METAL*NETWORK
        """
        virtual_device: NotRequired[pulumi.Input['ConnectionZSideAccessPointVirtualDeviceArgsDict']]
        """
        Virtual device
        """
elif False:
    ConnectionZSideAccessPointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionZSideAccessPointArgs:
    def __init__(__self__, *,
                 account: Optional[pulumi.Input['ConnectionZSideAccessPointAccountArgs']] = None,
                 authentication_key: Optional[pulumi.Input[_builtins.str]] = None,
                 gateway: Optional[pulumi.Input['ConnectionZSideAccessPointGatewayArgs']] = None,
                 interface: Optional[pulumi.Input['ConnectionZSideAccessPointInterfaceArgs']] = None,
                 link_protocol: Optional[pulumi.Input['ConnectionZSideAccessPointLinkProtocolArgs']] = None,
                 location: Optional[pulumi.Input['ConnectionZSideAccessPointLocationArgs']] = None,
                 network: Optional[pulumi.Input['ConnectionZSideAccessPointNetworkArgs']] = None,
                 peering_type: Optional[pulumi.Input[Union[_builtins.str, 'AccessPointPeeringType']]] = None,
                 port: Optional[pulumi.Input['ConnectionZSideAccessPointPortArgs']] = None,
                 profile: Optional[pulumi.Input['ConnectionZSideAccessPointProfileArgs']] = None,
                 provider_connection_id: Optional[pulumi.Input[_builtins.str]] = None,
                 router: Optional[pulumi.Input['ConnectionZSideAccessPointRouterArgs']] = None,
                 seller_region: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[Union[_builtins.str, 'AccessPointType']]] = None,
                 virtual_device: Optional[pulumi.Input['ConnectionZSideAccessPointVirtualDeviceArgs']] = None):
        """
        :param pulumi.Input['ConnectionZSideAccessPointAccountArgs'] account: Account
        :param pulumi.Input[_builtins.str] authentication_key: Authentication key for provider based connections or Metal-Fabric Integration connections
        :param pulumi.Input['ConnectionZSideAccessPointGatewayArgs'] gateway: **Deprecated** `gateway` Use `router` attribute instead
        :param pulumi.Input['ConnectionZSideAccessPointInterfaceArgs'] interface: Virtual device interface
        :param pulumi.Input['ConnectionZSideAccessPointLinkProtocolArgs'] link_protocol: Connection link protocol
        :param pulumi.Input['ConnectionZSideAccessPointLocationArgs'] location: Access point location
        :param pulumi.Input['ConnectionZSideAccessPointNetworkArgs'] network: network access point information
        :param pulumi.Input[Union[_builtins.str, 'AccessPointPeeringType']] peering_type: Peering Type- PRIVATE,MICROSOFT,PUBLIC, MANUAL
        :param pulumi.Input['ConnectionZSideAccessPointPortArgs'] port: Port access point information
        :param pulumi.Input['ConnectionZSideAccessPointProfileArgs'] profile: Service Profile
        :param pulumi.Input[_builtins.str] provider_connection_id: Provider assigned Connection Id
        :param pulumi.Input['ConnectionZSideAccessPointRouterArgs'] router: Cloud Router access point information that replaces `gateway`
        :param pulumi.Input[_builtins.str] seller_region: Access point seller region
        :param pulumi.Input[Union[_builtins.str, 'AccessPointType']] type: Access point type - COLO, VD, VG, SP, IGW, SUBNET, CLOUD*ROUTER, NETWORK, METAL*NETWORK
        :param pulumi.Input['ConnectionZSideAccessPointVirtualDeviceArgs'] virtual_device: Virtual device
        """
        if account is not None:
            pulumi.set(__self__, "account", account)
        if authentication_key is not None:
            pulumi.set(__self__, "authentication_key", authentication_key)
        if gateway is not None:
            warnings.warn("""use router attribute instead; gateway is no longer a part of the supported backend""", DeprecationWarning)
            pulumi.log.warn("""gateway is deprecated: use router attribute instead; gateway is no longer a part of the supported backend""")
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if interface is not None:
            pulumi.set(__self__, "interface", interface)
        if link_protocol is not None:
            pulumi.set(__self__, "link_protocol", link_protocol)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if peering_type is not None:
            pulumi.set(__self__, "peering_type", peering_type)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if profile is not None:
            pulumi.set(__self__, "profile", profile)
        if provider_connection_id is not None:
            pulumi.set(__self__, "provider_connection_id", provider_connection_id)
        if router is not None:
            pulumi.set(__self__, "router", router)
        if seller_region is not None:
            pulumi.set(__self__, "seller_region", seller_region)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if virtual_device is not None:
            pulumi.set(__self__, "virtual_device", virtual_device)

    @_builtins.property
    @pulumi.getter
    def account(self) -> Optional[pulumi.Input['ConnectionZSideAccessPointAccountArgs']]:
        """
        Account
        """
        return pulumi.get(self, "account")

    @account.setter
    def account(self, value: Optional[pulumi.Input['ConnectionZSideAccessPointAccountArgs']]):
        pulumi.set(self, "account", value)

    @_builtins.property
    @pulumi.getter(name="authenticationKey")
    def authentication_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Authentication key for provider based connections or Metal-Fabric Integration connections
        """
        return pulumi.get(self, "authentication_key")

    @authentication_key.setter
    def authentication_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "authentication_key", value)

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""use router attribute instead; gateway is no longer a part of the supported backend""")
    def gateway(self) -> Optional[pulumi.Input['ConnectionZSideAccessPointGatewayArgs']]:
        """
        **Deprecated** `gateway` Use `router` attribute instead
        """
        return pulumi.get(self, "gateway")

    @gateway.setter
    def gateway(self, value: Optional[pulumi.Input['ConnectionZSideAccessPointGatewayArgs']]):
        pulumi.set(self, "gateway", value)

    @_builtins.property
    @pulumi.getter
    def interface(self) -> Optional[pulumi.Input['ConnectionZSideAccessPointInterfaceArgs']]:
        """
        Virtual device interface
        """
        return pulumi.get(self, "interface")

    @interface.setter
    def interface(self, value: Optional[pulumi.Input['ConnectionZSideAccessPointInterfaceArgs']]):
        pulumi.set(self, "interface", value)

    @_builtins.property
    @pulumi.getter(name="linkProtocol")
    def link_protocol(self) -> Optional[pulumi.Input['ConnectionZSideAccessPointLinkProtocolArgs']]:
        """
        Connection link protocol
        """
        return pulumi.get(self, "link_protocol")

    @link_protocol.setter
    def link_protocol(self, value: Optional[pulumi.Input['ConnectionZSideAccessPointLinkProtocolArgs']]):
        pulumi.set(self, "link_protocol", value)

    @_builtins.property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input['ConnectionZSideAccessPointLocationArgs']]:
        """
        Access point location
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input['ConnectionZSideAccessPointLocationArgs']]):
        pulumi.set(self, "location", value)

    @_builtins.property
    @pulumi.getter
    def network(self) -> Optional[pulumi.Input['ConnectionZSideAccessPointNetworkArgs']]:
        """
        network access point information
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: Optional[pulumi.Input['ConnectionZSideAccessPointNetworkArgs']]):
        pulumi.set(self, "network", value)

    @_builtins.property
    @pulumi.getter(name="peeringType")
    def peering_type(self) -> Optional[pulumi.Input[Union[_builtins.str, 'AccessPointPeeringType']]]:
        """
        Peering Type- PRIVATE,MICROSOFT,PUBLIC, MANUAL
        """
        return pulumi.get(self, "peering_type")

    @peering_type.setter
    def peering_type(self, value: Optional[pulumi.Input[Union[_builtins.str, 'AccessPointPeeringType']]]):
        pulumi.set(self, "peering_type", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input['ConnectionZSideAccessPointPortArgs']]:
        """
        Port access point information
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input['ConnectionZSideAccessPointPortArgs']]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def profile(self) -> Optional[pulumi.Input['ConnectionZSideAccessPointProfileArgs']]:
        """
        Service Profile
        """
        return pulumi.get(self, "profile")

    @profile.setter
    def profile(self, value: Optional[pulumi.Input['ConnectionZSideAccessPointProfileArgs']]):
        pulumi.set(self, "profile", value)

    @_builtins.property
    @pulumi.getter(name="providerConnectionId")
    def provider_connection_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Provider assigned Connection Id
        """
        return pulumi.get(self, "provider_connection_id")

    @provider_connection_id.setter
    def provider_connection_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "provider_connection_id", value)

    @_builtins.property
    @pulumi.getter
    def router(self) -> Optional[pulumi.Input['ConnectionZSideAccessPointRouterArgs']]:
        """
        Cloud Router access point information that replaces `gateway`
        """
        return pulumi.get(self, "router")

    @router.setter
    def router(self, value: Optional[pulumi.Input['ConnectionZSideAccessPointRouterArgs']]):
        pulumi.set(self, "router", value)

    @_builtins.property
    @pulumi.getter(name="sellerRegion")
    def seller_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Access point seller region
        """
        return pulumi.get(self, "seller_region")

    @seller_region.setter
    def seller_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "seller_region", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[Union[_builtins.str, 'AccessPointType']]]:
        """
        Access point type - COLO, VD, VG, SP, IGW, SUBNET, CLOUD*ROUTER, NETWORK, METAL*NETWORK
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[Union[_builtins.str, 'AccessPointType']]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="virtualDevice")
    def virtual_device(self) -> Optional[pulumi.Input['ConnectionZSideAccessPointVirtualDeviceArgs']]:
        """
        Virtual device
        """
        return pulumi.get(self, "virtual_device")

    @virtual_device.setter
    def virtual_device(self, value: Optional[pulumi.Input['ConnectionZSideAccessPointVirtualDeviceArgs']]):
        pulumi.set(self, "virtual_device", value)


if not MYPY:
    class ConnectionZSideAccessPointAccountArgsDict(TypedDict):
        account_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Legal name of the accountholder.
        """
        account_number: NotRequired[pulumi.Input[_builtins.int]]
        """
        Equinix-assigned account number.
        """
        global_cust_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Equinix-assigned ID of the subscriber's parent organization.
        """
        global_org_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Equinix-assigned ID of the subscriber's parent organization.
        """
        global_organization_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Equinix-assigned name of the subscriber's parent organization.
        """
        org_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        Equinix-assigned ID of the subscriber's organization.
        """
        organization_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Equinix-assigned name of the subscriber's organization.
        """
        ucm_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Enterprise datastore id
        """
elif False:
    ConnectionZSideAccessPointAccountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionZSideAccessPointAccountArgs:
    def __init__(__self__, *,
                 account_name: Optional[pulumi.Input[_builtins.str]] = None,
                 account_number: Optional[pulumi.Input[_builtins.int]] = None,
                 global_cust_id: Optional[pulumi.Input[_builtins.str]] = None,
                 global_org_id: Optional[pulumi.Input[_builtins.str]] = None,
                 global_organization_name: Optional[pulumi.Input[_builtins.str]] = None,
                 org_id: Optional[pulumi.Input[_builtins.int]] = None,
                 organization_name: Optional[pulumi.Input[_builtins.str]] = None,
                 ucm_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] account_name: Legal name of the accountholder.
        :param pulumi.Input[_builtins.int] account_number: Equinix-assigned account number.
        :param pulumi.Input[_builtins.str] global_cust_id: Equinix-assigned ID of the subscriber's parent organization.
        :param pulumi.Input[_builtins.str] global_org_id: Equinix-assigned ID of the subscriber's parent organization.
        :param pulumi.Input[_builtins.str] global_organization_name: Equinix-assigned name of the subscriber's parent organization.
        :param pulumi.Input[_builtins.int] org_id: Equinix-assigned ID of the subscriber's organization.
        :param pulumi.Input[_builtins.str] organization_name: Equinix-assigned name of the subscriber's organization.
        :param pulumi.Input[_builtins.str] ucm_id: Enterprise datastore id
        """
        if account_name is not None:
            pulumi.set(__self__, "account_name", account_name)
        if account_number is not None:
            pulumi.set(__self__, "account_number", account_number)
        if global_cust_id is not None:
            pulumi.set(__self__, "global_cust_id", global_cust_id)
        if global_org_id is not None:
            pulumi.set(__self__, "global_org_id", global_org_id)
        if global_organization_name is not None:
            pulumi.set(__self__, "global_organization_name", global_organization_name)
        if org_id is not None:
            pulumi.set(__self__, "org_id", org_id)
        if organization_name is not None:
            pulumi.set(__self__, "organization_name", organization_name)
        if ucm_id is not None:
            pulumi.set(__self__, "ucm_id", ucm_id)

    @_builtins.property
    @pulumi.getter(name="accountName")
    def account_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Legal name of the accountholder.
        """
        return pulumi.get(self, "account_name")

    @account_name.setter
    def account_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "account_name", value)

    @_builtins.property
    @pulumi.getter(name="accountNumber")
    def account_number(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Equinix-assigned account number.
        """
        return pulumi.get(self, "account_number")

    @account_number.setter
    def account_number(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "account_number", value)

    @_builtins.property
    @pulumi.getter(name="globalCustId")
    def global_cust_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Equinix-assigned ID of the subscriber's parent organization.
        """
        return pulumi.get(self, "global_cust_id")

    @global_cust_id.setter
    def global_cust_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "global_cust_id", value)

    @_builtins.property
    @pulumi.getter(name="globalOrgId")
    def global_org_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Equinix-assigned ID of the subscriber's parent organization.
        """
        return pulumi.get(self, "global_org_id")

    @global_org_id.setter
    def global_org_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "global_org_id", value)

    @_builtins.property
    @pulumi.getter(name="globalOrganizationName")
    def global_organization_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Equinix-assigned name of the subscriber's parent organization.
        """
        return pulumi.get(self, "global_organization_name")

    @global_organization_name.setter
    def global_organization_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "global_organization_name", value)

    @_builtins.property
    @pulumi.getter(name="orgId")
    def org_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Equinix-assigned ID of the subscriber's organization.
        """
        return pulumi.get(self, "org_id")

    @org_id.setter
    def org_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "org_id", value)

    @_builtins.property
    @pulumi.getter(name="organizationName")
    def organization_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Equinix-assigned name of the subscriber's organization.
        """
        return pulumi.get(self, "organization_name")

    @organization_name.setter
    def organization_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "organization_name", value)

    @_builtins.property
    @pulumi.getter(name="ucmId")
    def ucm_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Enterprise datastore id
        """
        return pulumi.get(self, "ucm_id")

    @ucm_id.setter
    def ucm_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ucm_id", value)


if not MYPY:
    class ConnectionZSideAccessPointGatewayArgsDict(TypedDict):
        href: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unique Resource Identifier
        """
        uuid: NotRequired[pulumi.Input[_builtins.str]]
        """
        Equinix-assigned virtual gateway identifier
        """
elif False:
    ConnectionZSideAccessPointGatewayArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionZSideAccessPointGatewayArgs:
    def __init__(__self__, *,
                 href: Optional[pulumi.Input[_builtins.str]] = None,
                 uuid: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] href: Unique Resource Identifier
        :param pulumi.Input[_builtins.str] uuid: Equinix-assigned virtual gateway identifier
        """
        if href is not None:
            pulumi.set(__self__, "href", href)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unique Resource Identifier
        """
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "href", value)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Equinix-assigned virtual gateway identifier
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class ConnectionZSideAccessPointInterfaceArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.int]]
        """
        id
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Interface type
        """
        uuid: NotRequired[pulumi.Input[_builtins.str]]
        """
        Equinix-assigned interface identifier
        """
elif False:
    ConnectionZSideAccessPointInterfaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionZSideAccessPointInterfaceArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.int]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 uuid: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] id: id
        :param pulumi.Input[_builtins.str] type: Interface type
        :param pulumi.Input[_builtins.str] uuid: Equinix-assigned interface identifier
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        id
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Interface type
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Equinix-assigned interface identifier
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class ConnectionZSideAccessPointLinkProtocolArgsDict(TypedDict):
        type: NotRequired[pulumi.Input[Union[_builtins.str, 'AccessPointLinkProtocolType']]]
        """
        Type of the link protocol - UNTAGGED, DOT1Q, QINQ, EVPN_VXLAN
        """
        vlan_c_tag: NotRequired[pulumi.Input[_builtins.int]]
        """
        Vlan Customer Tag information, vlanCTag value specified for QINQ connections
        """
        vlan_s_tag: NotRequired[pulumi.Input[_builtins.int]]
        """
        Vlan Provider Tag information, vlanSTag value specified for QINQ connections
        """
        vlan_tag: NotRequired[pulumi.Input[_builtins.int]]
        """
        Vlan Tag information, vlanTag value specified for DOT1Q connections
        """
elif False:
    ConnectionZSideAccessPointLinkProtocolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionZSideAccessPointLinkProtocolArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[Union[_builtins.str, 'AccessPointLinkProtocolType']]] = None,
                 vlan_c_tag: Optional[pulumi.Input[_builtins.int]] = None,
                 vlan_s_tag: Optional[pulumi.Input[_builtins.int]] = None,
                 vlan_tag: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[Union[_builtins.str, 'AccessPointLinkProtocolType']] type: Type of the link protocol - UNTAGGED, DOT1Q, QINQ, EVPN_VXLAN
        :param pulumi.Input[_builtins.int] vlan_c_tag: Vlan Customer Tag information, vlanCTag value specified for QINQ connections
        :param pulumi.Input[_builtins.int] vlan_s_tag: Vlan Provider Tag information, vlanSTag value specified for QINQ connections
        :param pulumi.Input[_builtins.int] vlan_tag: Vlan Tag information, vlanTag value specified for DOT1Q connections
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if vlan_c_tag is not None:
            pulumi.set(__self__, "vlan_c_tag", vlan_c_tag)
        if vlan_s_tag is not None:
            pulumi.set(__self__, "vlan_s_tag", vlan_s_tag)
        if vlan_tag is not None:
            pulumi.set(__self__, "vlan_tag", vlan_tag)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[Union[_builtins.str, 'AccessPointLinkProtocolType']]]:
        """
        Type of the link protocol - UNTAGGED, DOT1Q, QINQ, EVPN_VXLAN
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[Union[_builtins.str, 'AccessPointLinkProtocolType']]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="vlanCTag")
    def vlan_c_tag(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Vlan Customer Tag information, vlanCTag value specified for QINQ connections
        """
        return pulumi.get(self, "vlan_c_tag")

    @vlan_c_tag.setter
    def vlan_c_tag(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "vlan_c_tag", value)

    @_builtins.property
    @pulumi.getter(name="vlanSTag")
    def vlan_s_tag(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Vlan Provider Tag information, vlanSTag value specified for QINQ connections
        """
        return pulumi.get(self, "vlan_s_tag")

    @vlan_s_tag.setter
    def vlan_s_tag(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "vlan_s_tag", value)

    @_builtins.property
    @pulumi.getter(name="vlanTag")
    def vlan_tag(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Vlan Tag information, vlanTag value specified for DOT1Q connections
        """
        return pulumi.get(self, "vlan_tag")

    @vlan_tag.setter
    def vlan_tag(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "vlan_tag", value)


if not MYPY:
    class ConnectionZSideAccessPointLocationArgsDict(TypedDict):
        ibx: NotRequired[pulumi.Input[_builtins.str]]
        """
        IBX Code
        """
        metro_code: NotRequired[pulumi.Input[Union[_builtins.str, '_root_enums.Metro']]]
        """
        Access point metro code
        """
        metro_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Access point metro name
        """
        region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Access point region
        """
elif False:
    ConnectionZSideAccessPointLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionZSideAccessPointLocationArgs:
    def __init__(__self__, *,
                 ibx: Optional[pulumi.Input[_builtins.str]] = None,
                 metro_code: Optional[pulumi.Input[Union[_builtins.str, '_root_enums.Metro']]] = None,
                 metro_name: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ibx: IBX Code
        :param pulumi.Input[Union[_builtins.str, '_root_enums.Metro']] metro_code: Access point metro code
        :param pulumi.Input[_builtins.str] metro_name: Access point metro name
        :param pulumi.Input[_builtins.str] region: Access point region
        """
        if ibx is not None:
            pulumi.set(__self__, "ibx", ibx)
        if metro_code is not None:
            pulumi.set(__self__, "metro_code", metro_code)
        if metro_name is not None:
            pulumi.set(__self__, "metro_name", metro_name)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def ibx(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IBX Code
        """
        return pulumi.get(self, "ibx")

    @ibx.setter
    def ibx(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ibx", value)

    @_builtins.property
    @pulumi.getter(name="metroCode")
    def metro_code(self) -> Optional[pulumi.Input[Union[_builtins.str, '_root_enums.Metro']]]:
        """
        Access point metro code
        """
        return pulumi.get(self, "metro_code")

    @metro_code.setter
    def metro_code(self, value: Optional[pulumi.Input[Union[_builtins.str, '_root_enums.Metro']]]):
        pulumi.set(self, "metro_code", value)

    @_builtins.property
    @pulumi.getter(name="metroName")
    def metro_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Access point metro name
        """
        return pulumi.get(self, "metro_name")

    @metro_name.setter
    def metro_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metro_name", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Access point region
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)


if not MYPY:
    class ConnectionZSideAccessPointNetworkArgsDict(TypedDict):
        uuid: pulumi.Input[_builtins.str]
        """
        Equinix-assigned Network identifier
        """
        href: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unique Resource Identifier
        """
elif False:
    ConnectionZSideAccessPointNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionZSideAccessPointNetworkArgs:
    def __init__(__self__, *,
                 uuid: pulumi.Input[_builtins.str],
                 href: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] uuid: Equinix-assigned Network identifier
        :param pulumi.Input[_builtins.str] href: Unique Resource Identifier
        """
        pulumi.set(__self__, "uuid", uuid)
        if href is not None:
            pulumi.set(__self__, "href", href)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> pulumi.Input[_builtins.str]:
        """
        Equinix-assigned Network identifier
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "uuid", value)

    @_builtins.property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unique Resource Identifier
        """
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "href", value)


if not MYPY:
    class ConnectionZSideAccessPointPortArgsDict(TypedDict):
        href: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unique Resource Identifier
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Port name
        """
        redundancy: NotRequired[pulumi.Input['ConnectionZSideAccessPointPortRedundancyArgsDict']]
        """
        Redundancy Information
        """
        uuid: NotRequired[pulumi.Input[_builtins.str]]
        """
        Equinix-assigned Port identifier
        """
elif False:
    ConnectionZSideAccessPointPortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionZSideAccessPointPortArgs:
    def __init__(__self__, *,
                 href: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 redundancy: Optional[pulumi.Input['ConnectionZSideAccessPointPortRedundancyArgs']] = None,
                 uuid: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] href: Unique Resource Identifier
        :param pulumi.Input[_builtins.str] name: Port name
        :param pulumi.Input['ConnectionZSideAccessPointPortRedundancyArgs'] redundancy: Redundancy Information
        :param pulumi.Input[_builtins.str] uuid: Equinix-assigned Port identifier
        """
        if href is not None:
            pulumi.set(__self__, "href", href)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if redundancy is not None:
            pulumi.set(__self__, "redundancy", redundancy)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unique Resource Identifier
        """
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "href", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Port name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def redundancy(self) -> Optional[pulumi.Input['ConnectionZSideAccessPointPortRedundancyArgs']]:
        """
        Redundancy Information
        """
        return pulumi.get(self, "redundancy")

    @redundancy.setter
    def redundancy(self, value: Optional[pulumi.Input['ConnectionZSideAccessPointPortRedundancyArgs']]):
        pulumi.set(self, "redundancy", value)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Equinix-assigned Port identifier
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class ConnectionZSideAccessPointPortRedundancyArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Access point redundancy
        """
        group: NotRequired[pulumi.Input[_builtins.str]]
        """
        Port redundancy group
        """
        priority: NotRequired[pulumi.Input[_builtins.str]]
        """
        Priority type-Primary or Secondary
        """
elif False:
    ConnectionZSideAccessPointPortRedundancyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionZSideAccessPointPortRedundancyArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 group: Optional[pulumi.Input[_builtins.str]] = None,
                 priority: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Access point redundancy
        :param pulumi.Input[_builtins.str] group: Port redundancy group
        :param pulumi.Input[_builtins.str] priority: Priority type-Primary or Secondary
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Access point redundancy
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Port redundancy group
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Priority type-Primary or Secondary
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "priority", value)


if not MYPY:
    class ConnectionZSideAccessPointProfileArgsDict(TypedDict):
        type: pulumi.Input[Union[_builtins.str, 'ProfileType']]
        """
        Service profile type - L2*PROFILE, L3*PROFILE, ECIA*PROFILE, ECMC*PROFILE, IA_PROFILE
        """
        uuid: pulumi.Input[_builtins.str]
        """
        Equinix assigned service profile identifier
        """
        access_point_type_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['ConnectionZSideAccessPointProfileAccessPointTypeConfigArgsDict']]]]
        """
        Access point config information
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        User-provided service description
        """
        href: NotRequired[pulumi.Input[_builtins.str]]
        """
        Service Profile URI response attribute
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Customer-assigned service profile name
        """
elif False:
    ConnectionZSideAccessPointProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionZSideAccessPointProfileArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[Union[_builtins.str, 'ProfileType']],
                 uuid: pulumi.Input[_builtins.str],
                 access_point_type_configs: Optional[pulumi.Input[Sequence[pulumi.Input['ConnectionZSideAccessPointProfileAccessPointTypeConfigArgs']]]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 href: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Union[_builtins.str, 'ProfileType']] type: Service profile type - L2*PROFILE, L3*PROFILE, ECIA*PROFILE, ECMC*PROFILE, IA_PROFILE
        :param pulumi.Input[_builtins.str] uuid: Equinix assigned service profile identifier
        :param pulumi.Input[Sequence[pulumi.Input['ConnectionZSideAccessPointProfileAccessPointTypeConfigArgs']]] access_point_type_configs: Access point config information
        :param pulumi.Input[_builtins.str] description: User-provided service description
        :param pulumi.Input[_builtins.str] href: Service Profile URI response attribute
        :param pulumi.Input[_builtins.str] name: Customer-assigned service profile name
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "uuid", uuid)
        if access_point_type_configs is not None:
            pulumi.set(__self__, "access_point_type_configs", access_point_type_configs)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if href is not None:
            pulumi.set(__self__, "href", href)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[Union[_builtins.str, 'ProfileType']]:
        """
        Service profile type - L2*PROFILE, L3*PROFILE, ECIA*PROFILE, ECMC*PROFILE, IA_PROFILE
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[Union[_builtins.str, 'ProfileType']]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> pulumi.Input[_builtins.str]:
        """
        Equinix assigned service profile identifier
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "uuid", value)

    @_builtins.property
    @pulumi.getter(name="accessPointTypeConfigs")
    def access_point_type_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ConnectionZSideAccessPointProfileAccessPointTypeConfigArgs']]]]:
        """
        Access point config information
        """
        return pulumi.get(self, "access_point_type_configs")

    @access_point_type_configs.setter
    def access_point_type_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ConnectionZSideAccessPointProfileAccessPointTypeConfigArgs']]]]):
        pulumi.set(self, "access_point_type_configs", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        User-provided service description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Service Profile URI response attribute
        """
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "href", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Customer-assigned service profile name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ConnectionZSideAccessPointProfileAccessPointTypeConfigArgsDict(TypedDict):
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type of access point type config - VD, COLO
        """
        uuid: NotRequired[pulumi.Input[_builtins.str]]
        """
        Equinix-assigned access point type config identifier
        """
elif False:
    ConnectionZSideAccessPointProfileAccessPointTypeConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionZSideAccessPointProfileAccessPointTypeConfigArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 uuid: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Type of access point type config - VD, COLO
        :param pulumi.Input[_builtins.str] uuid: Equinix-assigned access point type config identifier
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type of access point type config - VD, COLO
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Equinix-assigned access point type config identifier
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class ConnectionZSideAccessPointRouterArgsDict(TypedDict):
        href: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unique Resource Identifier
        """
        uuid: NotRequired[pulumi.Input[_builtins.str]]
        """
        Equinix-assigned virtual gateway identifier
        """
elif False:
    ConnectionZSideAccessPointRouterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionZSideAccessPointRouterArgs:
    def __init__(__self__, *,
                 href: Optional[pulumi.Input[_builtins.str]] = None,
                 uuid: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] href: Unique Resource Identifier
        :param pulumi.Input[_builtins.str] uuid: Equinix-assigned virtual gateway identifier
        """
        if href is not None:
            pulumi.set(__self__, "href", href)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unique Resource Identifier
        """
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "href", value)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Equinix-assigned virtual gateway identifier
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class ConnectionZSideAccessPointVirtualDeviceArgsDict(TypedDict):
        uuid: pulumi.Input[_builtins.str]
        """
        Equinix-assigned Virtual Device identifier
        """
        href: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unique Resource Identifier
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Customer-assigned Virtual Device Name
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Virtual Device type
        """
elif False:
    ConnectionZSideAccessPointVirtualDeviceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionZSideAccessPointVirtualDeviceArgs:
    def __init__(__self__, *,
                 uuid: pulumi.Input[_builtins.str],
                 href: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] uuid: Equinix-assigned Virtual Device identifier
        :param pulumi.Input[_builtins.str] href: Unique Resource Identifier
        :param pulumi.Input[_builtins.str] name: Customer-assigned Virtual Device Name
        :param pulumi.Input[_builtins.str] type: Virtual Device type
        """
        pulumi.set(__self__, "uuid", uuid)
        if href is not None:
            pulumi.set(__self__, "href", href)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> pulumi.Input[_builtins.str]:
        """
        Equinix-assigned Virtual Device identifier
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "uuid", value)

    @_builtins.property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unique Resource Identifier
        """
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "href", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Customer-assigned Virtual Device Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Virtual Device type
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ConnectionZSideAdditionalInfoArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Additional information key
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Additional information value
        """
elif False:
    ConnectionZSideAdditionalInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionZSideAdditionalInfoArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: Additional information key
        :param pulumi.Input[_builtins.str] value: Additional information value
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Additional information key
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Additional information value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ConnectionZSideServiceTokenArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Service token description
        """
        href: NotRequired[pulumi.Input[_builtins.str]]
        """
        An absolute URL that is the subject of the link's context
        """
        type: NotRequired[pulumi.Input[Union[_builtins.str, 'ServiceTokenType']]]
        """
        Token type - VC_TOKEN
        """
        uuid: NotRequired[pulumi.Input[_builtins.str]]
        """
        Equinix-assigned service token identifier
        """
elif False:
    ConnectionZSideServiceTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionZSideServiceTokenArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 href: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[Union[_builtins.str, 'ServiceTokenType']]] = None,
                 uuid: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: Service token description
        :param pulumi.Input[_builtins.str] href: An absolute URL that is the subject of the link's context
        :param pulumi.Input[Union[_builtins.str, 'ServiceTokenType']] type: Token type - VC_TOKEN
        :param pulumi.Input[_builtins.str] uuid: Equinix-assigned service token identifier
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if href is not None:
            pulumi.set(__self__, "href", href)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Service token description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An absolute URL that is the subject of the link's context
        """
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "href", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[Union[_builtins.str, 'ServiceTokenType']]]:
        """
        Token type - VC_TOKEN
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[Union[_builtins.str, 'ServiceTokenType']]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Equinix-assigned service token identifier
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class NetworkChangeArgsDict(TypedDict):
        href: NotRequired[pulumi.Input[_builtins.str]]
        """
        Absolute URL that returns the details of the given change.
        Example: https://api.equinix.com/fabric/v4/networks/92dc376a-a932-43aa-a6a2-c806dedbd784
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Asset instance change request type.: NETWORK_CREATION, NETWORK_UPDATE, NETWORK_DELETION
        """
        uuid: NotRequired[pulumi.Input[_builtins.str]]
        """
        Asset change request identifier.
        """
elif False:
    NetworkChangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkChangeArgs:
    def __init__(__self__, *,
                 href: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 uuid: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] href: Absolute URL that returns the details of the given change.
               Example: https://api.equinix.com/fabric/v4/networks/92dc376a-a932-43aa-a6a2-c806dedbd784
        :param pulumi.Input[_builtins.str] type: Asset instance change request type.: NETWORK_CREATION, NETWORK_UPDATE, NETWORK_DELETION
        :param pulumi.Input[_builtins.str] uuid: Asset change request identifier.
        """
        if href is not None:
            pulumi.set(__self__, "href", href)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Absolute URL that returns the details of the given change.
        Example: https://api.equinix.com/fabric/v4/networks/92dc376a-a932-43aa-a6a2-c806dedbd784
        """
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "href", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Asset instance change request type.: NETWORK_CREATION, NETWORK_UPDATE, NETWORK_DELETION
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Asset change request identifier.
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class NetworkChangeLogArgsDict(TypedDict):
        created_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        Created by User Key
        """
        created_by_email: NotRequired[pulumi.Input[_builtins.str]]
        """
        Created by User Email Address
        """
        created_by_full_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Created by User Full Name
        """
        created_date_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Created by Date and Time
        """
        deleted_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        Deleted by User Key
        """
        deleted_by_email: NotRequired[pulumi.Input[_builtins.str]]
        """
        Deleted by User Email Address
        """
        deleted_by_full_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Deleted by User Full Name
        """
        deleted_date_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Deleted by Date and Time
        """
        updated_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        Updated by User Key
        """
        updated_by_email: NotRequired[pulumi.Input[_builtins.str]]
        """
        Updated by User Email Address
        """
        updated_by_full_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Updated by User Full Name
        """
        updated_date_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Updated by Date and Time
        """
elif False:
    NetworkChangeLogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkChangeLogArgs:
    def __init__(__self__, *,
                 created_by: Optional[pulumi.Input[_builtins.str]] = None,
                 created_by_email: Optional[pulumi.Input[_builtins.str]] = None,
                 created_by_full_name: Optional[pulumi.Input[_builtins.str]] = None,
                 created_date_time: Optional[pulumi.Input[_builtins.str]] = None,
                 deleted_by: Optional[pulumi.Input[_builtins.str]] = None,
                 deleted_by_email: Optional[pulumi.Input[_builtins.str]] = None,
                 deleted_by_full_name: Optional[pulumi.Input[_builtins.str]] = None,
                 deleted_date_time: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_by: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_by_email: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_by_full_name: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_date_time: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] created_by: Created by User Key
        :param pulumi.Input[_builtins.str] created_by_email: Created by User Email Address
        :param pulumi.Input[_builtins.str] created_by_full_name: Created by User Full Name
        :param pulumi.Input[_builtins.str] created_date_time: Created by Date and Time
        :param pulumi.Input[_builtins.str] deleted_by: Deleted by User Key
        :param pulumi.Input[_builtins.str] deleted_by_email: Deleted by User Email Address
        :param pulumi.Input[_builtins.str] deleted_by_full_name: Deleted by User Full Name
        :param pulumi.Input[_builtins.str] deleted_date_time: Deleted by Date and Time
        :param pulumi.Input[_builtins.str] updated_by: Updated by User Key
        :param pulumi.Input[_builtins.str] updated_by_email: Updated by User Email Address
        :param pulumi.Input[_builtins.str] updated_by_full_name: Updated by User Full Name
        :param pulumi.Input[_builtins.str] updated_date_time: Updated by Date and Time
        """
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if created_by_email is not None:
            pulumi.set(__self__, "created_by_email", created_by_email)
        if created_by_full_name is not None:
            pulumi.set(__self__, "created_by_full_name", created_by_full_name)
        if created_date_time is not None:
            pulumi.set(__self__, "created_date_time", created_date_time)
        if deleted_by is not None:
            pulumi.set(__self__, "deleted_by", deleted_by)
        if deleted_by_email is not None:
            pulumi.set(__self__, "deleted_by_email", deleted_by_email)
        if deleted_by_full_name is not None:
            pulumi.set(__self__, "deleted_by_full_name", deleted_by_full_name)
        if deleted_date_time is not None:
            pulumi.set(__self__, "deleted_date_time", deleted_date_time)
        if updated_by is not None:
            pulumi.set(__self__, "updated_by", updated_by)
        if updated_by_email is not None:
            pulumi.set(__self__, "updated_by_email", updated_by_email)
        if updated_by_full_name is not None:
            pulumi.set(__self__, "updated_by_full_name", updated_by_full_name)
        if updated_date_time is not None:
            pulumi.set(__self__, "updated_date_time", updated_date_time)

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Created by User Key
        """
        return pulumi.get(self, "created_by")

    @created_by.setter
    def created_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_by", value)

    @_builtins.property
    @pulumi.getter(name="createdByEmail")
    def created_by_email(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Created by User Email Address
        """
        return pulumi.get(self, "created_by_email")

    @created_by_email.setter
    def created_by_email(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_by_email", value)

    @_builtins.property
    @pulumi.getter(name="createdByFullName")
    def created_by_full_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Created by User Full Name
        """
        return pulumi.get(self, "created_by_full_name")

    @created_by_full_name.setter
    def created_by_full_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_by_full_name", value)

    @_builtins.property
    @pulumi.getter(name="createdDateTime")
    def created_date_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Created by Date and Time
        """
        return pulumi.get(self, "created_date_time")

    @created_date_time.setter
    def created_date_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_date_time", value)

    @_builtins.property
    @pulumi.getter(name="deletedBy")
    def deleted_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Deleted by User Key
        """
        return pulumi.get(self, "deleted_by")

    @deleted_by.setter
    def deleted_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deleted_by", value)

    @_builtins.property
    @pulumi.getter(name="deletedByEmail")
    def deleted_by_email(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Deleted by User Email Address
        """
        return pulumi.get(self, "deleted_by_email")

    @deleted_by_email.setter
    def deleted_by_email(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deleted_by_email", value)

    @_builtins.property
    @pulumi.getter(name="deletedByFullName")
    def deleted_by_full_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Deleted by User Full Name
        """
        return pulumi.get(self, "deleted_by_full_name")

    @deleted_by_full_name.setter
    def deleted_by_full_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deleted_by_full_name", value)

    @_builtins.property
    @pulumi.getter(name="deletedDateTime")
    def deleted_date_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Deleted by Date and Time
        """
        return pulumi.get(self, "deleted_date_time")

    @deleted_date_time.setter
    def deleted_date_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deleted_date_time", value)

    @_builtins.property
    @pulumi.getter(name="updatedBy")
    def updated_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Updated by User Key
        """
        return pulumi.get(self, "updated_by")

    @updated_by.setter
    def updated_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_by", value)

    @_builtins.property
    @pulumi.getter(name="updatedByEmail")
    def updated_by_email(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Updated by User Email Address
        """
        return pulumi.get(self, "updated_by_email")

    @updated_by_email.setter
    def updated_by_email(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_by_email", value)

    @_builtins.property
    @pulumi.getter(name="updatedByFullName")
    def updated_by_full_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Updated by User Full Name
        """
        return pulumi.get(self, "updated_by_full_name")

    @updated_by_full_name.setter
    def updated_by_full_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_by_full_name", value)

    @_builtins.property
    @pulumi.getter(name="updatedDateTime")
    def updated_date_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Updated by Date and Time
        """
        return pulumi.get(self, "updated_date_time")

    @updated_date_time.setter
    def updated_date_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_date_time", value)


if not MYPY:
    class NetworkLocationArgsDict(TypedDict):
        ibx: NotRequired[pulumi.Input[_builtins.str]]
        """
        IBX Code
        """
        metro_code: NotRequired[pulumi.Input[_builtins.str]]
        """
        Access point metro code
        """
        metro_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Access point metro name
        """
        region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Access point region
        """
elif False:
    NetworkLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkLocationArgs:
    def __init__(__self__, *,
                 ibx: Optional[pulumi.Input[_builtins.str]] = None,
                 metro_code: Optional[pulumi.Input[_builtins.str]] = None,
                 metro_name: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ibx: IBX Code
        :param pulumi.Input[_builtins.str] metro_code: Access point metro code
        :param pulumi.Input[_builtins.str] metro_name: Access point metro name
        :param pulumi.Input[_builtins.str] region: Access point region
        """
        if ibx is not None:
            pulumi.set(__self__, "ibx", ibx)
        if metro_code is not None:
            pulumi.set(__self__, "metro_code", metro_code)
        if metro_name is not None:
            pulumi.set(__self__, "metro_name", metro_name)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def ibx(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IBX Code
        """
        return pulumi.get(self, "ibx")

    @ibx.setter
    def ibx(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ibx", value)

    @_builtins.property
    @pulumi.getter(name="metroCode")
    def metro_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Access point metro code
        """
        return pulumi.get(self, "metro_code")

    @metro_code.setter
    def metro_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metro_code", value)

    @_builtins.property
    @pulumi.getter(name="metroName")
    def metro_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Access point metro name
        """
        return pulumi.get(self, "metro_name")

    @metro_name.setter
    def metro_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metro_name", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Access point region
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)


if not MYPY:
    class NetworkNotificationArgsDict(TypedDict):
        emails: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Array of contact emails
        """
        type: pulumi.Input[_builtins.str]
        """
        Notification Type - ALL,CONNECTION*APPROVAL,SALES*REP_NOTIFICATIONS, NOTIFICATIONS
        """
        send_interval: NotRequired[pulumi.Input[_builtins.str]]
        """
        Send interval
        """
elif False:
    NetworkNotificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkNotificationArgs:
    def __init__(__self__, *,
                 emails: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 type: pulumi.Input[_builtins.str],
                 send_interval: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] emails: Array of contact emails
        :param pulumi.Input[_builtins.str] type: Notification Type - ALL,CONNECTION*APPROVAL,SALES*REP_NOTIFICATIONS, NOTIFICATIONS
        :param pulumi.Input[_builtins.str] send_interval: Send interval
        """
        pulumi.set(__self__, "emails", emails)
        pulumi.set(__self__, "type", type)
        if send_interval is not None:
            pulumi.set(__self__, "send_interval", send_interval)

    @_builtins.property
    @pulumi.getter
    def emails(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Array of contact emails
        """
        return pulumi.get(self, "emails")

    @emails.setter
    def emails(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "emails", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Notification Type - ALL,CONNECTION*APPROVAL,SALES*REP_NOTIFICATIONS, NOTIFICATIONS
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="sendInterval")
    def send_interval(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Send interval
        """
        return pulumi.get(self, "send_interval")

    @send_interval.setter
    def send_interval(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "send_interval", value)


if not MYPY:
    class NetworkOperationArgsDict(TypedDict):
        equinix_status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Progress towards provisioning a given asset.
        """
elif False:
    NetworkOperationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkOperationArgs:
    def __init__(__self__, *,
                 equinix_status: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] equinix_status: Progress towards provisioning a given asset.
        """
        if equinix_status is not None:
            pulumi.set(__self__, "equinix_status", equinix_status)

    @_builtins.property
    @pulumi.getter(name="equinixStatus")
    def equinix_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Progress towards provisioning a given asset.
        """
        return pulumi.get(self, "equinix_status")

    @equinix_status.setter
    def equinix_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "equinix_status", value)


if not MYPY:
    class NetworkProjectArgsDict(TypedDict):
        project_id: pulumi.Input[_builtins.str]
        """
        Customer project identifier
        """
elif False:
    NetworkProjectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkProjectArgs:
    def __init__(__self__, *,
                 project_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] project_id: Customer project identifier
        """
        pulumi.set(__self__, "project_id", project_id)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> pulumi.Input[_builtins.str]:
        """
        Customer project identifier
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "project_id", value)


if not MYPY:
    class PrecisionTimeServiceAccountArgsDict(TypedDict):
        account_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Account Name
        """
        account_number: NotRequired[pulumi.Input[_builtins.int]]
        """
        Equinix Account Number
        """
        global_cust_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Global Customer Id
        """
        global_org_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Customer organization naidentifierme
        """
        global_organization_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Global organization name
        """
        org_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        Customer organization identifier
        """
        organization_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Customer organization name
        """
        reseller_account_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Reseller account name
        """
        reseller_account_number: NotRequired[pulumi.Input[_builtins.int]]
        """
        Reseller account number
        """
        reseller_org_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        Reseller customer organization identifier
        """
        reseller_ucm_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Reseller account ucmId
        """
        ucm_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Global organization name
        """
elif False:
    PrecisionTimeServiceAccountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrecisionTimeServiceAccountArgs:
    def __init__(__self__, *,
                 account_name: Optional[pulumi.Input[_builtins.str]] = None,
                 account_number: Optional[pulumi.Input[_builtins.int]] = None,
                 global_cust_id: Optional[pulumi.Input[_builtins.str]] = None,
                 global_org_id: Optional[pulumi.Input[_builtins.str]] = None,
                 global_organization_name: Optional[pulumi.Input[_builtins.str]] = None,
                 org_id: Optional[pulumi.Input[_builtins.int]] = None,
                 organization_name: Optional[pulumi.Input[_builtins.str]] = None,
                 reseller_account_name: Optional[pulumi.Input[_builtins.str]] = None,
                 reseller_account_number: Optional[pulumi.Input[_builtins.int]] = None,
                 reseller_org_id: Optional[pulumi.Input[_builtins.int]] = None,
                 reseller_ucm_id: Optional[pulumi.Input[_builtins.str]] = None,
                 ucm_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] account_name: Account Name
        :param pulumi.Input[_builtins.int] account_number: Equinix Account Number
        :param pulumi.Input[_builtins.str] global_cust_id: Global Customer Id
        :param pulumi.Input[_builtins.str] global_org_id: Customer organization naidentifierme
        :param pulumi.Input[_builtins.str] global_organization_name: Global organization name
        :param pulumi.Input[_builtins.int] org_id: Customer organization identifier
        :param pulumi.Input[_builtins.str] organization_name: Customer organization name
        :param pulumi.Input[_builtins.str] reseller_account_name: Reseller account name
        :param pulumi.Input[_builtins.int] reseller_account_number: Reseller account number
        :param pulumi.Input[_builtins.int] reseller_org_id: Reseller customer organization identifier
        :param pulumi.Input[_builtins.str] reseller_ucm_id: Reseller account ucmId
        :param pulumi.Input[_builtins.str] ucm_id: Global organization name
        """
        if account_name is not None:
            pulumi.set(__self__, "account_name", account_name)
        if account_number is not None:
            pulumi.set(__self__, "account_number", account_number)
        if global_cust_id is not None:
            pulumi.set(__self__, "global_cust_id", global_cust_id)
        if global_org_id is not None:
            pulumi.set(__self__, "global_org_id", global_org_id)
        if global_organization_name is not None:
            pulumi.set(__self__, "global_organization_name", global_organization_name)
        if org_id is not None:
            pulumi.set(__self__, "org_id", org_id)
        if organization_name is not None:
            pulumi.set(__self__, "organization_name", organization_name)
        if reseller_account_name is not None:
            pulumi.set(__self__, "reseller_account_name", reseller_account_name)
        if reseller_account_number is not None:
            pulumi.set(__self__, "reseller_account_number", reseller_account_number)
        if reseller_org_id is not None:
            pulumi.set(__self__, "reseller_org_id", reseller_org_id)
        if reseller_ucm_id is not None:
            pulumi.set(__self__, "reseller_ucm_id", reseller_ucm_id)
        if ucm_id is not None:
            pulumi.set(__self__, "ucm_id", ucm_id)

    @_builtins.property
    @pulumi.getter(name="accountName")
    def account_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Account Name
        """
        return pulumi.get(self, "account_name")

    @account_name.setter
    def account_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "account_name", value)

    @_builtins.property
    @pulumi.getter(name="accountNumber")
    def account_number(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Equinix Account Number
        """
        return pulumi.get(self, "account_number")

    @account_number.setter
    def account_number(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "account_number", value)

    @_builtins.property
    @pulumi.getter(name="globalCustId")
    def global_cust_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Global Customer Id
        """
        return pulumi.get(self, "global_cust_id")

    @global_cust_id.setter
    def global_cust_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "global_cust_id", value)

    @_builtins.property
    @pulumi.getter(name="globalOrgId")
    def global_org_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Customer organization naidentifierme
        """
        return pulumi.get(self, "global_org_id")

    @global_org_id.setter
    def global_org_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "global_org_id", value)

    @_builtins.property
    @pulumi.getter(name="globalOrganizationName")
    def global_organization_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Global organization name
        """
        return pulumi.get(self, "global_organization_name")

    @global_organization_name.setter
    def global_organization_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "global_organization_name", value)

    @_builtins.property
    @pulumi.getter(name="orgId")
    def org_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Customer organization identifier
        """
        return pulumi.get(self, "org_id")

    @org_id.setter
    def org_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "org_id", value)

    @_builtins.property
    @pulumi.getter(name="organizationName")
    def organization_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Customer organization name
        """
        return pulumi.get(self, "organization_name")

    @organization_name.setter
    def organization_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "organization_name", value)

    @_builtins.property
    @pulumi.getter(name="resellerAccountName")
    def reseller_account_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Reseller account name
        """
        return pulumi.get(self, "reseller_account_name")

    @reseller_account_name.setter
    def reseller_account_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "reseller_account_name", value)

    @_builtins.property
    @pulumi.getter(name="resellerAccountNumber")
    def reseller_account_number(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Reseller account number
        """
        return pulumi.get(self, "reseller_account_number")

    @reseller_account_number.setter
    def reseller_account_number(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "reseller_account_number", value)

    @_builtins.property
    @pulumi.getter(name="resellerOrgId")
    def reseller_org_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Reseller customer organization identifier
        """
        return pulumi.get(self, "reseller_org_id")

    @reseller_org_id.setter
    def reseller_org_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "reseller_org_id", value)

    @_builtins.property
    @pulumi.getter(name="resellerUcmId")
    def reseller_ucm_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Reseller account ucmId
        """
        return pulumi.get(self, "reseller_ucm_id")

    @reseller_ucm_id.setter
    def reseller_ucm_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "reseller_ucm_id", value)

    @_builtins.property
    @pulumi.getter(name="ucmId")
    def ucm_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Global organization name
        """
        return pulumi.get(self, "ucm_id")

    @ucm_id.setter
    def ucm_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ucm_id", value)


if not MYPY:
    class PrecisionTimeServiceChangeLogArgsDict(TypedDict):
        created_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        User name of creator of the route aggregation resource
        """
        created_by_email: NotRequired[pulumi.Input[_builtins.str]]
        """
        Email of creator of the route aggregation resource
        """
        created_by_full_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Legal name of creator of the route aggregation resource
        """
        created_date_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Creation time of the route aggregation resource
        """
        deleted_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        User name of deleter of the route aggregation resource
        """
        deleted_by_email: NotRequired[pulumi.Input[_builtins.str]]
        """
        Email of deleter of the route aggregation resource
        """
        deleted_by_full_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Legal name of deleter of the route aggregation resource
        """
        deleted_date_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Deletion time of the route aggregation resource
        """
        updated_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        User name of last updater of the route aggregation resource
        """
        updated_by_email: NotRequired[pulumi.Input[_builtins.str]]
        """
        Email of last updater of the route aggregation resource
        """
        updated_by_full_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Legal name of last updater of the route aggregation resource
        """
        updated_date_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Last update time of the route aggregation resource
        """
elif False:
    PrecisionTimeServiceChangeLogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrecisionTimeServiceChangeLogArgs:
    def __init__(__self__, *,
                 created_by: Optional[pulumi.Input[_builtins.str]] = None,
                 created_by_email: Optional[pulumi.Input[_builtins.str]] = None,
                 created_by_full_name: Optional[pulumi.Input[_builtins.str]] = None,
                 created_date_time: Optional[pulumi.Input[_builtins.str]] = None,
                 deleted_by: Optional[pulumi.Input[_builtins.str]] = None,
                 deleted_by_email: Optional[pulumi.Input[_builtins.str]] = None,
                 deleted_by_full_name: Optional[pulumi.Input[_builtins.str]] = None,
                 deleted_date_time: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_by: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_by_email: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_by_full_name: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_date_time: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] created_by: User name of creator of the route aggregation resource
        :param pulumi.Input[_builtins.str] created_by_email: Email of creator of the route aggregation resource
        :param pulumi.Input[_builtins.str] created_by_full_name: Legal name of creator of the route aggregation resource
        :param pulumi.Input[_builtins.str] created_date_time: Creation time of the route aggregation resource
        :param pulumi.Input[_builtins.str] deleted_by: User name of deleter of the route aggregation resource
        :param pulumi.Input[_builtins.str] deleted_by_email: Email of deleter of the route aggregation resource
        :param pulumi.Input[_builtins.str] deleted_by_full_name: Legal name of deleter of the route aggregation resource
        :param pulumi.Input[_builtins.str] deleted_date_time: Deletion time of the route aggregation resource
        :param pulumi.Input[_builtins.str] updated_by: User name of last updater of the route aggregation resource
        :param pulumi.Input[_builtins.str] updated_by_email: Email of last updater of the route aggregation resource
        :param pulumi.Input[_builtins.str] updated_by_full_name: Legal name of last updater of the route aggregation resource
        :param pulumi.Input[_builtins.str] updated_date_time: Last update time of the route aggregation resource
        """
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if created_by_email is not None:
            pulumi.set(__self__, "created_by_email", created_by_email)
        if created_by_full_name is not None:
            pulumi.set(__self__, "created_by_full_name", created_by_full_name)
        if created_date_time is not None:
            pulumi.set(__self__, "created_date_time", created_date_time)
        if deleted_by is not None:
            pulumi.set(__self__, "deleted_by", deleted_by)
        if deleted_by_email is not None:
            pulumi.set(__self__, "deleted_by_email", deleted_by_email)
        if deleted_by_full_name is not None:
            pulumi.set(__self__, "deleted_by_full_name", deleted_by_full_name)
        if deleted_date_time is not None:
            pulumi.set(__self__, "deleted_date_time", deleted_date_time)
        if updated_by is not None:
            pulumi.set(__self__, "updated_by", updated_by)
        if updated_by_email is not None:
            pulumi.set(__self__, "updated_by_email", updated_by_email)
        if updated_by_full_name is not None:
            pulumi.set(__self__, "updated_by_full_name", updated_by_full_name)
        if updated_date_time is not None:
            pulumi.set(__self__, "updated_date_time", updated_date_time)

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        User name of creator of the route aggregation resource
        """
        return pulumi.get(self, "created_by")

    @created_by.setter
    def created_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_by", value)

    @_builtins.property
    @pulumi.getter(name="createdByEmail")
    def created_by_email(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Email of creator of the route aggregation resource
        """
        return pulumi.get(self, "created_by_email")

    @created_by_email.setter
    def created_by_email(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_by_email", value)

    @_builtins.property
    @pulumi.getter(name="createdByFullName")
    def created_by_full_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Legal name of creator of the route aggregation resource
        """
        return pulumi.get(self, "created_by_full_name")

    @created_by_full_name.setter
    def created_by_full_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_by_full_name", value)

    @_builtins.property
    @pulumi.getter(name="createdDateTime")
    def created_date_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Creation time of the route aggregation resource
        """
        return pulumi.get(self, "created_date_time")

    @created_date_time.setter
    def created_date_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_date_time", value)

    @_builtins.property
    @pulumi.getter(name="deletedBy")
    def deleted_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        User name of deleter of the route aggregation resource
        """
        return pulumi.get(self, "deleted_by")

    @deleted_by.setter
    def deleted_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deleted_by", value)

    @_builtins.property
    @pulumi.getter(name="deletedByEmail")
    def deleted_by_email(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Email of deleter of the route aggregation resource
        """
        return pulumi.get(self, "deleted_by_email")

    @deleted_by_email.setter
    def deleted_by_email(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deleted_by_email", value)

    @_builtins.property
    @pulumi.getter(name="deletedByFullName")
    def deleted_by_full_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Legal name of deleter of the route aggregation resource
        """
        return pulumi.get(self, "deleted_by_full_name")

    @deleted_by_full_name.setter
    def deleted_by_full_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deleted_by_full_name", value)

    @_builtins.property
    @pulumi.getter(name="deletedDateTime")
    def deleted_date_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Deletion time of the route aggregation resource
        """
        return pulumi.get(self, "deleted_date_time")

    @deleted_date_time.setter
    def deleted_date_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deleted_date_time", value)

    @_builtins.property
    @pulumi.getter(name="updatedBy")
    def updated_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        User name of last updater of the route aggregation resource
        """
        return pulumi.get(self, "updated_by")

    @updated_by.setter
    def updated_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_by", value)

    @_builtins.property
    @pulumi.getter(name="updatedByEmail")
    def updated_by_email(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Email of last updater of the route aggregation resource
        """
        return pulumi.get(self, "updated_by_email")

    @updated_by_email.setter
    def updated_by_email(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_by_email", value)

    @_builtins.property
    @pulumi.getter(name="updatedByFullName")
    def updated_by_full_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Legal name of last updater of the route aggregation resource
        """
        return pulumi.get(self, "updated_by_full_name")

    @updated_by_full_name.setter
    def updated_by_full_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_by_full_name", value)

    @_builtins.property
    @pulumi.getter(name="updatedDateTime")
    def updated_date_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Last update time of the route aggregation resource
        """
        return pulumi.get(self, "updated_date_time")

    @updated_date_time.setter
    def updated_date_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_date_time", value)


if not MYPY:
    class PrecisionTimeServiceConnectionArgsDict(TypedDict):
        uuid: pulumi.Input[_builtins.str]
        """
        Equinix Fabric Connection UUID; Precision Time Service will be connected with it
        """
        href: NotRequired[pulumi.Input[_builtins.str]]
        """
        Link to the Equinix Fabric Connection associated with the Precision Time Service
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type of the Equinix Fabric Connection associated with the Precision Time Service
        """
elif False:
    PrecisionTimeServiceConnectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrecisionTimeServiceConnectionArgs:
    def __init__(__self__, *,
                 uuid: pulumi.Input[_builtins.str],
                 href: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] uuid: Equinix Fabric Connection UUID; Precision Time Service will be connected with it
        :param pulumi.Input[_builtins.str] href: Link to the Equinix Fabric Connection associated with the Precision Time Service
        :param pulumi.Input[_builtins.str] type: Type of the Equinix Fabric Connection associated with the Precision Time Service
        """
        pulumi.set(__self__, "uuid", uuid)
        if href is not None:
            pulumi.set(__self__, "href", href)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> pulumi.Input[_builtins.str]:
        """
        Equinix Fabric Connection UUID; Precision Time Service will be connected with it
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "uuid", value)

    @_builtins.property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Link to the Equinix Fabric Connection associated with the Precision Time Service
        """
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "href", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type of the Equinix Fabric Connection associated with the Precision Time Service
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class PrecisionTimeServiceIpv4ArgsDict(TypedDict):
        default_gateway: pulumi.Input[_builtins.str]
        """
        IPv4 address that establishes the Routing Interface where traffic is directed. It serves as the next hop in the Network.
        """
        network_mask: pulumi.Input[_builtins.str]
        """
        IPv4 address that defines the range of consecutive subnets in the network.
        """
        primary: pulumi.Input[_builtins.str]
        """
        IPv4 address for the Primary Timing Master Server.
        """
        secondary: pulumi.Input[_builtins.str]
        """
        IPv4 address for the Secondary Timing Master Server.
        """
elif False:
    PrecisionTimeServiceIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrecisionTimeServiceIpv4Args:
    def __init__(__self__, *,
                 default_gateway: pulumi.Input[_builtins.str],
                 network_mask: pulumi.Input[_builtins.str],
                 primary: pulumi.Input[_builtins.str],
                 secondary: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] default_gateway: IPv4 address that establishes the Routing Interface where traffic is directed. It serves as the next hop in the Network.
        :param pulumi.Input[_builtins.str] network_mask: IPv4 address that defines the range of consecutive subnets in the network.
        :param pulumi.Input[_builtins.str] primary: IPv4 address for the Primary Timing Master Server.
        :param pulumi.Input[_builtins.str] secondary: IPv4 address for the Secondary Timing Master Server.
        """
        pulumi.set(__self__, "default_gateway", default_gateway)
        pulumi.set(__self__, "network_mask", network_mask)
        pulumi.set(__self__, "primary", primary)
        pulumi.set(__self__, "secondary", secondary)

    @_builtins.property
    @pulumi.getter(name="defaultGateway")
    def default_gateway(self) -> pulumi.Input[_builtins.str]:
        """
        IPv4 address that establishes the Routing Interface where traffic is directed. It serves as the next hop in the Network.
        """
        return pulumi.get(self, "default_gateway")

    @default_gateway.setter
    def default_gateway(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "default_gateway", value)

    @_builtins.property
    @pulumi.getter(name="networkMask")
    def network_mask(self) -> pulumi.Input[_builtins.str]:
        """
        IPv4 address that defines the range of consecutive subnets in the network.
        """
        return pulumi.get(self, "network_mask")

    @network_mask.setter
    def network_mask(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "network_mask", value)

    @_builtins.property
    @pulumi.getter
    def primary(self) -> pulumi.Input[_builtins.str]:
        """
        IPv4 address for the Primary Timing Master Server.
        """
        return pulumi.get(self, "primary")

    @primary.setter
    def primary(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "primary", value)

    @_builtins.property
    @pulumi.getter
    def secondary(self) -> pulumi.Input[_builtins.str]:
        """
        IPv4 address for the Secondary Timing Master Server.
        """
        return pulumi.get(self, "secondary")

    @secondary.setter
    def secondary(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secondary", value)


if not MYPY:
    class PrecisionTimeServiceNtpAdvancedConfigurationArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The plaintext authentication key. For ASCII type, the key\\
        \\ must contain printable ASCII characters, range 10-20 characters. For\\
        \\ HEX type, range should be 10-40 characters
        """
        key_number: NotRequired[pulumi.Input[_builtins.int]]
        """
        The authentication Key ID
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        md5 Authentication type
        """
elif False:
    PrecisionTimeServiceNtpAdvancedConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrecisionTimeServiceNtpAdvancedConfigurationArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 key_number: Optional[pulumi.Input[_builtins.int]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: The plaintext authentication key. For ASCII type, the key\\
               \\ must contain printable ASCII characters, range 10-20 characters. For\\
               \\ HEX type, range should be 10-40 characters
        :param pulumi.Input[_builtins.int] key_number: The authentication Key ID
        :param pulumi.Input[_builtins.str] type: md5 Authentication type
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if key_number is not None:
            pulumi.set(__self__, "key_number", key_number)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The plaintext authentication key. For ASCII type, the key\\
        \\ must contain printable ASCII characters, range 10-20 characters. For\\
        \\ HEX type, range should be 10-40 characters
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="keyNumber")
    def key_number(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The authentication Key ID
        """
        return pulumi.get(self, "key_number")

    @key_number.setter
    def key_number(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "key_number", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        md5 Authentication type
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class PrecisionTimeServiceOrderArgsDict(TypedDict):
        customer_reference_number: NotRequired[pulumi.Input[_builtins.str]]
        """
        Customer reference number
        """
        order_number: NotRequired[pulumi.Input[_builtins.str]]
        """
        Order reference number
        """
        purchase_order_number: NotRequired[pulumi.Input[_builtins.str]]
        """
        Purchase order number
        """
elif False:
    PrecisionTimeServiceOrderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrecisionTimeServiceOrderArgs:
    def __init__(__self__, *,
                 customer_reference_number: Optional[pulumi.Input[_builtins.str]] = None,
                 order_number: Optional[pulumi.Input[_builtins.str]] = None,
                 purchase_order_number: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] customer_reference_number: Customer reference number
        :param pulumi.Input[_builtins.str] order_number: Order reference number
        :param pulumi.Input[_builtins.str] purchase_order_number: Purchase order number
        """
        if customer_reference_number is not None:
            pulumi.set(__self__, "customer_reference_number", customer_reference_number)
        if order_number is not None:
            pulumi.set(__self__, "order_number", order_number)
        if purchase_order_number is not None:
            pulumi.set(__self__, "purchase_order_number", purchase_order_number)

    @_builtins.property
    @pulumi.getter(name="customerReferenceNumber")
    def customer_reference_number(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Customer reference number
        """
        return pulumi.get(self, "customer_reference_number")

    @customer_reference_number.setter
    def customer_reference_number(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "customer_reference_number", value)

    @_builtins.property
    @pulumi.getter(name="orderNumber")
    def order_number(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Order reference number
        """
        return pulumi.get(self, "order_number")

    @order_number.setter
    def order_number(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "order_number", value)

    @_builtins.property
    @pulumi.getter(name="purchaseOrderNumber")
    def purchase_order_number(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Purchase order number
        """
        return pulumi.get(self, "purchase_order_number")

    @purchase_order_number.setter
    def purchase_order_number(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "purchase_order_number", value)


if not MYPY:
    class PrecisionTimeServicePackageArgsDict(TypedDict):
        code: pulumi.Input[_builtins.str]
        """
        Time Precision Package Code for the desired billing package
        """
        href: NotRequired[pulumi.Input[_builtins.str]]
        """
        Time Precision Package HREF link to corresponding resource in Equinix Portal
        """
elif False:
    PrecisionTimeServicePackageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrecisionTimeServicePackageArgs:
    def __init__(__self__, *,
                 code: pulumi.Input[_builtins.str],
                 href: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] code: Time Precision Package Code for the desired billing package
        :param pulumi.Input[_builtins.str] href: Time Precision Package HREF link to corresponding resource in Equinix Portal
        """
        pulumi.set(__self__, "code", code)
        if href is not None:
            pulumi.set(__self__, "href", href)

    @_builtins.property
    @pulumi.getter
    def code(self) -> pulumi.Input[_builtins.str]:
        """
        Time Precision Package Code for the desired billing package
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "code", value)

    @_builtins.property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Time Precision Package HREF link to corresponding resource in Equinix Portal
        """
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "href", value)


if not MYPY:
    class PrecisionTimeServicePrecisionTimePriceArgsDict(TypedDict):
        charges: NotRequired[pulumi.Input[Sequence[pulumi.Input['PrecisionTimeServicePrecisionTimePriceChargeArgsDict']]]]
        """
        offering price charge
        """
        currency: NotRequired[pulumi.Input[_builtins.str]]
        """
        Offering price currency
        """
elif False:
    PrecisionTimeServicePrecisionTimePriceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrecisionTimeServicePrecisionTimePriceArgs:
    def __init__(__self__, *,
                 charges: Optional[pulumi.Input[Sequence[pulumi.Input['PrecisionTimeServicePrecisionTimePriceChargeArgs']]]] = None,
                 currency: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PrecisionTimeServicePrecisionTimePriceChargeArgs']]] charges: offering price charge
        :param pulumi.Input[_builtins.str] currency: Offering price currency
        """
        if charges is not None:
            pulumi.set(__self__, "charges", charges)
        if currency is not None:
            pulumi.set(__self__, "currency", currency)

    @_builtins.property
    @pulumi.getter
    def charges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PrecisionTimeServicePrecisionTimePriceChargeArgs']]]]:
        """
        offering price charge
        """
        return pulumi.get(self, "charges")

    @charges.setter
    def charges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PrecisionTimeServicePrecisionTimePriceChargeArgs']]]]):
        pulumi.set(self, "charges", value)

    @_builtins.property
    @pulumi.getter
    def currency(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Offering price currency
        """
        return pulumi.get(self, "currency")

    @currency.setter
    def currency(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "currency", value)


if not MYPY:
    class PrecisionTimeServicePrecisionTimePriceChargeArgsDict(TypedDict):
        price: NotRequired[pulumi.Input[_builtins.float]]
        """
        Offering price
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Price charge type; MONTHLY*RECURRING, NON*RECURRING
        """
elif False:
    PrecisionTimeServicePrecisionTimePriceChargeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrecisionTimeServicePrecisionTimePriceChargeArgs:
    def __init__(__self__, *,
                 price: Optional[pulumi.Input[_builtins.float]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.float] price: Offering price
        :param pulumi.Input[_builtins.str] type: Price charge type; MONTHLY*RECURRING, NON*RECURRING
        """
        if price is not None:
            pulumi.set(__self__, "price", price)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def price(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Offering price
        """
        return pulumi.get(self, "price")

    @price.setter
    def price(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "price", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Price charge type; MONTHLY*RECURRING, NON*RECURRING
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class PrecisionTimeServiceProjectArgsDict(TypedDict):
        project_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Equinix Subscriber-assigned project ID
        """
elif False:
    PrecisionTimeServiceProjectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrecisionTimeServiceProjectArgs:
    def __init__(__self__, *,
                 project_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] project_id: Equinix Subscriber-assigned project ID
        """
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Equinix Subscriber-assigned project ID
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "project_id", value)


if not MYPY:
    class PrecisionTimeServicePtpAdvancedConfigurationArgsDict(TypedDict):
        domain: NotRequired[pulumi.Input[_builtins.int]]
        """
        The PTP domain value
        """
        grant_time: NotRequired[pulumi.Input[_builtins.int]]
        """
        Unicast Grant Time in seconds. For Multicast and Hybrid transport modes, grant time defaults to 300 seconds. For Unicast mode, grant time can be between 30 to 7200
        """
        log_announce_interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        Logarithmic value that controls the rate of PTP Announce packets from the PTP time server. Default is 1 (1 packet every 2 seconds), Unit packets/second
        """
        log_delay_req_interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        Logarithmic value that controls the rate of PTP DelayReq packets. Default is -4 (16 packets per second), Unit packets/second..
        """
        log_sync_interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        Logarithmic value that controls the rate of PTP Sync packets. Default is -4 (16 packets per second), Unit packets/second..
        """
        priority1: NotRequired[pulumi.Input[_builtins.int]]
        """
        The priority1 value determines the best primary clock, Lower value indicates higher priority
        """
        priority2: NotRequired[pulumi.Input[_builtins.int]]
        """
        The priority2 value differentiates and prioritizes the primary clock to avoid confusion when priority1-value is the same for different primary clocks in a network
        """
        time_scale: NotRequired[pulumi.Input[_builtins.str]]
        """
        Time Scale value, ARB denotes Arbitrary and PTP denotes Precision Time Protocol
        """
        transport_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        ptp transport mode
        """
elif False:
    PrecisionTimeServicePtpAdvancedConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrecisionTimeServicePtpAdvancedConfigurationArgs:
    def __init__(__self__, *,
                 domain: Optional[pulumi.Input[_builtins.int]] = None,
                 grant_time: Optional[pulumi.Input[_builtins.int]] = None,
                 log_announce_interval: Optional[pulumi.Input[_builtins.int]] = None,
                 log_delay_req_interval: Optional[pulumi.Input[_builtins.int]] = None,
                 log_sync_interval: Optional[pulumi.Input[_builtins.int]] = None,
                 priority1: Optional[pulumi.Input[_builtins.int]] = None,
                 priority2: Optional[pulumi.Input[_builtins.int]] = None,
                 time_scale: Optional[pulumi.Input[_builtins.str]] = None,
                 transport_mode: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] domain: The PTP domain value
        :param pulumi.Input[_builtins.int] grant_time: Unicast Grant Time in seconds. For Multicast and Hybrid transport modes, grant time defaults to 300 seconds. For Unicast mode, grant time can be between 30 to 7200
        :param pulumi.Input[_builtins.int] log_announce_interval: Logarithmic value that controls the rate of PTP Announce packets from the PTP time server. Default is 1 (1 packet every 2 seconds), Unit packets/second
        :param pulumi.Input[_builtins.int] log_delay_req_interval: Logarithmic value that controls the rate of PTP DelayReq packets. Default is -4 (16 packets per second), Unit packets/second..
        :param pulumi.Input[_builtins.int] log_sync_interval: Logarithmic value that controls the rate of PTP Sync packets. Default is -4 (16 packets per second), Unit packets/second..
        :param pulumi.Input[_builtins.int] priority1: The priority1 value determines the best primary clock, Lower value indicates higher priority
        :param pulumi.Input[_builtins.int] priority2: The priority2 value differentiates and prioritizes the primary clock to avoid confusion when priority1-value is the same for different primary clocks in a network
        :param pulumi.Input[_builtins.str] time_scale: Time Scale value, ARB denotes Arbitrary and PTP denotes Precision Time Protocol
        :param pulumi.Input[_builtins.str] transport_mode: ptp transport mode
        """
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if grant_time is not None:
            pulumi.set(__self__, "grant_time", grant_time)
        if log_announce_interval is not None:
            pulumi.set(__self__, "log_announce_interval", log_announce_interval)
        if log_delay_req_interval is not None:
            pulumi.set(__self__, "log_delay_req_interval", log_delay_req_interval)
        if log_sync_interval is not None:
            pulumi.set(__self__, "log_sync_interval", log_sync_interval)
        if priority1 is not None:
            pulumi.set(__self__, "priority1", priority1)
        if priority2 is not None:
            pulumi.set(__self__, "priority2", priority2)
        if time_scale is not None:
            pulumi.set(__self__, "time_scale", time_scale)
        if transport_mode is not None:
            pulumi.set(__self__, "transport_mode", transport_mode)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The PTP domain value
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "domain", value)

    @_builtins.property
    @pulumi.getter(name="grantTime")
    def grant_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Unicast Grant Time in seconds. For Multicast and Hybrid transport modes, grant time defaults to 300 seconds. For Unicast mode, grant time can be between 30 to 7200
        """
        return pulumi.get(self, "grant_time")

    @grant_time.setter
    def grant_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "grant_time", value)

    @_builtins.property
    @pulumi.getter(name="logAnnounceInterval")
    def log_announce_interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Logarithmic value that controls the rate of PTP Announce packets from the PTP time server. Default is 1 (1 packet every 2 seconds), Unit packets/second
        """
        return pulumi.get(self, "log_announce_interval")

    @log_announce_interval.setter
    def log_announce_interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "log_announce_interval", value)

    @_builtins.property
    @pulumi.getter(name="logDelayReqInterval")
    def log_delay_req_interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Logarithmic value that controls the rate of PTP DelayReq packets. Default is -4 (16 packets per second), Unit packets/second..
        """
        return pulumi.get(self, "log_delay_req_interval")

    @log_delay_req_interval.setter
    def log_delay_req_interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "log_delay_req_interval", value)

    @_builtins.property
    @pulumi.getter(name="logSyncInterval")
    def log_sync_interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Logarithmic value that controls the rate of PTP Sync packets. Default is -4 (16 packets per second), Unit packets/second..
        """
        return pulumi.get(self, "log_sync_interval")

    @log_sync_interval.setter
    def log_sync_interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "log_sync_interval", value)

    @_builtins.property
    @pulumi.getter
    def priority1(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The priority1 value determines the best primary clock, Lower value indicates higher priority
        """
        return pulumi.get(self, "priority1")

    @priority1.setter
    def priority1(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "priority1", value)

    @_builtins.property
    @pulumi.getter
    def priority2(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The priority2 value differentiates and prioritizes the primary clock to avoid confusion when priority1-value is the same for different primary clocks in a network
        """
        return pulumi.get(self, "priority2")

    @priority2.setter
    def priority2(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "priority2", value)

    @_builtins.property
    @pulumi.getter(name="timeScale")
    def time_scale(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Time Scale value, ARB denotes Arbitrary and PTP denotes Precision Time Protocol
        """
        return pulumi.get(self, "time_scale")

    @time_scale.setter
    def time_scale(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_scale", value)

    @_builtins.property
    @pulumi.getter(name="transportMode")
    def transport_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ptp transport mode
        """
        return pulumi.get(self, "transport_mode")

    @transport_mode.setter
    def transport_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "transport_mode", value)


if not MYPY:
    class PrecisionTimeServiceTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        read: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    PrecisionTimeServiceTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrecisionTimeServiceTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 read: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if read is not None:
            pulumi.set(__self__, "read", read)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def read(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @read.setter
    def read(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "read", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class RouteAggregationChangeArgsDict(TypedDict):
        href: pulumi.Input[_builtins.str]
        """
        Equinix auto generated URI to the route aggregation change
        """
        type: pulumi.Input[_builtins.str]
        """
        Equinix defined Route Aggregation Change Type
        """
        uuid: pulumi.Input[_builtins.str]
        """
        Equinix-assigned unique id for a change
        """
elif False:
    RouteAggregationChangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteAggregationChangeArgs:
    def __init__(__self__, *,
                 href: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 uuid: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] href: Equinix auto generated URI to the route aggregation change
        :param pulumi.Input[_builtins.str] type: Equinix defined Route Aggregation Change Type
        :param pulumi.Input[_builtins.str] uuid: Equinix-assigned unique id for a change
        """
        pulumi.set(__self__, "href", href)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter
    def href(self) -> pulumi.Input[_builtins.str]:
        """
        Equinix auto generated URI to the route aggregation change
        """
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "href", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Equinix defined Route Aggregation Change Type
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> pulumi.Input[_builtins.str]:
        """
        Equinix-assigned unique id for a change
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class RouteAggregationChangeLogArgsDict(TypedDict):
        created_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        User name of creator of the route aggregation resource
        """
        created_by_email: NotRequired[pulumi.Input[_builtins.str]]
        """
        Email of creator of the route aggregation resource
        """
        created_by_full_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Legal name of creator of the route aggregation resource
        """
        created_date_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Creation time of the route aggregation resource
        """
        deleted_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        User name of deleter of the route aggregation resource
        """
        deleted_by_email: NotRequired[pulumi.Input[_builtins.str]]
        """
        Email of deleter of the route aggregation resource
        """
        deleted_by_full_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Legal name of deleter of the route aggregation resource
        """
        deleted_date_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Deletion time of the route aggregation resource
        """
        updated_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        User name of last updater of the route aggregation resource
        """
        updated_by_email: NotRequired[pulumi.Input[_builtins.str]]
        """
        Email of last updater of the route aggregation resource
        """
        updated_by_full_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Legal name of last updater of the route aggregation resource
        """
        updated_date_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Last update time of the route aggregation resource
        """
elif False:
    RouteAggregationChangeLogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteAggregationChangeLogArgs:
    def __init__(__self__, *,
                 created_by: Optional[pulumi.Input[_builtins.str]] = None,
                 created_by_email: Optional[pulumi.Input[_builtins.str]] = None,
                 created_by_full_name: Optional[pulumi.Input[_builtins.str]] = None,
                 created_date_time: Optional[pulumi.Input[_builtins.str]] = None,
                 deleted_by: Optional[pulumi.Input[_builtins.str]] = None,
                 deleted_by_email: Optional[pulumi.Input[_builtins.str]] = None,
                 deleted_by_full_name: Optional[pulumi.Input[_builtins.str]] = None,
                 deleted_date_time: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_by: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_by_email: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_by_full_name: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_date_time: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] created_by: User name of creator of the route aggregation resource
        :param pulumi.Input[_builtins.str] created_by_email: Email of creator of the route aggregation resource
        :param pulumi.Input[_builtins.str] created_by_full_name: Legal name of creator of the route aggregation resource
        :param pulumi.Input[_builtins.str] created_date_time: Creation time of the route aggregation resource
        :param pulumi.Input[_builtins.str] deleted_by: User name of deleter of the route aggregation resource
        :param pulumi.Input[_builtins.str] deleted_by_email: Email of deleter of the route aggregation resource
        :param pulumi.Input[_builtins.str] deleted_by_full_name: Legal name of deleter of the route aggregation resource
        :param pulumi.Input[_builtins.str] deleted_date_time: Deletion time of the route aggregation resource
        :param pulumi.Input[_builtins.str] updated_by: User name of last updater of the route aggregation resource
        :param pulumi.Input[_builtins.str] updated_by_email: Email of last updater of the route aggregation resource
        :param pulumi.Input[_builtins.str] updated_by_full_name: Legal name of last updater of the route aggregation resource
        :param pulumi.Input[_builtins.str] updated_date_time: Last update time of the route aggregation resource
        """
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if created_by_email is not None:
            pulumi.set(__self__, "created_by_email", created_by_email)
        if created_by_full_name is not None:
            pulumi.set(__self__, "created_by_full_name", created_by_full_name)
        if created_date_time is not None:
            pulumi.set(__self__, "created_date_time", created_date_time)
        if deleted_by is not None:
            pulumi.set(__self__, "deleted_by", deleted_by)
        if deleted_by_email is not None:
            pulumi.set(__self__, "deleted_by_email", deleted_by_email)
        if deleted_by_full_name is not None:
            pulumi.set(__self__, "deleted_by_full_name", deleted_by_full_name)
        if deleted_date_time is not None:
            pulumi.set(__self__, "deleted_date_time", deleted_date_time)
        if updated_by is not None:
            pulumi.set(__self__, "updated_by", updated_by)
        if updated_by_email is not None:
            pulumi.set(__self__, "updated_by_email", updated_by_email)
        if updated_by_full_name is not None:
            pulumi.set(__self__, "updated_by_full_name", updated_by_full_name)
        if updated_date_time is not None:
            pulumi.set(__self__, "updated_date_time", updated_date_time)

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        User name of creator of the route aggregation resource
        """
        return pulumi.get(self, "created_by")

    @created_by.setter
    def created_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_by", value)

    @_builtins.property
    @pulumi.getter(name="createdByEmail")
    def created_by_email(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Email of creator of the route aggregation resource
        """
        return pulumi.get(self, "created_by_email")

    @created_by_email.setter
    def created_by_email(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_by_email", value)

    @_builtins.property
    @pulumi.getter(name="createdByFullName")
    def created_by_full_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Legal name of creator of the route aggregation resource
        """
        return pulumi.get(self, "created_by_full_name")

    @created_by_full_name.setter
    def created_by_full_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_by_full_name", value)

    @_builtins.property
    @pulumi.getter(name="createdDateTime")
    def created_date_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Creation time of the route aggregation resource
        """
        return pulumi.get(self, "created_date_time")

    @created_date_time.setter
    def created_date_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_date_time", value)

    @_builtins.property
    @pulumi.getter(name="deletedBy")
    def deleted_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        User name of deleter of the route aggregation resource
        """
        return pulumi.get(self, "deleted_by")

    @deleted_by.setter
    def deleted_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deleted_by", value)

    @_builtins.property
    @pulumi.getter(name="deletedByEmail")
    def deleted_by_email(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Email of deleter of the route aggregation resource
        """
        return pulumi.get(self, "deleted_by_email")

    @deleted_by_email.setter
    def deleted_by_email(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deleted_by_email", value)

    @_builtins.property
    @pulumi.getter(name="deletedByFullName")
    def deleted_by_full_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Legal name of deleter of the route aggregation resource
        """
        return pulumi.get(self, "deleted_by_full_name")

    @deleted_by_full_name.setter
    def deleted_by_full_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deleted_by_full_name", value)

    @_builtins.property
    @pulumi.getter(name="deletedDateTime")
    def deleted_date_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Deletion time of the route aggregation resource
        """
        return pulumi.get(self, "deleted_date_time")

    @deleted_date_time.setter
    def deleted_date_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deleted_date_time", value)

    @_builtins.property
    @pulumi.getter(name="updatedBy")
    def updated_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        User name of last updater of the route aggregation resource
        """
        return pulumi.get(self, "updated_by")

    @updated_by.setter
    def updated_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_by", value)

    @_builtins.property
    @pulumi.getter(name="updatedByEmail")
    def updated_by_email(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Email of last updater of the route aggregation resource
        """
        return pulumi.get(self, "updated_by_email")

    @updated_by_email.setter
    def updated_by_email(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_by_email", value)

    @_builtins.property
    @pulumi.getter(name="updatedByFullName")
    def updated_by_full_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Legal name of last updater of the route aggregation resource
        """
        return pulumi.get(self, "updated_by_full_name")

    @updated_by_full_name.setter
    def updated_by_full_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_by_full_name", value)

    @_builtins.property
    @pulumi.getter(name="updatedDateTime")
    def updated_date_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Last update time of the route aggregation resource
        """
        return pulumi.get(self, "updated_date_time")

    @updated_date_time.setter
    def updated_date_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_date_time", value)


if not MYPY:
    class RouteAggregationProjectArgsDict(TypedDict):
        project_id: pulumi.Input[_builtins.str]
        """
        Equinix Subscriber-assigned project ID
        """
elif False:
    RouteAggregationProjectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteAggregationProjectArgs:
    def __init__(__self__, *,
                 project_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] project_id: Equinix Subscriber-assigned project ID
        """
        pulumi.set(__self__, "project_id", project_id)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> pulumi.Input[_builtins.str]:
        """
        Equinix Subscriber-assigned project ID
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "project_id", value)


if not MYPY:
    class RouteAggregationRuleChangeArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Equinix defined Route Aggregation Change Type
        """
        uuid: pulumi.Input[_builtins.str]
        """
        Equinix-assigned unique id for a change
        """
        href: NotRequired[pulumi.Input[_builtins.str]]
        """
        Equinix auto generated URI to the route aggregation change
        """
elif False:
    RouteAggregationRuleChangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteAggregationRuleChangeArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 uuid: pulumi.Input[_builtins.str],
                 href: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Equinix defined Route Aggregation Change Type
        :param pulumi.Input[_builtins.str] uuid: Equinix-assigned unique id for a change
        :param pulumi.Input[_builtins.str] href: Equinix auto generated URI to the route aggregation change
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "uuid", uuid)
        if href is not None:
            pulumi.set(__self__, "href", href)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Equinix defined Route Aggregation Change Type
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> pulumi.Input[_builtins.str]:
        """
        Equinix-assigned unique id for a change
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "uuid", value)

    @_builtins.property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Equinix auto generated URI to the route aggregation change
        """
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "href", value)


if not MYPY:
    class RouteAggregationRuleChangeLogArgsDict(TypedDict):
        created_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        User name of creator of the stream resource
        """
        created_by_email: NotRequired[pulumi.Input[_builtins.str]]
        """
        Email of creator of the stream resource
        """
        created_by_full_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Legal name of creator of the stream resource
        """
        created_date_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Creation time of the stream resource
        """
        deleted_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        User name of deleter of the stream resource
        """
        deleted_by_email: NotRequired[pulumi.Input[_builtins.str]]
        """
        Email of deleter of the stream resource
        """
        deleted_by_full_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Legal name of deleter of the stream resource
        """
        deleted_date_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Deletion time of the stream resource
        """
        updated_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        User name of last updater of the stream resource
        """
        updated_by_email: NotRequired[pulumi.Input[_builtins.str]]
        """
        Email of last updater of the stream resource
        """
        updated_by_full_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Legal name of last updater of the stream resource
        """
        updated_date_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Last update time of the stream resource
        """
elif False:
    RouteAggregationRuleChangeLogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteAggregationRuleChangeLogArgs:
    def __init__(__self__, *,
                 created_by: Optional[pulumi.Input[_builtins.str]] = None,
                 created_by_email: Optional[pulumi.Input[_builtins.str]] = None,
                 created_by_full_name: Optional[pulumi.Input[_builtins.str]] = None,
                 created_date_time: Optional[pulumi.Input[_builtins.str]] = None,
                 deleted_by: Optional[pulumi.Input[_builtins.str]] = None,
                 deleted_by_email: Optional[pulumi.Input[_builtins.str]] = None,
                 deleted_by_full_name: Optional[pulumi.Input[_builtins.str]] = None,
                 deleted_date_time: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_by: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_by_email: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_by_full_name: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_date_time: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] created_by: User name of creator of the stream resource
        :param pulumi.Input[_builtins.str] created_by_email: Email of creator of the stream resource
        :param pulumi.Input[_builtins.str] created_by_full_name: Legal name of creator of the stream resource
        :param pulumi.Input[_builtins.str] created_date_time: Creation time of the stream resource
        :param pulumi.Input[_builtins.str] deleted_by: User name of deleter of the stream resource
        :param pulumi.Input[_builtins.str] deleted_by_email: Email of deleter of the stream resource
        :param pulumi.Input[_builtins.str] deleted_by_full_name: Legal name of deleter of the stream resource
        :param pulumi.Input[_builtins.str] deleted_date_time: Deletion time of the stream resource
        :param pulumi.Input[_builtins.str] updated_by: User name of last updater of the stream resource
        :param pulumi.Input[_builtins.str] updated_by_email: Email of last updater of the stream resource
        :param pulumi.Input[_builtins.str] updated_by_full_name: Legal name of last updater of the stream resource
        :param pulumi.Input[_builtins.str] updated_date_time: Last update time of the stream resource
        """
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if created_by_email is not None:
            pulumi.set(__self__, "created_by_email", created_by_email)
        if created_by_full_name is not None:
            pulumi.set(__self__, "created_by_full_name", created_by_full_name)
        if created_date_time is not None:
            pulumi.set(__self__, "created_date_time", created_date_time)
        if deleted_by is not None:
            pulumi.set(__self__, "deleted_by", deleted_by)
        if deleted_by_email is not None:
            pulumi.set(__self__, "deleted_by_email", deleted_by_email)
        if deleted_by_full_name is not None:
            pulumi.set(__self__, "deleted_by_full_name", deleted_by_full_name)
        if deleted_date_time is not None:
            pulumi.set(__self__, "deleted_date_time", deleted_date_time)
        if updated_by is not None:
            pulumi.set(__self__, "updated_by", updated_by)
        if updated_by_email is not None:
            pulumi.set(__self__, "updated_by_email", updated_by_email)
        if updated_by_full_name is not None:
            pulumi.set(__self__, "updated_by_full_name", updated_by_full_name)
        if updated_date_time is not None:
            pulumi.set(__self__, "updated_date_time", updated_date_time)

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        User name of creator of the stream resource
        """
        return pulumi.get(self, "created_by")

    @created_by.setter
    def created_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_by", value)

    @_builtins.property
    @pulumi.getter(name="createdByEmail")
    def created_by_email(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Email of creator of the stream resource
        """
        return pulumi.get(self, "created_by_email")

    @created_by_email.setter
    def created_by_email(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_by_email", value)

    @_builtins.property
    @pulumi.getter(name="createdByFullName")
    def created_by_full_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Legal name of creator of the stream resource
        """
        return pulumi.get(self, "created_by_full_name")

    @created_by_full_name.setter
    def created_by_full_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_by_full_name", value)

    @_builtins.property
    @pulumi.getter(name="createdDateTime")
    def created_date_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Creation time of the stream resource
        """
        return pulumi.get(self, "created_date_time")

    @created_date_time.setter
    def created_date_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_date_time", value)

    @_builtins.property
    @pulumi.getter(name="deletedBy")
    def deleted_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        User name of deleter of the stream resource
        """
        return pulumi.get(self, "deleted_by")

    @deleted_by.setter
    def deleted_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deleted_by", value)

    @_builtins.property
    @pulumi.getter(name="deletedByEmail")
    def deleted_by_email(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Email of deleter of the stream resource
        """
        return pulumi.get(self, "deleted_by_email")

    @deleted_by_email.setter
    def deleted_by_email(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deleted_by_email", value)

    @_builtins.property
    @pulumi.getter(name="deletedByFullName")
    def deleted_by_full_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Legal name of deleter of the stream resource
        """
        return pulumi.get(self, "deleted_by_full_name")

    @deleted_by_full_name.setter
    def deleted_by_full_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deleted_by_full_name", value)

    @_builtins.property
    @pulumi.getter(name="deletedDateTime")
    def deleted_date_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Deletion time of the stream resource
        """
        return pulumi.get(self, "deleted_date_time")

    @deleted_date_time.setter
    def deleted_date_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deleted_date_time", value)

    @_builtins.property
    @pulumi.getter(name="updatedBy")
    def updated_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        User name of last updater of the stream resource
        """
        return pulumi.get(self, "updated_by")

    @updated_by.setter
    def updated_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_by", value)

    @_builtins.property
    @pulumi.getter(name="updatedByEmail")
    def updated_by_email(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Email of last updater of the stream resource
        """
        return pulumi.get(self, "updated_by_email")

    @updated_by_email.setter
    def updated_by_email(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_by_email", value)

    @_builtins.property
    @pulumi.getter(name="updatedByFullName")
    def updated_by_full_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Legal name of last updater of the stream resource
        """
        return pulumi.get(self, "updated_by_full_name")

    @updated_by_full_name.setter
    def updated_by_full_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_by_full_name", value)

    @_builtins.property
    @pulumi.getter(name="updatedDateTime")
    def updated_date_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Last update time of the stream resource
        """
        return pulumi.get(self, "updated_date_time")

    @updated_date_time.setter
    def updated_date_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_date_time", value)


if not MYPY:
    class RouteAggregationRuleTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        read: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    RouteAggregationRuleTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteAggregationRuleTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 read: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if read is not None:
            pulumi.set(__self__, "read", read)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def read(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @read.setter
    def read(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "read", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class RouteAggregationTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        read: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    RouteAggregationTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteAggregationTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 read: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if read is not None:
            pulumi.set(__self__, "read", read)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def read(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @read.setter
    def read(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "read", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class RouteFilterChangeArgsDict(TypedDict):
        href: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URI of the previous Route Filter Change
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type of change. One of [ "BGP_IPv4_PREFIX_FILTER_UPDATE","BGP_IPv4_PREFIX_FILTER_CREATION","BGP_IPv4_PREFIX_FILTER_DELETION","BGP_IPv6_PREFIX_FILTER_UPDATE","BGP_IPv6_PREFIX_FILTER_CREATION","BGP_IPv6_PREFIX_FILTER_DELETION" ]
        """
        uuid: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unique identifier for the previous change
        """
elif False:
    RouteFilterChangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteFilterChangeArgs:
    def __init__(__self__, *,
                 href: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 uuid: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] href: The URI of the previous Route Filter Change
        :param pulumi.Input[_builtins.str] type: Type of change. One of [ "BGP_IPv4_PREFIX_FILTER_UPDATE","BGP_IPv4_PREFIX_FILTER_CREATION","BGP_IPv4_PREFIX_FILTER_DELETION","BGP_IPv6_PREFIX_FILTER_UPDATE","BGP_IPv6_PREFIX_FILTER_CREATION","BGP_IPv6_PREFIX_FILTER_DELETION" ]
        :param pulumi.Input[_builtins.str] uuid: Unique identifier for the previous change
        """
        if href is not None:
            pulumi.set(__self__, "href", href)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URI of the previous Route Filter Change
        """
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "href", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type of change. One of [ "BGP_IPv4_PREFIX_FILTER_UPDATE","BGP_IPv4_PREFIX_FILTER_CREATION","BGP_IPv4_PREFIX_FILTER_DELETION","BGP_IPv6_PREFIX_FILTER_UPDATE","BGP_IPv6_PREFIX_FILTER_CREATION","BGP_IPv6_PREFIX_FILTER_DELETION" ]
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unique identifier for the previous change
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class RouteFilterChangeLogArgsDict(TypedDict):
        created_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        Created by User Key
        """
        created_by_email: NotRequired[pulumi.Input[_builtins.str]]
        """
        Created by User Email Address
        """
        created_by_full_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Created by User Full Name
        """
        created_date_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Created by Date and Time
        """
        deleted_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        Deleted by User Key
        """
        deleted_by_email: NotRequired[pulumi.Input[_builtins.str]]
        """
        Deleted by User Email Address
        """
        deleted_by_full_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Deleted by User Full Name
        """
        deleted_date_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Deleted by Date and Time
        """
        updated_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        Updated by User Key
        """
        updated_by_email: NotRequired[pulumi.Input[_builtins.str]]
        """
        Updated by User Email Address
        """
        updated_by_full_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Updated by User Full Name
        """
        updated_date_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Updated by Date and Time
        """
elif False:
    RouteFilterChangeLogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteFilterChangeLogArgs:
    def __init__(__self__, *,
                 created_by: Optional[pulumi.Input[_builtins.str]] = None,
                 created_by_email: Optional[pulumi.Input[_builtins.str]] = None,
                 created_by_full_name: Optional[pulumi.Input[_builtins.str]] = None,
                 created_date_time: Optional[pulumi.Input[_builtins.str]] = None,
                 deleted_by: Optional[pulumi.Input[_builtins.str]] = None,
                 deleted_by_email: Optional[pulumi.Input[_builtins.str]] = None,
                 deleted_by_full_name: Optional[pulumi.Input[_builtins.str]] = None,
                 deleted_date_time: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_by: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_by_email: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_by_full_name: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_date_time: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] created_by: Created by User Key
        :param pulumi.Input[_builtins.str] created_by_email: Created by User Email Address
        :param pulumi.Input[_builtins.str] created_by_full_name: Created by User Full Name
        :param pulumi.Input[_builtins.str] created_date_time: Created by Date and Time
        :param pulumi.Input[_builtins.str] deleted_by: Deleted by User Key
        :param pulumi.Input[_builtins.str] deleted_by_email: Deleted by User Email Address
        :param pulumi.Input[_builtins.str] deleted_by_full_name: Deleted by User Full Name
        :param pulumi.Input[_builtins.str] deleted_date_time: Deleted by Date and Time
        :param pulumi.Input[_builtins.str] updated_by: Updated by User Key
        :param pulumi.Input[_builtins.str] updated_by_email: Updated by User Email Address
        :param pulumi.Input[_builtins.str] updated_by_full_name: Updated by User Full Name
        :param pulumi.Input[_builtins.str] updated_date_time: Updated by Date and Time
        """
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if created_by_email is not None:
            pulumi.set(__self__, "created_by_email", created_by_email)
        if created_by_full_name is not None:
            pulumi.set(__self__, "created_by_full_name", created_by_full_name)
        if created_date_time is not None:
            pulumi.set(__self__, "created_date_time", created_date_time)
        if deleted_by is not None:
            pulumi.set(__self__, "deleted_by", deleted_by)
        if deleted_by_email is not None:
            pulumi.set(__self__, "deleted_by_email", deleted_by_email)
        if deleted_by_full_name is not None:
            pulumi.set(__self__, "deleted_by_full_name", deleted_by_full_name)
        if deleted_date_time is not None:
            pulumi.set(__self__, "deleted_date_time", deleted_date_time)
        if updated_by is not None:
            pulumi.set(__self__, "updated_by", updated_by)
        if updated_by_email is not None:
            pulumi.set(__self__, "updated_by_email", updated_by_email)
        if updated_by_full_name is not None:
            pulumi.set(__self__, "updated_by_full_name", updated_by_full_name)
        if updated_date_time is not None:
            pulumi.set(__self__, "updated_date_time", updated_date_time)

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Created by User Key
        """
        return pulumi.get(self, "created_by")

    @created_by.setter
    def created_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_by", value)

    @_builtins.property
    @pulumi.getter(name="createdByEmail")
    def created_by_email(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Created by User Email Address
        """
        return pulumi.get(self, "created_by_email")

    @created_by_email.setter
    def created_by_email(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_by_email", value)

    @_builtins.property
    @pulumi.getter(name="createdByFullName")
    def created_by_full_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Created by User Full Name
        """
        return pulumi.get(self, "created_by_full_name")

    @created_by_full_name.setter
    def created_by_full_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_by_full_name", value)

    @_builtins.property
    @pulumi.getter(name="createdDateTime")
    def created_date_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Created by Date and Time
        """
        return pulumi.get(self, "created_date_time")

    @created_date_time.setter
    def created_date_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_date_time", value)

    @_builtins.property
    @pulumi.getter(name="deletedBy")
    def deleted_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Deleted by User Key
        """
        return pulumi.get(self, "deleted_by")

    @deleted_by.setter
    def deleted_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deleted_by", value)

    @_builtins.property
    @pulumi.getter(name="deletedByEmail")
    def deleted_by_email(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Deleted by User Email Address
        """
        return pulumi.get(self, "deleted_by_email")

    @deleted_by_email.setter
    def deleted_by_email(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deleted_by_email", value)

    @_builtins.property
    @pulumi.getter(name="deletedByFullName")
    def deleted_by_full_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Deleted by User Full Name
        """
        return pulumi.get(self, "deleted_by_full_name")

    @deleted_by_full_name.setter
    def deleted_by_full_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deleted_by_full_name", value)

    @_builtins.property
    @pulumi.getter(name="deletedDateTime")
    def deleted_date_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Deleted by Date and Time
        """
        return pulumi.get(self, "deleted_date_time")

    @deleted_date_time.setter
    def deleted_date_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deleted_date_time", value)

    @_builtins.property
    @pulumi.getter(name="updatedBy")
    def updated_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Updated by User Key
        """
        return pulumi.get(self, "updated_by")

    @updated_by.setter
    def updated_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_by", value)

    @_builtins.property
    @pulumi.getter(name="updatedByEmail")
    def updated_by_email(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Updated by User Email Address
        """
        return pulumi.get(self, "updated_by_email")

    @updated_by_email.setter
    def updated_by_email(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_by_email", value)

    @_builtins.property
    @pulumi.getter(name="updatedByFullName")
    def updated_by_full_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Updated by User Full Name
        """
        return pulumi.get(self, "updated_by_full_name")

    @updated_by_full_name.setter
    def updated_by_full_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_by_full_name", value)

    @_builtins.property
    @pulumi.getter(name="updatedDateTime")
    def updated_date_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Updated by Date and Time
        """
        return pulumi.get(self, "updated_date_time")

    @updated_date_time.setter
    def updated_date_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_date_time", value)


if not MYPY:
    class RouteFilterProjectArgsDict(TypedDict):
        project_id: pulumi.Input[_builtins.str]
        """
        Project id associated with Fabric Project
        """
        href: NotRequired[pulumi.Input[_builtins.str]]
        """
        URI of the Fabric Project
        """
elif False:
    RouteFilterProjectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteFilterProjectArgs:
    def __init__(__self__, *,
                 project_id: pulumi.Input[_builtins.str],
                 href: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] project_id: Project id associated with Fabric Project
        :param pulumi.Input[_builtins.str] href: URI of the Fabric Project
        """
        pulumi.set(__self__, "project_id", project_id)
        if href is not None:
            pulumi.set(__self__, "href", href)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> pulumi.Input[_builtins.str]:
        """
        Project id associated with Fabric Project
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "project_id", value)

    @_builtins.property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        URI of the Fabric Project
        """
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "href", value)


if not MYPY:
    class RouteFilterRuleChangeArgsDict(TypedDict):
        href: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URI of the previous Route Filter Rule Change
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type of change. One of [ "BGP_IPv4_PREFIX_FILTER_RULE_UPDATE","BGP_IPv4_PREFIX_FILTER_RULE_CREATION","BGP_IPv4_PREFIX_FILTER_RULE_DELETION","BGP_IPv6_PREFIX_FILTER_RULE_UPDATE","BGP_IPv6_PREFIX_FILTER_RULE_CREATION","BGP_IPv6_PREFIX_FILTER_RULE_DELETION" ]
        """
        uuid: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unique identifier for the previous change
        """
elif False:
    RouteFilterRuleChangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteFilterRuleChangeArgs:
    def __init__(__self__, *,
                 href: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 uuid: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] href: The URI of the previous Route Filter Rule Change
        :param pulumi.Input[_builtins.str] type: Type of change. One of [ "BGP_IPv4_PREFIX_FILTER_RULE_UPDATE","BGP_IPv4_PREFIX_FILTER_RULE_CREATION","BGP_IPv4_PREFIX_FILTER_RULE_DELETION","BGP_IPv6_PREFIX_FILTER_RULE_UPDATE","BGP_IPv6_PREFIX_FILTER_RULE_CREATION","BGP_IPv6_PREFIX_FILTER_RULE_DELETION" ]
        :param pulumi.Input[_builtins.str] uuid: Unique identifier for the previous change
        """
        if href is not None:
            pulumi.set(__self__, "href", href)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URI of the previous Route Filter Rule Change
        """
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "href", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type of change. One of [ "BGP_IPv4_PREFIX_FILTER_RULE_UPDATE","BGP_IPv4_PREFIX_FILTER_RULE_CREATION","BGP_IPv4_PREFIX_FILTER_RULE_DELETION","BGP_IPv6_PREFIX_FILTER_RULE_UPDATE","BGP_IPv6_PREFIX_FILTER_RULE_CREATION","BGP_IPv6_PREFIX_FILTER_RULE_DELETION" ]
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unique identifier for the previous change
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class RouteFilterRuleChangeLogArgsDict(TypedDict):
        created_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        Created by User Key
        """
        created_by_email: NotRequired[pulumi.Input[_builtins.str]]
        """
        Created by User Email Address
        """
        created_by_full_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Created by User Full Name
        """
        created_date_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Created by Date and Time
        """
        deleted_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        Deleted by User Key
        """
        deleted_by_email: NotRequired[pulumi.Input[_builtins.str]]
        """
        Deleted by User Email Address
        """
        deleted_by_full_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Deleted by User Full Name
        """
        deleted_date_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Deleted by Date and Time
        """
        updated_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        Updated by User Key
        """
        updated_by_email: NotRequired[pulumi.Input[_builtins.str]]
        """
        Updated by User Email Address
        """
        updated_by_full_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Updated by User Full Name
        """
        updated_date_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Updated by Date and Time
        """
elif False:
    RouteFilterRuleChangeLogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteFilterRuleChangeLogArgs:
    def __init__(__self__, *,
                 created_by: Optional[pulumi.Input[_builtins.str]] = None,
                 created_by_email: Optional[pulumi.Input[_builtins.str]] = None,
                 created_by_full_name: Optional[pulumi.Input[_builtins.str]] = None,
                 created_date_time: Optional[pulumi.Input[_builtins.str]] = None,
                 deleted_by: Optional[pulumi.Input[_builtins.str]] = None,
                 deleted_by_email: Optional[pulumi.Input[_builtins.str]] = None,
                 deleted_by_full_name: Optional[pulumi.Input[_builtins.str]] = None,
                 deleted_date_time: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_by: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_by_email: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_by_full_name: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_date_time: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] created_by: Created by User Key
        :param pulumi.Input[_builtins.str] created_by_email: Created by User Email Address
        :param pulumi.Input[_builtins.str] created_by_full_name: Created by User Full Name
        :param pulumi.Input[_builtins.str] created_date_time: Created by Date and Time
        :param pulumi.Input[_builtins.str] deleted_by: Deleted by User Key
        :param pulumi.Input[_builtins.str] deleted_by_email: Deleted by User Email Address
        :param pulumi.Input[_builtins.str] deleted_by_full_name: Deleted by User Full Name
        :param pulumi.Input[_builtins.str] deleted_date_time: Deleted by Date and Time
        :param pulumi.Input[_builtins.str] updated_by: Updated by User Key
        :param pulumi.Input[_builtins.str] updated_by_email: Updated by User Email Address
        :param pulumi.Input[_builtins.str] updated_by_full_name: Updated by User Full Name
        :param pulumi.Input[_builtins.str] updated_date_time: Updated by Date and Time
        """
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if created_by_email is not None:
            pulumi.set(__self__, "created_by_email", created_by_email)
        if created_by_full_name is not None:
            pulumi.set(__self__, "created_by_full_name", created_by_full_name)
        if created_date_time is not None:
            pulumi.set(__self__, "created_date_time", created_date_time)
        if deleted_by is not None:
            pulumi.set(__self__, "deleted_by", deleted_by)
        if deleted_by_email is not None:
            pulumi.set(__self__, "deleted_by_email", deleted_by_email)
        if deleted_by_full_name is not None:
            pulumi.set(__self__, "deleted_by_full_name", deleted_by_full_name)
        if deleted_date_time is not None:
            pulumi.set(__self__, "deleted_date_time", deleted_date_time)
        if updated_by is not None:
            pulumi.set(__self__, "updated_by", updated_by)
        if updated_by_email is not None:
            pulumi.set(__self__, "updated_by_email", updated_by_email)
        if updated_by_full_name is not None:
            pulumi.set(__self__, "updated_by_full_name", updated_by_full_name)
        if updated_date_time is not None:
            pulumi.set(__self__, "updated_date_time", updated_date_time)

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Created by User Key
        """
        return pulumi.get(self, "created_by")

    @created_by.setter
    def created_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_by", value)

    @_builtins.property
    @pulumi.getter(name="createdByEmail")
    def created_by_email(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Created by User Email Address
        """
        return pulumi.get(self, "created_by_email")

    @created_by_email.setter
    def created_by_email(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_by_email", value)

    @_builtins.property
    @pulumi.getter(name="createdByFullName")
    def created_by_full_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Created by User Full Name
        """
        return pulumi.get(self, "created_by_full_name")

    @created_by_full_name.setter
    def created_by_full_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_by_full_name", value)

    @_builtins.property
    @pulumi.getter(name="createdDateTime")
    def created_date_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Created by Date and Time
        """
        return pulumi.get(self, "created_date_time")

    @created_date_time.setter
    def created_date_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_date_time", value)

    @_builtins.property
    @pulumi.getter(name="deletedBy")
    def deleted_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Deleted by User Key
        """
        return pulumi.get(self, "deleted_by")

    @deleted_by.setter
    def deleted_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deleted_by", value)

    @_builtins.property
    @pulumi.getter(name="deletedByEmail")
    def deleted_by_email(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Deleted by User Email Address
        """
        return pulumi.get(self, "deleted_by_email")

    @deleted_by_email.setter
    def deleted_by_email(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deleted_by_email", value)

    @_builtins.property
    @pulumi.getter(name="deletedByFullName")
    def deleted_by_full_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Deleted by User Full Name
        """
        return pulumi.get(self, "deleted_by_full_name")

    @deleted_by_full_name.setter
    def deleted_by_full_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deleted_by_full_name", value)

    @_builtins.property
    @pulumi.getter(name="deletedDateTime")
    def deleted_date_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Deleted by Date and Time
        """
        return pulumi.get(self, "deleted_date_time")

    @deleted_date_time.setter
    def deleted_date_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deleted_date_time", value)

    @_builtins.property
    @pulumi.getter(name="updatedBy")
    def updated_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Updated by User Key
        """
        return pulumi.get(self, "updated_by")

    @updated_by.setter
    def updated_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_by", value)

    @_builtins.property
    @pulumi.getter(name="updatedByEmail")
    def updated_by_email(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Updated by User Email Address
        """
        return pulumi.get(self, "updated_by_email")

    @updated_by_email.setter
    def updated_by_email(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_by_email", value)

    @_builtins.property
    @pulumi.getter(name="updatedByFullName")
    def updated_by_full_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Updated by User Full Name
        """
        return pulumi.get(self, "updated_by_full_name")

    @updated_by_full_name.setter
    def updated_by_full_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_by_full_name", value)

    @_builtins.property
    @pulumi.getter(name="updatedDateTime")
    def updated_date_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Updated by Date and Time
        """
        return pulumi.get(self, "updated_date_time")

    @updated_date_time.setter
    def updated_date_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_date_time", value)


if not MYPY:
    class RoutingProtocolBfdArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Bidirectional Forwarding Detection enablement
        """
        interval: NotRequired[pulumi.Input[_builtins.str]]
        """
        Interval range between the received BFD control packets
        """
elif False:
    RoutingProtocolBfdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RoutingProtocolBfdArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 interval: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Bidirectional Forwarding Detection enablement
        :param pulumi.Input[_builtins.str] interval: Interval range between the received BFD control packets
        """
        pulumi.set(__self__, "enabled", enabled)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Bidirectional Forwarding Detection enablement
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Interval range between the received BFD control packets
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "interval", value)


if not MYPY:
    class RoutingProtocolBgpIpv4ArgsDict(TypedDict):
        customer_peer_ip: pulumi.Input[_builtins.str]
        """
        Customer side peering ip
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Admin status for the BGP session
        """
        equinix_peer_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        Equinix side peering ip
        """
        inbound_med: NotRequired[pulumi.Input[_builtins.int]]
        """
        Inbound Multi Exit Discriminator attribute
        """
        outbound_as_prepend_count: NotRequired[pulumi.Input[_builtins.str]]
        """
        AS path prepend count. One of: 0, 1, 3, 5
        """
        outbound_med: NotRequired[pulumi.Input[_builtins.int]]
        """
        Outbound Multi Exit Discriminator attribute
        """
elif False:
    RoutingProtocolBgpIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RoutingProtocolBgpIpv4Args:
    def __init__(__self__, *,
                 customer_peer_ip: pulumi.Input[_builtins.str],
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 equinix_peer_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 inbound_med: Optional[pulumi.Input[_builtins.int]] = None,
                 outbound_as_prepend_count: Optional[pulumi.Input[_builtins.str]] = None,
                 outbound_med: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] customer_peer_ip: Customer side peering ip
        :param pulumi.Input[_builtins.bool] enabled: Admin status for the BGP session
        :param pulumi.Input[_builtins.str] equinix_peer_ip: Equinix side peering ip
        :param pulumi.Input[_builtins.int] inbound_med: Inbound Multi Exit Discriminator attribute
        :param pulumi.Input[_builtins.str] outbound_as_prepend_count: AS path prepend count. One of: 0, 1, 3, 5
        :param pulumi.Input[_builtins.int] outbound_med: Outbound Multi Exit Discriminator attribute
        """
        pulumi.set(__self__, "customer_peer_ip", customer_peer_ip)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if equinix_peer_ip is not None:
            pulumi.set(__self__, "equinix_peer_ip", equinix_peer_ip)
        if inbound_med is not None:
            pulumi.set(__self__, "inbound_med", inbound_med)
        if outbound_as_prepend_count is not None:
            pulumi.set(__self__, "outbound_as_prepend_count", outbound_as_prepend_count)
        if outbound_med is not None:
            pulumi.set(__self__, "outbound_med", outbound_med)

    @_builtins.property
    @pulumi.getter(name="customerPeerIp")
    def customer_peer_ip(self) -> pulumi.Input[_builtins.str]:
        """
        Customer side peering ip
        """
        return pulumi.get(self, "customer_peer_ip")

    @customer_peer_ip.setter
    def customer_peer_ip(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "customer_peer_ip", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Admin status for the BGP session
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="equinixPeerIp")
    def equinix_peer_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Equinix side peering ip
        """
        return pulumi.get(self, "equinix_peer_ip")

    @equinix_peer_ip.setter
    def equinix_peer_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "equinix_peer_ip", value)

    @_builtins.property
    @pulumi.getter(name="inboundMed")
    def inbound_med(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Inbound Multi Exit Discriminator attribute
        """
        return pulumi.get(self, "inbound_med")

    @inbound_med.setter
    def inbound_med(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "inbound_med", value)

    @_builtins.property
    @pulumi.getter(name="outboundAsPrependCount")
    def outbound_as_prepend_count(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        AS path prepend count. One of: 0, 1, 3, 5
        """
        return pulumi.get(self, "outbound_as_prepend_count")

    @outbound_as_prepend_count.setter
    def outbound_as_prepend_count(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "outbound_as_prepend_count", value)

    @_builtins.property
    @pulumi.getter(name="outboundMed")
    def outbound_med(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Outbound Multi Exit Discriminator attribute
        """
        return pulumi.get(self, "outbound_med")

    @outbound_med.setter
    def outbound_med(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "outbound_med", value)


if not MYPY:
    class RoutingProtocolBgpIpv6ArgsDict(TypedDict):
        customer_peer_ip: pulumi.Input[_builtins.str]
        """
        Customer side peering ip
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Admin status for the BGP session
        """
        equinix_peer_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        Equinix side peering ip
        """
        inbound_med: NotRequired[pulumi.Input[_builtins.int]]
        """
        Inbound Multi Exit Discriminator attribute
        """
        outbound_as_prepend_count: NotRequired[pulumi.Input[_builtins.str]]
        """
        AS path prepend count. One of: 0, 1, 3, 5
        """
        outbound_med: NotRequired[pulumi.Input[_builtins.int]]
        """
        Outbound Multi Exit Discriminator attribute
        """
elif False:
    RoutingProtocolBgpIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RoutingProtocolBgpIpv6Args:
    def __init__(__self__, *,
                 customer_peer_ip: pulumi.Input[_builtins.str],
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 equinix_peer_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 inbound_med: Optional[pulumi.Input[_builtins.int]] = None,
                 outbound_as_prepend_count: Optional[pulumi.Input[_builtins.str]] = None,
                 outbound_med: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] customer_peer_ip: Customer side peering ip
        :param pulumi.Input[_builtins.bool] enabled: Admin status for the BGP session
        :param pulumi.Input[_builtins.str] equinix_peer_ip: Equinix side peering ip
        :param pulumi.Input[_builtins.int] inbound_med: Inbound Multi Exit Discriminator attribute
        :param pulumi.Input[_builtins.str] outbound_as_prepend_count: AS path prepend count. One of: 0, 1, 3, 5
        :param pulumi.Input[_builtins.int] outbound_med: Outbound Multi Exit Discriminator attribute
        """
        pulumi.set(__self__, "customer_peer_ip", customer_peer_ip)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if equinix_peer_ip is not None:
            pulumi.set(__self__, "equinix_peer_ip", equinix_peer_ip)
        if inbound_med is not None:
            pulumi.set(__self__, "inbound_med", inbound_med)
        if outbound_as_prepend_count is not None:
            pulumi.set(__self__, "outbound_as_prepend_count", outbound_as_prepend_count)
        if outbound_med is not None:
            pulumi.set(__self__, "outbound_med", outbound_med)

    @_builtins.property
    @pulumi.getter(name="customerPeerIp")
    def customer_peer_ip(self) -> pulumi.Input[_builtins.str]:
        """
        Customer side peering ip
        """
        return pulumi.get(self, "customer_peer_ip")

    @customer_peer_ip.setter
    def customer_peer_ip(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "customer_peer_ip", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Admin status for the BGP session
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="equinixPeerIp")
    def equinix_peer_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Equinix side peering ip
        """
        return pulumi.get(self, "equinix_peer_ip")

    @equinix_peer_ip.setter
    def equinix_peer_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "equinix_peer_ip", value)

    @_builtins.property
    @pulumi.getter(name="inboundMed")
    def inbound_med(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Inbound Multi Exit Discriminator attribute
        """
        return pulumi.get(self, "inbound_med")

    @inbound_med.setter
    def inbound_med(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "inbound_med", value)

    @_builtins.property
    @pulumi.getter(name="outboundAsPrependCount")
    def outbound_as_prepend_count(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        AS path prepend count. One of: 0, 1, 3, 5
        """
        return pulumi.get(self, "outbound_as_prepend_count")

    @outbound_as_prepend_count.setter
    def outbound_as_prepend_count(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "outbound_as_prepend_count", value)

    @_builtins.property
    @pulumi.getter(name="outboundMed")
    def outbound_med(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Outbound Multi Exit Discriminator attribute
        """
        return pulumi.get(self, "outbound_med")

    @outbound_med.setter
    def outbound_med(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "outbound_med", value)


if not MYPY:
    class RoutingProtocolChangeArgsDict(TypedDict):
        href: NotRequired[pulumi.Input[_builtins.str]]
        """
        Routing Protocol Change URI
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type of change
        """
        uuid: NotRequired[pulumi.Input[_builtins.str]]
        """
        Uniquely identifies a change
        """
elif False:
    RoutingProtocolChangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RoutingProtocolChangeArgs:
    def __init__(__self__, *,
                 href: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 uuid: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] href: Routing Protocol Change URI
        :param pulumi.Input[_builtins.str] type: Type of change
        :param pulumi.Input[_builtins.str] uuid: Uniquely identifies a change
        """
        if href is not None:
            pulumi.set(__self__, "href", href)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Routing Protocol Change URI
        """
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "href", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type of change
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Uniquely identifies a change
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class RoutingProtocolChangeLogArgsDict(TypedDict):
        created_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        Created by User Key
        """
        created_by_email: NotRequired[pulumi.Input[_builtins.str]]
        """
        Created by User Email Address
        """
        created_by_full_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Created by User Full Name
        """
        created_date_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Created by Date and Time
        """
        deleted_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        Deleted by User Key
        """
        deleted_by_email: NotRequired[pulumi.Input[_builtins.str]]
        """
        Deleted by User Email Address
        """
        deleted_by_full_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Deleted by User Full Name
        """
        deleted_date_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Deleted by Date and Time
        """
        updated_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        Updated by User Key
        """
        updated_by_email: NotRequired[pulumi.Input[_builtins.str]]
        """
        Updated by User Email Address
        """
        updated_by_full_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Updated by User Full Name
        """
        updated_date_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Updated by Date and Time
        """
elif False:
    RoutingProtocolChangeLogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RoutingProtocolChangeLogArgs:
    def __init__(__self__, *,
                 created_by: Optional[pulumi.Input[_builtins.str]] = None,
                 created_by_email: Optional[pulumi.Input[_builtins.str]] = None,
                 created_by_full_name: Optional[pulumi.Input[_builtins.str]] = None,
                 created_date_time: Optional[pulumi.Input[_builtins.str]] = None,
                 deleted_by: Optional[pulumi.Input[_builtins.str]] = None,
                 deleted_by_email: Optional[pulumi.Input[_builtins.str]] = None,
                 deleted_by_full_name: Optional[pulumi.Input[_builtins.str]] = None,
                 deleted_date_time: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_by: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_by_email: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_by_full_name: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_date_time: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] created_by: Created by User Key
        :param pulumi.Input[_builtins.str] created_by_email: Created by User Email Address
        :param pulumi.Input[_builtins.str] created_by_full_name: Created by User Full Name
        :param pulumi.Input[_builtins.str] created_date_time: Created by Date and Time
        :param pulumi.Input[_builtins.str] deleted_by: Deleted by User Key
        :param pulumi.Input[_builtins.str] deleted_by_email: Deleted by User Email Address
        :param pulumi.Input[_builtins.str] deleted_by_full_name: Deleted by User Full Name
        :param pulumi.Input[_builtins.str] deleted_date_time: Deleted by Date and Time
        :param pulumi.Input[_builtins.str] updated_by: Updated by User Key
        :param pulumi.Input[_builtins.str] updated_by_email: Updated by User Email Address
        :param pulumi.Input[_builtins.str] updated_by_full_name: Updated by User Full Name
        :param pulumi.Input[_builtins.str] updated_date_time: Updated by Date and Time
        """
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if created_by_email is not None:
            pulumi.set(__self__, "created_by_email", created_by_email)
        if created_by_full_name is not None:
            pulumi.set(__self__, "created_by_full_name", created_by_full_name)
        if created_date_time is not None:
            pulumi.set(__self__, "created_date_time", created_date_time)
        if deleted_by is not None:
            pulumi.set(__self__, "deleted_by", deleted_by)
        if deleted_by_email is not None:
            pulumi.set(__self__, "deleted_by_email", deleted_by_email)
        if deleted_by_full_name is not None:
            pulumi.set(__self__, "deleted_by_full_name", deleted_by_full_name)
        if deleted_date_time is not None:
            pulumi.set(__self__, "deleted_date_time", deleted_date_time)
        if updated_by is not None:
            pulumi.set(__self__, "updated_by", updated_by)
        if updated_by_email is not None:
            pulumi.set(__self__, "updated_by_email", updated_by_email)
        if updated_by_full_name is not None:
            pulumi.set(__self__, "updated_by_full_name", updated_by_full_name)
        if updated_date_time is not None:
            pulumi.set(__self__, "updated_date_time", updated_date_time)

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Created by User Key
        """
        return pulumi.get(self, "created_by")

    @created_by.setter
    def created_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_by", value)

    @_builtins.property
    @pulumi.getter(name="createdByEmail")
    def created_by_email(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Created by User Email Address
        """
        return pulumi.get(self, "created_by_email")

    @created_by_email.setter
    def created_by_email(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_by_email", value)

    @_builtins.property
    @pulumi.getter(name="createdByFullName")
    def created_by_full_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Created by User Full Name
        """
        return pulumi.get(self, "created_by_full_name")

    @created_by_full_name.setter
    def created_by_full_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_by_full_name", value)

    @_builtins.property
    @pulumi.getter(name="createdDateTime")
    def created_date_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Created by Date and Time
        """
        return pulumi.get(self, "created_date_time")

    @created_date_time.setter
    def created_date_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_date_time", value)

    @_builtins.property
    @pulumi.getter(name="deletedBy")
    def deleted_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Deleted by User Key
        """
        return pulumi.get(self, "deleted_by")

    @deleted_by.setter
    def deleted_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deleted_by", value)

    @_builtins.property
    @pulumi.getter(name="deletedByEmail")
    def deleted_by_email(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Deleted by User Email Address
        """
        return pulumi.get(self, "deleted_by_email")

    @deleted_by_email.setter
    def deleted_by_email(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deleted_by_email", value)

    @_builtins.property
    @pulumi.getter(name="deletedByFullName")
    def deleted_by_full_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Deleted by User Full Name
        """
        return pulumi.get(self, "deleted_by_full_name")

    @deleted_by_full_name.setter
    def deleted_by_full_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deleted_by_full_name", value)

    @_builtins.property
    @pulumi.getter(name="deletedDateTime")
    def deleted_date_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Deleted by Date and Time
        """
        return pulumi.get(self, "deleted_date_time")

    @deleted_date_time.setter
    def deleted_date_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deleted_date_time", value)

    @_builtins.property
    @pulumi.getter(name="updatedBy")
    def updated_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Updated by User Key
        """
        return pulumi.get(self, "updated_by")

    @updated_by.setter
    def updated_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_by", value)

    @_builtins.property
    @pulumi.getter(name="updatedByEmail")
    def updated_by_email(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Updated by User Email Address
        """
        return pulumi.get(self, "updated_by_email")

    @updated_by_email.setter
    def updated_by_email(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_by_email", value)

    @_builtins.property
    @pulumi.getter(name="updatedByFullName")
    def updated_by_full_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Updated by User Full Name
        """
        return pulumi.get(self, "updated_by_full_name")

    @updated_by_full_name.setter
    def updated_by_full_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_by_full_name", value)

    @_builtins.property
    @pulumi.getter(name="updatedDateTime")
    def updated_date_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Updated by Date and Time
        """
        return pulumi.get(self, "updated_date_time")

    @updated_date_time.setter
    def updated_date_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_date_time", value)


if not MYPY:
    class RoutingProtocolDirectIpv4ArgsDict(TypedDict):
        equinix_iface_ip: pulumi.Input[_builtins.str]
        """
        Equinix side Interface IP address
        """
elif False:
    RoutingProtocolDirectIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RoutingProtocolDirectIpv4Args:
    def __init__(__self__, *,
                 equinix_iface_ip: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] equinix_iface_ip: Equinix side Interface IP address
        """
        pulumi.set(__self__, "equinix_iface_ip", equinix_iface_ip)

    @_builtins.property
    @pulumi.getter(name="equinixIfaceIp")
    def equinix_iface_ip(self) -> pulumi.Input[_builtins.str]:
        """
        Equinix side Interface IP address
        """
        return pulumi.get(self, "equinix_iface_ip")

    @equinix_iface_ip.setter
    def equinix_iface_ip(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "equinix_iface_ip", value)


if not MYPY:
    class RoutingProtocolDirectIpv6ArgsDict(TypedDict):
        equinix_iface_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        Equinix side Interface IP address
        """
elif False:
    RoutingProtocolDirectIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RoutingProtocolDirectIpv6Args:
    def __init__(__self__, *,
                 equinix_iface_ip: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] equinix_iface_ip: Equinix side Interface IP address
        """
        if equinix_iface_ip is not None:
            pulumi.set(__self__, "equinix_iface_ip", equinix_iface_ip)

    @_builtins.property
    @pulumi.getter(name="equinixIfaceIp")
    def equinix_iface_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Equinix side Interface IP address
        """
        return pulumi.get(self, "equinix_iface_ip")

    @equinix_iface_ip.setter
    def equinix_iface_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "equinix_iface_ip", value)


if not MYPY:
    class RoutingProtocolOperationArgsDict(TypedDict):
        errors: NotRequired[pulumi.Input[Sequence[pulumi.Input['RoutingProtocolOperationErrorArgsDict']]]]
        """
        Errors occurred
        """
elif False:
    RoutingProtocolOperationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RoutingProtocolOperationArgs:
    def __init__(__self__, *,
                 errors: Optional[pulumi.Input[Sequence[pulumi.Input['RoutingProtocolOperationErrorArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RoutingProtocolOperationErrorArgs']]] errors: Errors occurred
        """
        if errors is not None:
            pulumi.set(__self__, "errors", errors)

    @_builtins.property
    @pulumi.getter
    def errors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RoutingProtocolOperationErrorArgs']]]]:
        """
        Errors occurred
        """
        return pulumi.get(self, "errors")

    @errors.setter
    def errors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RoutingProtocolOperationErrorArgs']]]]):
        pulumi.set(self, "errors", value)


if not MYPY:
    class RoutingProtocolOperationErrorArgsDict(TypedDict):
        additional_infos: NotRequired[pulumi.Input[Sequence[pulumi.Input['RoutingProtocolOperationErrorAdditionalInfoArgsDict']]]]
        """
        Pricing error additional Info
        """
        correlation_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        CorrelationId
        """
        details: NotRequired[pulumi.Input[_builtins.str]]
        """
        Details
        """
        error_code: NotRequired[pulumi.Input[_builtins.str]]
        """
        Error  code
        """
        error_message: NotRequired[pulumi.Input[_builtins.str]]
        """
        Error Message
        """
        help: NotRequired[pulumi.Input[_builtins.str]]
        """
        Help
        """
elif False:
    RoutingProtocolOperationErrorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RoutingProtocolOperationErrorArgs:
    def __init__(__self__, *,
                 additional_infos: Optional[pulumi.Input[Sequence[pulumi.Input['RoutingProtocolOperationErrorAdditionalInfoArgs']]]] = None,
                 correlation_id: Optional[pulumi.Input[_builtins.str]] = None,
                 details: Optional[pulumi.Input[_builtins.str]] = None,
                 error_code: Optional[pulumi.Input[_builtins.str]] = None,
                 error_message: Optional[pulumi.Input[_builtins.str]] = None,
                 help: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RoutingProtocolOperationErrorAdditionalInfoArgs']]] additional_infos: Pricing error additional Info
        :param pulumi.Input[_builtins.str] correlation_id: CorrelationId
        :param pulumi.Input[_builtins.str] details: Details
        :param pulumi.Input[_builtins.str] error_code: Error  code
        :param pulumi.Input[_builtins.str] error_message: Error Message
        :param pulumi.Input[_builtins.str] help: Help
        """
        if additional_infos is not None:
            pulumi.set(__self__, "additional_infos", additional_infos)
        if correlation_id is not None:
            pulumi.set(__self__, "correlation_id", correlation_id)
        if details is not None:
            pulumi.set(__self__, "details", details)
        if error_code is not None:
            pulumi.set(__self__, "error_code", error_code)
        if error_message is not None:
            pulumi.set(__self__, "error_message", error_message)
        if help is not None:
            pulumi.set(__self__, "help", help)

    @_builtins.property
    @pulumi.getter(name="additionalInfos")
    def additional_infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RoutingProtocolOperationErrorAdditionalInfoArgs']]]]:
        """
        Pricing error additional Info
        """
        return pulumi.get(self, "additional_infos")

    @additional_infos.setter
    def additional_infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RoutingProtocolOperationErrorAdditionalInfoArgs']]]]):
        pulumi.set(self, "additional_infos", value)

    @_builtins.property
    @pulumi.getter(name="correlationId")
    def correlation_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        CorrelationId
        """
        return pulumi.get(self, "correlation_id")

    @correlation_id.setter
    def correlation_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "correlation_id", value)

    @_builtins.property
    @pulumi.getter
    def details(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Details
        """
        return pulumi.get(self, "details")

    @details.setter
    def details(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "details", value)

    @_builtins.property
    @pulumi.getter(name="errorCode")
    def error_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Error  code
        """
        return pulumi.get(self, "error_code")

    @error_code.setter
    def error_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "error_code", value)

    @_builtins.property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Error Message
        """
        return pulumi.get(self, "error_message")

    @error_message.setter
    def error_message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "error_message", value)

    @_builtins.property
    @pulumi.getter
    def help(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Help
        """
        return pulumi.get(self, "help")

    @help.setter
    def help(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "help", value)


if not MYPY:
    class RoutingProtocolOperationErrorAdditionalInfoArgsDict(TypedDict):
        property: NotRequired[pulumi.Input[_builtins.str]]
        """
        Property at which the error potentially occurred
        """
        reason: NotRequired[pulumi.Input[_builtins.str]]
        """
        Reason for the error
        """
elif False:
    RoutingProtocolOperationErrorAdditionalInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RoutingProtocolOperationErrorAdditionalInfoArgs:
    def __init__(__self__, *,
                 property: Optional[pulumi.Input[_builtins.str]] = None,
                 reason: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] property: Property at which the error potentially occurred
        :param pulumi.Input[_builtins.str] reason: Reason for the error
        """
        if property is not None:
            pulumi.set(__self__, "property", property)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @_builtins.property
    @pulumi.getter
    def property(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Property at which the error potentially occurred
        """
        return pulumi.get(self, "property")

    @property.setter
    def property(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "property", value)

    @_builtins.property
    @pulumi.getter
    def reason(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Reason for the error
        """
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "reason", value)


if not MYPY:
    class ServiceProfileAccessPointTypeConfigArgsDict(TypedDict):
        type: pulumi.Input[Union[_builtins.str, 'ProfileAccessPointType']]
        """
        Type of access point type config - VD, COLO
        """
        allow_bandwidth_auto_approval: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Setting to enable or disable the ability of the buyer to change connection bandwidth without approval of the seller
        """
        allow_bandwidth_upgrade: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Availability of a bandwidth upgrade. The default is false
        """
        allow_custom_bandwidth: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Setting to enable or disable the ability of the buyer to customize the bandwidth
        """
        allow_remote_connections: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Setting to allow or prohibit remote connections to the service profile
        """
        api_config: NotRequired[pulumi.Input['ServiceProfileAccessPointTypeConfigApiConfigArgsDict']]
        """
        Api configuration details
        """
        authentication_key: NotRequired[pulumi.Input['ServiceProfileAccessPointTypeConfigAuthenticationKeyArgsDict']]
        """
        Authentication key details
        """
        bandwidth_alert_threshold: NotRequired[pulumi.Input[_builtins.float]]
        """
        Percentage of port bandwidth at which an allocation alert is generated
        """
        connection_label: NotRequired[pulumi.Input[_builtins.str]]
        """
        Custom name for Connection
        """
        connection_redundancy_required: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Mandate redundant connections
        """
        enable_auto_generate_service_key: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable auto generate service key
        """
        link_protocol_config: NotRequired[pulumi.Input['ServiceProfileAccessPointTypeConfigLinkProtocolConfigArgsDict']]
        """
        Link protocol configuration details
        """
        supported_bandwidths: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        Supported bandwidths
        """
        uuid: NotRequired[pulumi.Input[_builtins.str]]
        """
        Colo/Port Uuid
        """
elif False:
    ServiceProfileAccessPointTypeConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceProfileAccessPointTypeConfigArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[Union[_builtins.str, 'ProfileAccessPointType']],
                 allow_bandwidth_auto_approval: Optional[pulumi.Input[_builtins.bool]] = None,
                 allow_bandwidth_upgrade: Optional[pulumi.Input[_builtins.bool]] = None,
                 allow_custom_bandwidth: Optional[pulumi.Input[_builtins.bool]] = None,
                 allow_remote_connections: Optional[pulumi.Input[_builtins.bool]] = None,
                 api_config: Optional[pulumi.Input['ServiceProfileAccessPointTypeConfigApiConfigArgs']] = None,
                 authentication_key: Optional[pulumi.Input['ServiceProfileAccessPointTypeConfigAuthenticationKeyArgs']] = None,
                 bandwidth_alert_threshold: Optional[pulumi.Input[_builtins.float]] = None,
                 connection_label: Optional[pulumi.Input[_builtins.str]] = None,
                 connection_redundancy_required: Optional[pulumi.Input[_builtins.bool]] = None,
                 enable_auto_generate_service_key: Optional[pulumi.Input[_builtins.bool]] = None,
                 link_protocol_config: Optional[pulumi.Input['ServiceProfileAccessPointTypeConfigLinkProtocolConfigArgs']] = None,
                 supported_bandwidths: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None,
                 uuid: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Union[_builtins.str, 'ProfileAccessPointType']] type: Type of access point type config - VD, COLO
        :param pulumi.Input[_builtins.bool] allow_bandwidth_auto_approval: Setting to enable or disable the ability of the buyer to change connection bandwidth without approval of the seller
        :param pulumi.Input[_builtins.bool] allow_bandwidth_upgrade: Availability of a bandwidth upgrade. The default is false
        :param pulumi.Input[_builtins.bool] allow_custom_bandwidth: Setting to enable or disable the ability of the buyer to customize the bandwidth
        :param pulumi.Input[_builtins.bool] allow_remote_connections: Setting to allow or prohibit remote connections to the service profile
        :param pulumi.Input['ServiceProfileAccessPointTypeConfigApiConfigArgs'] api_config: Api configuration details
        :param pulumi.Input['ServiceProfileAccessPointTypeConfigAuthenticationKeyArgs'] authentication_key: Authentication key details
        :param pulumi.Input[_builtins.float] bandwidth_alert_threshold: Percentage of port bandwidth at which an allocation alert is generated
        :param pulumi.Input[_builtins.str] connection_label: Custom name for Connection
        :param pulumi.Input[_builtins.bool] connection_redundancy_required: Mandate redundant connections
        :param pulumi.Input[_builtins.bool] enable_auto_generate_service_key: Enable auto generate service key
        :param pulumi.Input['ServiceProfileAccessPointTypeConfigLinkProtocolConfigArgs'] link_protocol_config: Link protocol configuration details
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] supported_bandwidths: Supported bandwidths
        :param pulumi.Input[_builtins.str] uuid: Colo/Port Uuid
        """
        pulumi.set(__self__, "type", type)
        if allow_bandwidth_auto_approval is not None:
            pulumi.set(__self__, "allow_bandwidth_auto_approval", allow_bandwidth_auto_approval)
        if allow_bandwidth_upgrade is not None:
            pulumi.set(__self__, "allow_bandwidth_upgrade", allow_bandwidth_upgrade)
        if allow_custom_bandwidth is not None:
            pulumi.set(__self__, "allow_custom_bandwidth", allow_custom_bandwidth)
        if allow_remote_connections is not None:
            pulumi.set(__self__, "allow_remote_connections", allow_remote_connections)
        if api_config is not None:
            pulumi.set(__self__, "api_config", api_config)
        if authentication_key is not None:
            pulumi.set(__self__, "authentication_key", authentication_key)
        if bandwidth_alert_threshold is not None:
            pulumi.set(__self__, "bandwidth_alert_threshold", bandwidth_alert_threshold)
        if connection_label is not None:
            pulumi.set(__self__, "connection_label", connection_label)
        if connection_redundancy_required is not None:
            pulumi.set(__self__, "connection_redundancy_required", connection_redundancy_required)
        if enable_auto_generate_service_key is not None:
            pulumi.set(__self__, "enable_auto_generate_service_key", enable_auto_generate_service_key)
        if link_protocol_config is not None:
            pulumi.set(__self__, "link_protocol_config", link_protocol_config)
        if supported_bandwidths is not None:
            pulumi.set(__self__, "supported_bandwidths", supported_bandwidths)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[Union[_builtins.str, 'ProfileAccessPointType']]:
        """
        Type of access point type config - VD, COLO
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[Union[_builtins.str, 'ProfileAccessPointType']]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="allowBandwidthAutoApproval")
    def allow_bandwidth_auto_approval(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Setting to enable or disable the ability of the buyer to change connection bandwidth without approval of the seller
        """
        return pulumi.get(self, "allow_bandwidth_auto_approval")

    @allow_bandwidth_auto_approval.setter
    def allow_bandwidth_auto_approval(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_bandwidth_auto_approval", value)

    @_builtins.property
    @pulumi.getter(name="allowBandwidthUpgrade")
    def allow_bandwidth_upgrade(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Availability of a bandwidth upgrade. The default is false
        """
        return pulumi.get(self, "allow_bandwidth_upgrade")

    @allow_bandwidth_upgrade.setter
    def allow_bandwidth_upgrade(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_bandwidth_upgrade", value)

    @_builtins.property
    @pulumi.getter(name="allowCustomBandwidth")
    def allow_custom_bandwidth(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Setting to enable or disable the ability of the buyer to customize the bandwidth
        """
        return pulumi.get(self, "allow_custom_bandwidth")

    @allow_custom_bandwidth.setter
    def allow_custom_bandwidth(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_custom_bandwidth", value)

    @_builtins.property
    @pulumi.getter(name="allowRemoteConnections")
    def allow_remote_connections(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Setting to allow or prohibit remote connections to the service profile
        """
        return pulumi.get(self, "allow_remote_connections")

    @allow_remote_connections.setter
    def allow_remote_connections(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_remote_connections", value)

    @_builtins.property
    @pulumi.getter(name="apiConfig")
    def api_config(self) -> Optional[pulumi.Input['ServiceProfileAccessPointTypeConfigApiConfigArgs']]:
        """
        Api configuration details
        """
        return pulumi.get(self, "api_config")

    @api_config.setter
    def api_config(self, value: Optional[pulumi.Input['ServiceProfileAccessPointTypeConfigApiConfigArgs']]):
        pulumi.set(self, "api_config", value)

    @_builtins.property
    @pulumi.getter(name="authenticationKey")
    def authentication_key(self) -> Optional[pulumi.Input['ServiceProfileAccessPointTypeConfigAuthenticationKeyArgs']]:
        """
        Authentication key details
        """
        return pulumi.get(self, "authentication_key")

    @authentication_key.setter
    def authentication_key(self, value: Optional[pulumi.Input['ServiceProfileAccessPointTypeConfigAuthenticationKeyArgs']]):
        pulumi.set(self, "authentication_key", value)

    @_builtins.property
    @pulumi.getter(name="bandwidthAlertThreshold")
    def bandwidth_alert_threshold(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Percentage of port bandwidth at which an allocation alert is generated
        """
        return pulumi.get(self, "bandwidth_alert_threshold")

    @bandwidth_alert_threshold.setter
    def bandwidth_alert_threshold(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "bandwidth_alert_threshold", value)

    @_builtins.property
    @pulumi.getter(name="connectionLabel")
    def connection_label(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Custom name for Connection
        """
        return pulumi.get(self, "connection_label")

    @connection_label.setter
    def connection_label(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "connection_label", value)

    @_builtins.property
    @pulumi.getter(name="connectionRedundancyRequired")
    def connection_redundancy_required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Mandate redundant connections
        """
        return pulumi.get(self, "connection_redundancy_required")

    @connection_redundancy_required.setter
    def connection_redundancy_required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "connection_redundancy_required", value)

    @_builtins.property
    @pulumi.getter(name="enableAutoGenerateServiceKey")
    def enable_auto_generate_service_key(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable auto generate service key
        """
        return pulumi.get(self, "enable_auto_generate_service_key")

    @enable_auto_generate_service_key.setter
    def enable_auto_generate_service_key(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_auto_generate_service_key", value)

    @_builtins.property
    @pulumi.getter(name="linkProtocolConfig")
    def link_protocol_config(self) -> Optional[pulumi.Input['ServiceProfileAccessPointTypeConfigLinkProtocolConfigArgs']]:
        """
        Link protocol configuration details
        """
        return pulumi.get(self, "link_protocol_config")

    @link_protocol_config.setter
    def link_protocol_config(self, value: Optional[pulumi.Input['ServiceProfileAccessPointTypeConfigLinkProtocolConfigArgs']]):
        pulumi.set(self, "link_protocol_config", value)

    @_builtins.property
    @pulumi.getter(name="supportedBandwidths")
    def supported_bandwidths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        Supported bandwidths
        """
        return pulumi.get(self, "supported_bandwidths")

    @supported_bandwidths.setter
    def supported_bandwidths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "supported_bandwidths", value)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Colo/Port Uuid
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class ServiceProfileAccessPointTypeConfigApiConfigArgsDict(TypedDict):
        allow_over_subscription: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Setting showing that oversubscription support is available (true) or not (false). The default is false
        """
        api_available: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates if it's possible to establish connections based on the given service profile using the Equinix Fabric API.
        """
        bandwidth_from_api: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates if the connection bandwidth can be obtained directly from the cloud service provider.
        """
        equinix_managed_port: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Setting indicating that the port is managed by Equinix (true) or not (false)
        """
        equinix_managed_vlan: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Setting indicating that the VLAN is managed by Equinix (true) or not (false)
        """
        integration_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        A unique identifier issued during onboarding and used to integrate the customer's service profile with the Equinix Fabric API.
        """
        over_subscription_limit: NotRequired[pulumi.Input[_builtins.int]]
        """
        Port bandwidth multiplier that determines the total bandwidth that can be allocated to users creating connections to your services. For example, a 10 Gbps port combined with an overSubscriptionLimit parameter value of 10 allows your subscribers to create connections with a total bandwidth of 100 Gbps.
        """
elif False:
    ServiceProfileAccessPointTypeConfigApiConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceProfileAccessPointTypeConfigApiConfigArgs:
    def __init__(__self__, *,
                 allow_over_subscription: Optional[pulumi.Input[_builtins.bool]] = None,
                 api_available: Optional[pulumi.Input[_builtins.bool]] = None,
                 bandwidth_from_api: Optional[pulumi.Input[_builtins.bool]] = None,
                 equinix_managed_port: Optional[pulumi.Input[_builtins.bool]] = None,
                 equinix_managed_vlan: Optional[pulumi.Input[_builtins.bool]] = None,
                 integration_id: Optional[pulumi.Input[_builtins.str]] = None,
                 over_subscription_limit: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.bool] allow_over_subscription: Setting showing that oversubscription support is available (true) or not (false). The default is false
        :param pulumi.Input[_builtins.bool] api_available: Indicates if it's possible to establish connections based on the given service profile using the Equinix Fabric API.
        :param pulumi.Input[_builtins.bool] bandwidth_from_api: Indicates if the connection bandwidth can be obtained directly from the cloud service provider.
        :param pulumi.Input[_builtins.bool] equinix_managed_port: Setting indicating that the port is managed by Equinix (true) or not (false)
        :param pulumi.Input[_builtins.bool] equinix_managed_vlan: Setting indicating that the VLAN is managed by Equinix (true) or not (false)
        :param pulumi.Input[_builtins.str] integration_id: A unique identifier issued during onboarding and used to integrate the customer's service profile with the Equinix Fabric API.
        :param pulumi.Input[_builtins.int] over_subscription_limit: Port bandwidth multiplier that determines the total bandwidth that can be allocated to users creating connections to your services. For example, a 10 Gbps port combined with an overSubscriptionLimit parameter value of 10 allows your subscribers to create connections with a total bandwidth of 100 Gbps.
        """
        if allow_over_subscription is not None:
            pulumi.set(__self__, "allow_over_subscription", allow_over_subscription)
        if api_available is not None:
            pulumi.set(__self__, "api_available", api_available)
        if bandwidth_from_api is not None:
            pulumi.set(__self__, "bandwidth_from_api", bandwidth_from_api)
        if equinix_managed_port is not None:
            pulumi.set(__self__, "equinix_managed_port", equinix_managed_port)
        if equinix_managed_vlan is not None:
            pulumi.set(__self__, "equinix_managed_vlan", equinix_managed_vlan)
        if integration_id is not None:
            pulumi.set(__self__, "integration_id", integration_id)
        if over_subscription_limit is not None:
            pulumi.set(__self__, "over_subscription_limit", over_subscription_limit)

    @_builtins.property
    @pulumi.getter(name="allowOverSubscription")
    def allow_over_subscription(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Setting showing that oversubscription support is available (true) or not (false). The default is false
        """
        return pulumi.get(self, "allow_over_subscription")

    @allow_over_subscription.setter
    def allow_over_subscription(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_over_subscription", value)

    @_builtins.property
    @pulumi.getter(name="apiAvailable")
    def api_available(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates if it's possible to establish connections based on the given service profile using the Equinix Fabric API.
        """
        return pulumi.get(self, "api_available")

    @api_available.setter
    def api_available(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "api_available", value)

    @_builtins.property
    @pulumi.getter(name="bandwidthFromApi")
    def bandwidth_from_api(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates if the connection bandwidth can be obtained directly from the cloud service provider.
        """
        return pulumi.get(self, "bandwidth_from_api")

    @bandwidth_from_api.setter
    def bandwidth_from_api(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "bandwidth_from_api", value)

    @_builtins.property
    @pulumi.getter(name="equinixManagedPort")
    def equinix_managed_port(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Setting indicating that the port is managed by Equinix (true) or not (false)
        """
        return pulumi.get(self, "equinix_managed_port")

    @equinix_managed_port.setter
    def equinix_managed_port(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "equinix_managed_port", value)

    @_builtins.property
    @pulumi.getter(name="equinixManagedVlan")
    def equinix_managed_vlan(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Setting indicating that the VLAN is managed by Equinix (true) or not (false)
        """
        return pulumi.get(self, "equinix_managed_vlan")

    @equinix_managed_vlan.setter
    def equinix_managed_vlan(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "equinix_managed_vlan", value)

    @_builtins.property
    @pulumi.getter(name="integrationId")
    def integration_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A unique identifier issued during onboarding and used to integrate the customer's service profile with the Equinix Fabric API.
        """
        return pulumi.get(self, "integration_id")

    @integration_id.setter
    def integration_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "integration_id", value)

    @_builtins.property
    @pulumi.getter(name="overSubscriptionLimit")
    def over_subscription_limit(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Port bandwidth multiplier that determines the total bandwidth that can be allocated to users creating connections to your services. For example, a 10 Gbps port combined with an overSubscriptionLimit parameter value of 10 allows your subscribers to create connections with a total bandwidth of 100 Gbps.
        """
        return pulumi.get(self, "over_subscription_limit")

    @over_subscription_limit.setter
    def over_subscription_limit(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "over_subscription_limit", value)


if not MYPY:
    class ServiceProfileAccessPointTypeConfigAuthenticationKeyArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of authorization key
        """
        label: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the parameter that must be provided to authorize the connection.
        """
        required: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Requirement to configure an authentication key.
        """
elif False:
    ServiceProfileAccessPointTypeConfigAuthenticationKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceProfileAccessPointTypeConfigAuthenticationKeyArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 label: Optional[pulumi.Input[_builtins.str]] = None,
                 required: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] description: Description of authorization key
        :param pulumi.Input[_builtins.str] label: Name of the parameter that must be provided to authorize the connection.
        :param pulumi.Input[_builtins.bool] required: Requirement to configure an authentication key.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if required is not None:
            pulumi.set(__self__, "required", required)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of authorization key
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the parameter that must be provided to authorize the connection.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "label", value)

    @_builtins.property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Requirement to configure an authentication key.
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "required", value)


if not MYPY:
    class ServiceProfileAccessPointTypeConfigLinkProtocolConfigArgsDict(TypedDict):
        encapsulation: NotRequired[pulumi.Input[_builtins.str]]
        """
        Data frames encapsulation standard.UNTAGGED - Untagged encapsulation for EPL connections. DOT1Q - DOT1Q encapsulation standard. QINQ - QINQ encapsulation standard.
        """
        encapsulation_strategy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Additional tagging information required by the seller profile.
        """
        reuse_vlan_s_tag: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Automatically accept subsequent DOT1Q to QINQ connections that use the same authentication key. These connections will have the same VLAN S-tag assigned as the initial connection.
        """
elif False:
    ServiceProfileAccessPointTypeConfigLinkProtocolConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceProfileAccessPointTypeConfigLinkProtocolConfigArgs:
    def __init__(__self__, *,
                 encapsulation: Optional[pulumi.Input[_builtins.str]] = None,
                 encapsulation_strategy: Optional[pulumi.Input[_builtins.str]] = None,
                 reuse_vlan_s_tag: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] encapsulation: Data frames encapsulation standard.UNTAGGED - Untagged encapsulation for EPL connections. DOT1Q - DOT1Q encapsulation standard. QINQ - QINQ encapsulation standard.
        :param pulumi.Input[_builtins.str] encapsulation_strategy: Additional tagging information required by the seller profile.
        :param pulumi.Input[_builtins.bool] reuse_vlan_s_tag: Automatically accept subsequent DOT1Q to QINQ connections that use the same authentication key. These connections will have the same VLAN S-tag assigned as the initial connection.
        """
        if encapsulation is not None:
            pulumi.set(__self__, "encapsulation", encapsulation)
        if encapsulation_strategy is not None:
            pulumi.set(__self__, "encapsulation_strategy", encapsulation_strategy)
        if reuse_vlan_s_tag is not None:
            pulumi.set(__self__, "reuse_vlan_s_tag", reuse_vlan_s_tag)

    @_builtins.property
    @pulumi.getter
    def encapsulation(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Data frames encapsulation standard.UNTAGGED - Untagged encapsulation for EPL connections. DOT1Q - DOT1Q encapsulation standard. QINQ - QINQ encapsulation standard.
        """
        return pulumi.get(self, "encapsulation")

    @encapsulation.setter
    def encapsulation(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "encapsulation", value)

    @_builtins.property
    @pulumi.getter(name="encapsulationStrategy")
    def encapsulation_strategy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Additional tagging information required by the seller profile.
        """
        return pulumi.get(self, "encapsulation_strategy")

    @encapsulation_strategy.setter
    def encapsulation_strategy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "encapsulation_strategy", value)

    @_builtins.property
    @pulumi.getter(name="reuseVlanSTag")
    def reuse_vlan_s_tag(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Automatically accept subsequent DOT1Q to QINQ connections that use the same authentication key. These connections will have the same VLAN S-tag assigned as the initial connection.
        """
        return pulumi.get(self, "reuse_vlan_s_tag")

    @reuse_vlan_s_tag.setter
    def reuse_vlan_s_tag(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "reuse_vlan_s_tag", value)


if not MYPY:
    class ServiceProfileAccountArgsDict(TypedDict):
        account_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Legal name of the accountholder.
        """
        account_number: NotRequired[pulumi.Input[_builtins.int]]
        """
        Equinix-assigned account number.
        """
        global_cust_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Equinix-assigned ID of the subscriber's parent organization.
        """
        global_org_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Equinix-assigned ID of the subscriber's parent organization.
        """
        global_organization_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Equinix-assigned name of the subscriber's parent organization.
        """
        org_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        Equinix-assigned ID of the subscriber's organization.
        """
        organization_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Equinix-assigned name of the subscriber's organization.
        """
        ucm_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Enterprise datastore id
        """
elif False:
    ServiceProfileAccountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceProfileAccountArgs:
    def __init__(__self__, *,
                 account_name: Optional[pulumi.Input[_builtins.str]] = None,
                 account_number: Optional[pulumi.Input[_builtins.int]] = None,
                 global_cust_id: Optional[pulumi.Input[_builtins.str]] = None,
                 global_org_id: Optional[pulumi.Input[_builtins.str]] = None,
                 global_organization_name: Optional[pulumi.Input[_builtins.str]] = None,
                 org_id: Optional[pulumi.Input[_builtins.int]] = None,
                 organization_name: Optional[pulumi.Input[_builtins.str]] = None,
                 ucm_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] account_name: Legal name of the accountholder.
        :param pulumi.Input[_builtins.int] account_number: Equinix-assigned account number.
        :param pulumi.Input[_builtins.str] global_cust_id: Equinix-assigned ID of the subscriber's parent organization.
        :param pulumi.Input[_builtins.str] global_org_id: Equinix-assigned ID of the subscriber's parent organization.
        :param pulumi.Input[_builtins.str] global_organization_name: Equinix-assigned name of the subscriber's parent organization.
        :param pulumi.Input[_builtins.int] org_id: Equinix-assigned ID of the subscriber's organization.
        :param pulumi.Input[_builtins.str] organization_name: Equinix-assigned name of the subscriber's organization.
        :param pulumi.Input[_builtins.str] ucm_id: Enterprise datastore id
        """
        if account_name is not None:
            pulumi.set(__self__, "account_name", account_name)
        if account_number is not None:
            pulumi.set(__self__, "account_number", account_number)
        if global_cust_id is not None:
            pulumi.set(__self__, "global_cust_id", global_cust_id)
        if global_org_id is not None:
            pulumi.set(__self__, "global_org_id", global_org_id)
        if global_organization_name is not None:
            pulumi.set(__self__, "global_organization_name", global_organization_name)
        if org_id is not None:
            pulumi.set(__self__, "org_id", org_id)
        if organization_name is not None:
            pulumi.set(__self__, "organization_name", organization_name)
        if ucm_id is not None:
            pulumi.set(__self__, "ucm_id", ucm_id)

    @_builtins.property
    @pulumi.getter(name="accountName")
    def account_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Legal name of the accountholder.
        """
        return pulumi.get(self, "account_name")

    @account_name.setter
    def account_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "account_name", value)

    @_builtins.property
    @pulumi.getter(name="accountNumber")
    def account_number(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Equinix-assigned account number.
        """
        return pulumi.get(self, "account_number")

    @account_number.setter
    def account_number(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "account_number", value)

    @_builtins.property
    @pulumi.getter(name="globalCustId")
    def global_cust_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Equinix-assigned ID of the subscriber's parent organization.
        """
        return pulumi.get(self, "global_cust_id")

    @global_cust_id.setter
    def global_cust_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "global_cust_id", value)

    @_builtins.property
    @pulumi.getter(name="globalOrgId")
    def global_org_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Equinix-assigned ID of the subscriber's parent organization.
        """
        return pulumi.get(self, "global_org_id")

    @global_org_id.setter
    def global_org_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "global_org_id", value)

    @_builtins.property
    @pulumi.getter(name="globalOrganizationName")
    def global_organization_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Equinix-assigned name of the subscriber's parent organization.
        """
        return pulumi.get(self, "global_organization_name")

    @global_organization_name.setter
    def global_organization_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "global_organization_name", value)

    @_builtins.property
    @pulumi.getter(name="orgId")
    def org_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Equinix-assigned ID of the subscriber's organization.
        """
        return pulumi.get(self, "org_id")

    @org_id.setter
    def org_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "org_id", value)

    @_builtins.property
    @pulumi.getter(name="organizationName")
    def organization_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Equinix-assigned name of the subscriber's organization.
        """
        return pulumi.get(self, "organization_name")

    @organization_name.setter
    def organization_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "organization_name", value)

    @_builtins.property
    @pulumi.getter(name="ucmId")
    def ucm_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Enterprise datastore id
        """
        return pulumi.get(self, "ucm_id")

    @ucm_id.setter
    def ucm_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ucm_id", value)


if not MYPY:
    class ServiceProfileChangeLogArgsDict(TypedDict):
        created_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        Created by User Key
        """
        created_by_email: NotRequired[pulumi.Input[_builtins.str]]
        """
        Created by User Email Address
        """
        created_by_full_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Created by User Full Name
        """
        created_date_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Created by Date and Time
        """
        deleted_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        Deleted by User Key
        """
        deleted_by_email: NotRequired[pulumi.Input[_builtins.str]]
        """
        Deleted by User Email Address
        """
        deleted_by_full_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Deleted by User Full Name
        """
        deleted_date_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Deleted by Date and Time
        """
        updated_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        Updated by User Key
        """
        updated_by_email: NotRequired[pulumi.Input[_builtins.str]]
        """
        Updated by User Email Address
        """
        updated_by_full_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Updated by User Full Name
        """
        updated_date_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Updated by Date and Time
        """
elif False:
    ServiceProfileChangeLogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceProfileChangeLogArgs:
    def __init__(__self__, *,
                 created_by: Optional[pulumi.Input[_builtins.str]] = None,
                 created_by_email: Optional[pulumi.Input[_builtins.str]] = None,
                 created_by_full_name: Optional[pulumi.Input[_builtins.str]] = None,
                 created_date_time: Optional[pulumi.Input[_builtins.str]] = None,
                 deleted_by: Optional[pulumi.Input[_builtins.str]] = None,
                 deleted_by_email: Optional[pulumi.Input[_builtins.str]] = None,
                 deleted_by_full_name: Optional[pulumi.Input[_builtins.str]] = None,
                 deleted_date_time: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_by: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_by_email: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_by_full_name: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_date_time: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] created_by: Created by User Key
        :param pulumi.Input[_builtins.str] created_by_email: Created by User Email Address
        :param pulumi.Input[_builtins.str] created_by_full_name: Created by User Full Name
        :param pulumi.Input[_builtins.str] created_date_time: Created by Date and Time
        :param pulumi.Input[_builtins.str] deleted_by: Deleted by User Key
        :param pulumi.Input[_builtins.str] deleted_by_email: Deleted by User Email Address
        :param pulumi.Input[_builtins.str] deleted_by_full_name: Deleted by User Full Name
        :param pulumi.Input[_builtins.str] deleted_date_time: Deleted by Date and Time
        :param pulumi.Input[_builtins.str] updated_by: Updated by User Key
        :param pulumi.Input[_builtins.str] updated_by_email: Updated by User Email Address
        :param pulumi.Input[_builtins.str] updated_by_full_name: Updated by User Full Name
        :param pulumi.Input[_builtins.str] updated_date_time: Updated by Date and Time
        """
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if created_by_email is not None:
            pulumi.set(__self__, "created_by_email", created_by_email)
        if created_by_full_name is not None:
            pulumi.set(__self__, "created_by_full_name", created_by_full_name)
        if created_date_time is not None:
            pulumi.set(__self__, "created_date_time", created_date_time)
        if deleted_by is not None:
            pulumi.set(__self__, "deleted_by", deleted_by)
        if deleted_by_email is not None:
            pulumi.set(__self__, "deleted_by_email", deleted_by_email)
        if deleted_by_full_name is not None:
            pulumi.set(__self__, "deleted_by_full_name", deleted_by_full_name)
        if deleted_date_time is not None:
            pulumi.set(__self__, "deleted_date_time", deleted_date_time)
        if updated_by is not None:
            pulumi.set(__self__, "updated_by", updated_by)
        if updated_by_email is not None:
            pulumi.set(__self__, "updated_by_email", updated_by_email)
        if updated_by_full_name is not None:
            pulumi.set(__self__, "updated_by_full_name", updated_by_full_name)
        if updated_date_time is not None:
            pulumi.set(__self__, "updated_date_time", updated_date_time)

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Created by User Key
        """
        return pulumi.get(self, "created_by")

    @created_by.setter
    def created_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_by", value)

    @_builtins.property
    @pulumi.getter(name="createdByEmail")
    def created_by_email(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Created by User Email Address
        """
        return pulumi.get(self, "created_by_email")

    @created_by_email.setter
    def created_by_email(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_by_email", value)

    @_builtins.property
    @pulumi.getter(name="createdByFullName")
    def created_by_full_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Created by User Full Name
        """
        return pulumi.get(self, "created_by_full_name")

    @created_by_full_name.setter
    def created_by_full_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_by_full_name", value)

    @_builtins.property
    @pulumi.getter(name="createdDateTime")
    def created_date_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Created by Date and Time
        """
        return pulumi.get(self, "created_date_time")

    @created_date_time.setter
    def created_date_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_date_time", value)

    @_builtins.property
    @pulumi.getter(name="deletedBy")
    def deleted_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Deleted by User Key
        """
        return pulumi.get(self, "deleted_by")

    @deleted_by.setter
    def deleted_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deleted_by", value)

    @_builtins.property
    @pulumi.getter(name="deletedByEmail")
    def deleted_by_email(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Deleted by User Email Address
        """
        return pulumi.get(self, "deleted_by_email")

    @deleted_by_email.setter
    def deleted_by_email(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deleted_by_email", value)

    @_builtins.property
    @pulumi.getter(name="deletedByFullName")
    def deleted_by_full_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Deleted by User Full Name
        """
        return pulumi.get(self, "deleted_by_full_name")

    @deleted_by_full_name.setter
    def deleted_by_full_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deleted_by_full_name", value)

    @_builtins.property
    @pulumi.getter(name="deletedDateTime")
    def deleted_date_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Deleted by Date and Time
        """
        return pulumi.get(self, "deleted_date_time")

    @deleted_date_time.setter
    def deleted_date_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deleted_date_time", value)

    @_builtins.property
    @pulumi.getter(name="updatedBy")
    def updated_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Updated by User Key
        """
        return pulumi.get(self, "updated_by")

    @updated_by.setter
    def updated_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_by", value)

    @_builtins.property
    @pulumi.getter(name="updatedByEmail")
    def updated_by_email(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Updated by User Email Address
        """
        return pulumi.get(self, "updated_by_email")

    @updated_by_email.setter
    def updated_by_email(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_by_email", value)

    @_builtins.property
    @pulumi.getter(name="updatedByFullName")
    def updated_by_full_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Updated by User Full Name
        """
        return pulumi.get(self, "updated_by_full_name")

    @updated_by_full_name.setter
    def updated_by_full_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_by_full_name", value)

    @_builtins.property
    @pulumi.getter(name="updatedDateTime")
    def updated_date_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Updated by Date and Time
        """
        return pulumi.get(self, "updated_date_time")

    @updated_date_time.setter
    def updated_date_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_date_time", value)


if not MYPY:
    class ServiceProfileCustomFieldArgsDict(TypedDict):
        data_type: pulumi.Input[_builtins.str]
        """
        Data type
        """
        label: pulumi.Input[_builtins.str]
        """
        Label
        """
        required: pulumi.Input[_builtins.bool]
        """
        Required field
        """
        capture_in_email: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Required field
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description
        """
        options: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Options
        """
elif False:
    ServiceProfileCustomFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceProfileCustomFieldArgs:
    def __init__(__self__, *,
                 data_type: pulumi.Input[_builtins.str],
                 label: pulumi.Input[_builtins.str],
                 required: pulumi.Input[_builtins.bool],
                 capture_in_email: Optional[pulumi.Input[_builtins.bool]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 options: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] data_type: Data type
        :param pulumi.Input[_builtins.str] label: Label
        :param pulumi.Input[_builtins.bool] required: Required field
        :param pulumi.Input[_builtins.bool] capture_in_email: Required field
        :param pulumi.Input[_builtins.str] description: Description
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] options: Options
        """
        pulumi.set(__self__, "data_type", data_type)
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "required", required)
        if capture_in_email is not None:
            pulumi.set(__self__, "capture_in_email", capture_in_email)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if options is not None:
            pulumi.set(__self__, "options", options)

    @_builtins.property
    @pulumi.getter(name="dataType")
    def data_type(self) -> pulumi.Input[_builtins.str]:
        """
        Data type
        """
        return pulumi.get(self, "data_type")

    @data_type.setter
    def data_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "data_type", value)

    @_builtins.property
    @pulumi.getter
    def label(self) -> pulumi.Input[_builtins.str]:
        """
        Label
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "label", value)

    @_builtins.property
    @pulumi.getter
    def required(self) -> pulumi.Input[_builtins.bool]:
        """
        Required field
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "required", value)

    @_builtins.property
    @pulumi.getter(name="captureInEmail")
    def capture_in_email(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Required field
        """
        return pulumi.get(self, "capture_in_email")

    @capture_in_email.setter
    def capture_in_email(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "capture_in_email", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Options
        """
        return pulumi.get(self, "options")

    @options.setter
    def options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "options", value)


if not MYPY:
    class ServiceProfileMarketingInfoArgsDict(TypedDict):
        logo: NotRequired[pulumi.Input[_builtins.str]]
        """
        Logo
        """
        process_steps: NotRequired[pulumi.Input[Sequence[pulumi.Input['ServiceProfileMarketingInfoProcessStepArgsDict']]]]
        """
        Process Step
        """
        promotion: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Promotion
        """
elif False:
    ServiceProfileMarketingInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceProfileMarketingInfoArgs:
    def __init__(__self__, *,
                 logo: Optional[pulumi.Input[_builtins.str]] = None,
                 process_steps: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceProfileMarketingInfoProcessStepArgs']]]] = None,
                 promotion: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] logo: Logo
        :param pulumi.Input[Sequence[pulumi.Input['ServiceProfileMarketingInfoProcessStepArgs']]] process_steps: Process Step
        :param pulumi.Input[_builtins.bool] promotion: Promotion
        """
        if logo is not None:
            pulumi.set(__self__, "logo", logo)
        if process_steps is not None:
            pulumi.set(__self__, "process_steps", process_steps)
        if promotion is not None:
            pulumi.set(__self__, "promotion", promotion)

    @_builtins.property
    @pulumi.getter
    def logo(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Logo
        """
        return pulumi.get(self, "logo")

    @logo.setter
    def logo(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "logo", value)

    @_builtins.property
    @pulumi.getter(name="processSteps")
    def process_steps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceProfileMarketingInfoProcessStepArgs']]]]:
        """
        Process Step
        """
        return pulumi.get(self, "process_steps")

    @process_steps.setter
    def process_steps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceProfileMarketingInfoProcessStepArgs']]]]):
        pulumi.set(self, "process_steps", value)

    @_builtins.property
    @pulumi.getter
    def promotion(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Promotion
        """
        return pulumi.get(self, "promotion")

    @promotion.setter
    def promotion(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "promotion", value)


if not MYPY:
    class ServiceProfileMarketingInfoProcessStepArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description
        """
        sub_title: NotRequired[pulumi.Input[_builtins.str]]
        """
        Sub Title
        """
        title: NotRequired[pulumi.Input[_builtins.str]]
        """
        Title
        """
elif False:
    ServiceProfileMarketingInfoProcessStepArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceProfileMarketingInfoProcessStepArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 sub_title: Optional[pulumi.Input[_builtins.str]] = None,
                 title: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: Description
        :param pulumi.Input[_builtins.str] sub_title: Sub Title
        :param pulumi.Input[_builtins.str] title: Title
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if sub_title is not None:
            pulumi.set(__self__, "sub_title", sub_title)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="subTitle")
    def sub_title(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Sub Title
        """
        return pulumi.get(self, "sub_title")

    @sub_title.setter
    def sub_title(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sub_title", value)

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Title
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "title", value)


if not MYPY:
    class ServiceProfileMetroArgsDict(TypedDict):
        code: NotRequired[pulumi.Input[_builtins.str]]
        """
        Metro Code - Example SV
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Display Name
        """
        ibxs: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        IBX- Equinix International Business Exchange list
        """
        in_trail: NotRequired[pulumi.Input[_builtins.bool]]
        """
        In Trail
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Metro Name
        """
        seller_regions: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Seller Regions
        """
elif False:
    ServiceProfileMetroArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceProfileMetroArgs:
    def __init__(__self__, *,
                 code: Optional[pulumi.Input[_builtins.str]] = None,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 ibxs: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 in_trail: Optional[pulumi.Input[_builtins.bool]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 seller_regions: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] code: Metro Code - Example SV
        :param pulumi.Input[_builtins.str] display_name: Display Name
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ibxs: IBX- Equinix International Business Exchange list
        :param pulumi.Input[_builtins.bool] in_trail: In Trail
        :param pulumi.Input[_builtins.str] name: Metro Name
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] seller_regions: Seller Regions
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if ibxs is not None:
            pulumi.set(__self__, "ibxs", ibxs)
        if in_trail is not None:
            pulumi.set(__self__, "in_trail", in_trail)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if seller_regions is not None:
            pulumi.set(__self__, "seller_regions", seller_regions)

    @_builtins.property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Metro Code - Example SV
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "code", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Display Name
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter
    def ibxs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        IBX- Equinix International Business Exchange list
        """
        return pulumi.get(self, "ibxs")

    @ibxs.setter
    def ibxs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ibxs", value)

    @_builtins.property
    @pulumi.getter(name="inTrail")
    def in_trail(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        In Trail
        """
        return pulumi.get(self, "in_trail")

    @in_trail.setter
    def in_trail(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "in_trail", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Metro Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="sellerRegions")
    def seller_regions(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Seller Regions
        """
        return pulumi.get(self, "seller_regions")

    @seller_regions.setter
    def seller_regions(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "seller_regions", value)


if not MYPY:
    class ServiceProfileNotificationArgsDict(TypedDict):
        emails: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Array of contact emails
        """
        type: pulumi.Input[Union[_builtins.str, 'NotificationsType']]
        """
        Notification Type - ALL,CONNECTION*APPROVAL,SALES*REP_NOTIFICATIONS, NOTIFICATIONS
        """
        send_interval: NotRequired[pulumi.Input[_builtins.str]]
        """
        Send interval
        """
elif False:
    ServiceProfileNotificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceProfileNotificationArgs:
    def __init__(__self__, *,
                 emails: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 type: pulumi.Input[Union[_builtins.str, 'NotificationsType']],
                 send_interval: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] emails: Array of contact emails
        :param pulumi.Input[Union[_builtins.str, 'NotificationsType']] type: Notification Type - ALL,CONNECTION*APPROVAL,SALES*REP_NOTIFICATIONS, NOTIFICATIONS
        :param pulumi.Input[_builtins.str] send_interval: Send interval
        """
        pulumi.set(__self__, "emails", emails)
        pulumi.set(__self__, "type", type)
        if send_interval is not None:
            pulumi.set(__self__, "send_interval", send_interval)

    @_builtins.property
    @pulumi.getter
    def emails(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Array of contact emails
        """
        return pulumi.get(self, "emails")

    @emails.setter
    def emails(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "emails", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[Union[_builtins.str, 'NotificationsType']]:
        """
        Notification Type - ALL,CONNECTION*APPROVAL,SALES*REP_NOTIFICATIONS, NOTIFICATIONS
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[Union[_builtins.str, 'NotificationsType']]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="sendInterval")
    def send_interval(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Send interval
        """
        return pulumi.get(self, "send_interval")

    @send_interval.setter
    def send_interval(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "send_interval", value)


if not MYPY:
    class ServiceProfilePortArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Colo/Port Type
        """
        uuid: pulumi.Input[_builtins.str]
        """
        Colo/Port Uuid
        """
        cross_connect_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Cross Connect Id
        """
        location: NotRequired[pulumi.Input['ServiceProfilePortLocationArgsDict']]
        """
        Colo/Port Location
        """
        seller_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Seller Region
        """
        seller_region_description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Seller Region details
        """
elif False:
    ServiceProfilePortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceProfilePortArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 uuid: pulumi.Input[_builtins.str],
                 cross_connect_id: Optional[pulumi.Input[_builtins.str]] = None,
                 location: Optional[pulumi.Input['ServiceProfilePortLocationArgs']] = None,
                 seller_region: Optional[pulumi.Input[_builtins.str]] = None,
                 seller_region_description: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Colo/Port Type
        :param pulumi.Input[_builtins.str] uuid: Colo/Port Uuid
        :param pulumi.Input[_builtins.str] cross_connect_id: Cross Connect Id
        :param pulumi.Input['ServiceProfilePortLocationArgs'] location: Colo/Port Location
        :param pulumi.Input[_builtins.str] seller_region: Seller Region
        :param pulumi.Input[_builtins.str] seller_region_description: Seller Region details
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "uuid", uuid)
        if cross_connect_id is not None:
            pulumi.set(__self__, "cross_connect_id", cross_connect_id)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if seller_region is not None:
            pulumi.set(__self__, "seller_region", seller_region)
        if seller_region_description is not None:
            pulumi.set(__self__, "seller_region_description", seller_region_description)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Colo/Port Type
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> pulumi.Input[_builtins.str]:
        """
        Colo/Port Uuid
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "uuid", value)

    @_builtins.property
    @pulumi.getter(name="crossConnectId")
    def cross_connect_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Cross Connect Id
        """
        return pulumi.get(self, "cross_connect_id")

    @cross_connect_id.setter
    def cross_connect_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cross_connect_id", value)

    @_builtins.property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input['ServiceProfilePortLocationArgs']]:
        """
        Colo/Port Location
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input['ServiceProfilePortLocationArgs']]):
        pulumi.set(self, "location", value)

    @_builtins.property
    @pulumi.getter(name="sellerRegion")
    def seller_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Seller Region
        """
        return pulumi.get(self, "seller_region")

    @seller_region.setter
    def seller_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "seller_region", value)

    @_builtins.property
    @pulumi.getter(name="sellerRegionDescription")
    def seller_region_description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Seller Region details
        """
        return pulumi.get(self, "seller_region_description")

    @seller_region_description.setter
    def seller_region_description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "seller_region_description", value)


if not MYPY:
    class ServiceProfilePortLocationArgsDict(TypedDict):
        ibx: NotRequired[pulumi.Input[_builtins.str]]
        """
        IBX Code
        """
        metro_code: NotRequired[pulumi.Input[_builtins.str]]
        """
        Access point metro code
        """
        metro_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Access point metro name
        """
        region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Access point region
        """
elif False:
    ServiceProfilePortLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceProfilePortLocationArgs:
    def __init__(__self__, *,
                 ibx: Optional[pulumi.Input[_builtins.str]] = None,
                 metro_code: Optional[pulumi.Input[_builtins.str]] = None,
                 metro_name: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ibx: IBX Code
        :param pulumi.Input[_builtins.str] metro_code: Access point metro code
        :param pulumi.Input[_builtins.str] metro_name: Access point metro name
        :param pulumi.Input[_builtins.str] region: Access point region
        """
        if ibx is not None:
            pulumi.set(__self__, "ibx", ibx)
        if metro_code is not None:
            pulumi.set(__self__, "metro_code", metro_code)
        if metro_name is not None:
            pulumi.set(__self__, "metro_name", metro_name)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def ibx(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IBX Code
        """
        return pulumi.get(self, "ibx")

    @ibx.setter
    def ibx(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ibx", value)

    @_builtins.property
    @pulumi.getter(name="metroCode")
    def metro_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Access point metro code
        """
        return pulumi.get(self, "metro_code")

    @metro_code.setter
    def metro_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metro_code", value)

    @_builtins.property
    @pulumi.getter(name="metroName")
    def metro_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Access point metro name
        """
        return pulumi.get(self, "metro_name")

    @metro_name.setter
    def metro_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metro_name", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Access point region
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)


if not MYPY:
    class ServiceProfileProjectArgsDict(TypedDict):
        href: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unique Resource URL
        """
        project_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Project Id
        """
elif False:
    ServiceProfileProjectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceProfileProjectArgs:
    def __init__(__self__, *,
                 href: Optional[pulumi.Input[_builtins.str]] = None,
                 project_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] href: Unique Resource URL
        :param pulumi.Input[_builtins.str] project_id: Project Id
        """
        if href is not None:
            pulumi.set(__self__, "href", href)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)

    @_builtins.property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unique Resource URL
        """
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "href", value)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Project Id
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "project_id", value)


if not MYPY:
    class ServiceProfileVirtualDeviceArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Virtual Device Type
        """
        uuid: pulumi.Input[_builtins.str]
        """
        Virtual Device Uuid
        """
        interface_uuid: NotRequired[pulumi.Input[_builtins.str]]
        """
        Device Interface Uuid
        """
        location: NotRequired[pulumi.Input['ServiceProfileVirtualDeviceLocationArgsDict']]
        """
        Device Location
        """
elif False:
    ServiceProfileVirtualDeviceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceProfileVirtualDeviceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 uuid: pulumi.Input[_builtins.str],
                 interface_uuid: Optional[pulumi.Input[_builtins.str]] = None,
                 location: Optional[pulumi.Input['ServiceProfileVirtualDeviceLocationArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] type: Virtual Device Type
        :param pulumi.Input[_builtins.str] uuid: Virtual Device Uuid
        :param pulumi.Input[_builtins.str] interface_uuid: Device Interface Uuid
        :param pulumi.Input['ServiceProfileVirtualDeviceLocationArgs'] location: Device Location
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "uuid", uuid)
        if interface_uuid is not None:
            pulumi.set(__self__, "interface_uuid", interface_uuid)
        if location is not None:
            pulumi.set(__self__, "location", location)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Virtual Device Type
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> pulumi.Input[_builtins.str]:
        """
        Virtual Device Uuid
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "uuid", value)

    @_builtins.property
    @pulumi.getter(name="interfaceUuid")
    def interface_uuid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Device Interface Uuid
        """
        return pulumi.get(self, "interface_uuid")

    @interface_uuid.setter
    def interface_uuid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "interface_uuid", value)

    @_builtins.property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input['ServiceProfileVirtualDeviceLocationArgs']]:
        """
        Device Location
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input['ServiceProfileVirtualDeviceLocationArgs']]):
        pulumi.set(self, "location", value)


if not MYPY:
    class ServiceProfileVirtualDeviceLocationArgsDict(TypedDict):
        ibx: NotRequired[pulumi.Input[_builtins.str]]
        """
        IBX Code
        """
        metro_code: NotRequired[pulumi.Input[_builtins.str]]
        """
        Access point metro code
        """
        metro_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Access point metro name
        """
        region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Access point region
        """
elif False:
    ServiceProfileVirtualDeviceLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceProfileVirtualDeviceLocationArgs:
    def __init__(__self__, *,
                 ibx: Optional[pulumi.Input[_builtins.str]] = None,
                 metro_code: Optional[pulumi.Input[_builtins.str]] = None,
                 metro_name: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ibx: IBX Code
        :param pulumi.Input[_builtins.str] metro_code: Access point metro code
        :param pulumi.Input[_builtins.str] metro_name: Access point metro name
        :param pulumi.Input[_builtins.str] region: Access point region
        """
        if ibx is not None:
            pulumi.set(__self__, "ibx", ibx)
        if metro_code is not None:
            pulumi.set(__self__, "metro_code", metro_code)
        if metro_name is not None:
            pulumi.set(__self__, "metro_name", metro_name)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def ibx(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IBX Code
        """
        return pulumi.get(self, "ibx")

    @ibx.setter
    def ibx(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ibx", value)

    @_builtins.property
    @pulumi.getter(name="metroCode")
    def metro_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Access point metro code
        """
        return pulumi.get(self, "metro_code")

    @metro_code.setter
    def metro_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metro_code", value)

    @_builtins.property
    @pulumi.getter(name="metroName")
    def metro_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Access point metro name
        """
        return pulumi.get(self, "metro_name")

    @metro_name.setter
    def metro_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metro_name", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Access point region
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)


if not MYPY:
    class ServiceTokenAccountArgsDict(TypedDict):
        account_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Legal name of the accountholder.
        """
        account_number: NotRequired[pulumi.Input[_builtins.int]]
        """
        Equinix-assigned account number.
        """
        global_cust_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Equinix-assigned ID of the subscriber's parent organization.
        """
        global_org_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Equinix-assigned ID of the subscriber's parent organization.
        """
        global_organization_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Equinix-assigned name of the subscriber's parent organization.
        """
        org_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        Equinix-assigned ID of the subscriber's organization.
        """
        organization_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Equinix-assigned name of the subscriber's organization.
        """
        ucm_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Enterprise datastore id
        """
elif False:
    ServiceTokenAccountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceTokenAccountArgs:
    def __init__(__self__, *,
                 account_name: Optional[pulumi.Input[_builtins.str]] = None,
                 account_number: Optional[pulumi.Input[_builtins.int]] = None,
                 global_cust_id: Optional[pulumi.Input[_builtins.str]] = None,
                 global_org_id: Optional[pulumi.Input[_builtins.str]] = None,
                 global_organization_name: Optional[pulumi.Input[_builtins.str]] = None,
                 org_id: Optional[pulumi.Input[_builtins.int]] = None,
                 organization_name: Optional[pulumi.Input[_builtins.str]] = None,
                 ucm_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] account_name: Legal name of the accountholder.
        :param pulumi.Input[_builtins.int] account_number: Equinix-assigned account number.
        :param pulumi.Input[_builtins.str] global_cust_id: Equinix-assigned ID of the subscriber's parent organization.
        :param pulumi.Input[_builtins.str] global_org_id: Equinix-assigned ID of the subscriber's parent organization.
        :param pulumi.Input[_builtins.str] global_organization_name: Equinix-assigned name of the subscriber's parent organization.
        :param pulumi.Input[_builtins.int] org_id: Equinix-assigned ID of the subscriber's organization.
        :param pulumi.Input[_builtins.str] organization_name: Equinix-assigned name of the subscriber's organization.
        :param pulumi.Input[_builtins.str] ucm_id: Enterprise datastore id
        """
        if account_name is not None:
            pulumi.set(__self__, "account_name", account_name)
        if account_number is not None:
            pulumi.set(__self__, "account_number", account_number)
        if global_cust_id is not None:
            pulumi.set(__self__, "global_cust_id", global_cust_id)
        if global_org_id is not None:
            pulumi.set(__self__, "global_org_id", global_org_id)
        if global_organization_name is not None:
            pulumi.set(__self__, "global_organization_name", global_organization_name)
        if org_id is not None:
            pulumi.set(__self__, "org_id", org_id)
        if organization_name is not None:
            pulumi.set(__self__, "organization_name", organization_name)
        if ucm_id is not None:
            pulumi.set(__self__, "ucm_id", ucm_id)

    @_builtins.property
    @pulumi.getter(name="accountName")
    def account_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Legal name of the accountholder.
        """
        return pulumi.get(self, "account_name")

    @account_name.setter
    def account_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "account_name", value)

    @_builtins.property
    @pulumi.getter(name="accountNumber")
    def account_number(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Equinix-assigned account number.
        """
        return pulumi.get(self, "account_number")

    @account_number.setter
    def account_number(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "account_number", value)

    @_builtins.property
    @pulumi.getter(name="globalCustId")
    def global_cust_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Equinix-assigned ID of the subscriber's parent organization.
        """
        return pulumi.get(self, "global_cust_id")

    @global_cust_id.setter
    def global_cust_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "global_cust_id", value)

    @_builtins.property
    @pulumi.getter(name="globalOrgId")
    def global_org_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Equinix-assigned ID of the subscriber's parent organization.
        """
        return pulumi.get(self, "global_org_id")

    @global_org_id.setter
    def global_org_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "global_org_id", value)

    @_builtins.property
    @pulumi.getter(name="globalOrganizationName")
    def global_organization_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Equinix-assigned name of the subscriber's parent organization.
        """
        return pulumi.get(self, "global_organization_name")

    @global_organization_name.setter
    def global_organization_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "global_organization_name", value)

    @_builtins.property
    @pulumi.getter(name="orgId")
    def org_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Equinix-assigned ID of the subscriber's organization.
        """
        return pulumi.get(self, "org_id")

    @org_id.setter
    def org_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "org_id", value)

    @_builtins.property
    @pulumi.getter(name="organizationName")
    def organization_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Equinix-assigned name of the subscriber's organization.
        """
        return pulumi.get(self, "organization_name")

    @organization_name.setter
    def organization_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "organization_name", value)

    @_builtins.property
    @pulumi.getter(name="ucmId")
    def ucm_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Enterprise datastore id
        """
        return pulumi.get(self, "ucm_id")

    @ucm_id.setter
    def ucm_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ucm_id", value)


if not MYPY:
    class ServiceTokenChangeLogArgsDict(TypedDict):
        created_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        Created by User Key
        """
        created_by_email: NotRequired[pulumi.Input[_builtins.str]]
        """
        Created by User Email Address
        """
        created_by_full_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Created by User Full Name
        """
        created_date_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Created by Date and Time
        """
        deleted_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        Deleted by User Key
        """
        deleted_by_email: NotRequired[pulumi.Input[_builtins.str]]
        """
        Deleted by User Email Address
        """
        deleted_by_full_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Deleted by User Full Name
        """
        deleted_date_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Deleted by Date and Time
        """
        updated_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        Updated by User Key
        """
        updated_by_email: NotRequired[pulumi.Input[_builtins.str]]
        """
        Updated by User Email Address
        """
        updated_by_full_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Updated by User Full Name
        """
        updated_date_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Updated by Date and Time
        """
elif False:
    ServiceTokenChangeLogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceTokenChangeLogArgs:
    def __init__(__self__, *,
                 created_by: Optional[pulumi.Input[_builtins.str]] = None,
                 created_by_email: Optional[pulumi.Input[_builtins.str]] = None,
                 created_by_full_name: Optional[pulumi.Input[_builtins.str]] = None,
                 created_date_time: Optional[pulumi.Input[_builtins.str]] = None,
                 deleted_by: Optional[pulumi.Input[_builtins.str]] = None,
                 deleted_by_email: Optional[pulumi.Input[_builtins.str]] = None,
                 deleted_by_full_name: Optional[pulumi.Input[_builtins.str]] = None,
                 deleted_date_time: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_by: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_by_email: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_by_full_name: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_date_time: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] created_by: Created by User Key
        :param pulumi.Input[_builtins.str] created_by_email: Created by User Email Address
        :param pulumi.Input[_builtins.str] created_by_full_name: Created by User Full Name
        :param pulumi.Input[_builtins.str] created_date_time: Created by Date and Time
        :param pulumi.Input[_builtins.str] deleted_by: Deleted by User Key
        :param pulumi.Input[_builtins.str] deleted_by_email: Deleted by User Email Address
        :param pulumi.Input[_builtins.str] deleted_by_full_name: Deleted by User Full Name
        :param pulumi.Input[_builtins.str] deleted_date_time: Deleted by Date and Time
        :param pulumi.Input[_builtins.str] updated_by: Updated by User Key
        :param pulumi.Input[_builtins.str] updated_by_email: Updated by User Email Address
        :param pulumi.Input[_builtins.str] updated_by_full_name: Updated by User Full Name
        :param pulumi.Input[_builtins.str] updated_date_time: Updated by Date and Time
        """
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if created_by_email is not None:
            pulumi.set(__self__, "created_by_email", created_by_email)
        if created_by_full_name is not None:
            pulumi.set(__self__, "created_by_full_name", created_by_full_name)
        if created_date_time is not None:
            pulumi.set(__self__, "created_date_time", created_date_time)
        if deleted_by is not None:
            pulumi.set(__self__, "deleted_by", deleted_by)
        if deleted_by_email is not None:
            pulumi.set(__self__, "deleted_by_email", deleted_by_email)
        if deleted_by_full_name is not None:
            pulumi.set(__self__, "deleted_by_full_name", deleted_by_full_name)
        if deleted_date_time is not None:
            pulumi.set(__self__, "deleted_date_time", deleted_date_time)
        if updated_by is not None:
            pulumi.set(__self__, "updated_by", updated_by)
        if updated_by_email is not None:
            pulumi.set(__self__, "updated_by_email", updated_by_email)
        if updated_by_full_name is not None:
            pulumi.set(__self__, "updated_by_full_name", updated_by_full_name)
        if updated_date_time is not None:
            pulumi.set(__self__, "updated_date_time", updated_date_time)

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Created by User Key
        """
        return pulumi.get(self, "created_by")

    @created_by.setter
    def created_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_by", value)

    @_builtins.property
    @pulumi.getter(name="createdByEmail")
    def created_by_email(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Created by User Email Address
        """
        return pulumi.get(self, "created_by_email")

    @created_by_email.setter
    def created_by_email(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_by_email", value)

    @_builtins.property
    @pulumi.getter(name="createdByFullName")
    def created_by_full_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Created by User Full Name
        """
        return pulumi.get(self, "created_by_full_name")

    @created_by_full_name.setter
    def created_by_full_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_by_full_name", value)

    @_builtins.property
    @pulumi.getter(name="createdDateTime")
    def created_date_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Created by Date and Time
        """
        return pulumi.get(self, "created_date_time")

    @created_date_time.setter
    def created_date_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_date_time", value)

    @_builtins.property
    @pulumi.getter(name="deletedBy")
    def deleted_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Deleted by User Key
        """
        return pulumi.get(self, "deleted_by")

    @deleted_by.setter
    def deleted_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deleted_by", value)

    @_builtins.property
    @pulumi.getter(name="deletedByEmail")
    def deleted_by_email(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Deleted by User Email Address
        """
        return pulumi.get(self, "deleted_by_email")

    @deleted_by_email.setter
    def deleted_by_email(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deleted_by_email", value)

    @_builtins.property
    @pulumi.getter(name="deletedByFullName")
    def deleted_by_full_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Deleted by User Full Name
        """
        return pulumi.get(self, "deleted_by_full_name")

    @deleted_by_full_name.setter
    def deleted_by_full_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deleted_by_full_name", value)

    @_builtins.property
    @pulumi.getter(name="deletedDateTime")
    def deleted_date_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Deleted by Date and Time
        """
        return pulumi.get(self, "deleted_date_time")

    @deleted_date_time.setter
    def deleted_date_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deleted_date_time", value)

    @_builtins.property
    @pulumi.getter(name="updatedBy")
    def updated_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Updated by User Key
        """
        return pulumi.get(self, "updated_by")

    @updated_by.setter
    def updated_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_by", value)

    @_builtins.property
    @pulumi.getter(name="updatedByEmail")
    def updated_by_email(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Updated by User Email Address
        """
        return pulumi.get(self, "updated_by_email")

    @updated_by_email.setter
    def updated_by_email(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_by_email", value)

    @_builtins.property
    @pulumi.getter(name="updatedByFullName")
    def updated_by_full_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Updated by User Full Name
        """
        return pulumi.get(self, "updated_by_full_name")

    @updated_by_full_name.setter
    def updated_by_full_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_by_full_name", value)

    @_builtins.property
    @pulumi.getter(name="updatedDateTime")
    def updated_date_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Updated by Date and Time
        """
        return pulumi.get(self, "updated_date_time")

    @updated_date_time.setter
    def updated_date_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_date_time", value)


if not MYPY:
    class ServiceTokenNotificationArgsDict(TypedDict):
        emails: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Array of contact emails
        """
        type: pulumi.Input[_builtins.str]
        """
        Notification Type - ALL,CONNECTION*APPROVAL,SALES*REP_NOTIFICATIONS, NOTIFICATIONS
        """
        send_interval: NotRequired[pulumi.Input[_builtins.str]]
        """
        Send interval
        """
elif False:
    ServiceTokenNotificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceTokenNotificationArgs:
    def __init__(__self__, *,
                 emails: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 type: pulumi.Input[_builtins.str],
                 send_interval: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] emails: Array of contact emails
        :param pulumi.Input[_builtins.str] type: Notification Type - ALL,CONNECTION*APPROVAL,SALES*REP_NOTIFICATIONS, NOTIFICATIONS
        :param pulumi.Input[_builtins.str] send_interval: Send interval
        """
        pulumi.set(__self__, "emails", emails)
        pulumi.set(__self__, "type", type)
        if send_interval is not None:
            pulumi.set(__self__, "send_interval", send_interval)

    @_builtins.property
    @pulumi.getter
    def emails(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Array of contact emails
        """
        return pulumi.get(self, "emails")

    @emails.setter
    def emails(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "emails", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Notification Type - ALL,CONNECTION*APPROVAL,SALES*REP_NOTIFICATIONS, NOTIFICATIONS
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="sendInterval")
    def send_interval(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Send interval
        """
        return pulumi.get(self, "send_interval")

    @send_interval.setter
    def send_interval(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "send_interval", value)


if not MYPY:
    class ServiceTokenProjectArgsDict(TypedDict):
        href: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unique Resource URL
        """
        project_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Project Id
        """
elif False:
    ServiceTokenProjectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceTokenProjectArgs:
    def __init__(__self__, *,
                 href: Optional[pulumi.Input[_builtins.str]] = None,
                 project_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] href: Unique Resource URL
        :param pulumi.Input[_builtins.str] project_id: Project Id
        """
        if href is not None:
            pulumi.set(__self__, "href", href)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)

    @_builtins.property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unique Resource URL
        """
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "href", value)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Project Id
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "project_id", value)


if not MYPY:
    class ServiceTokenServiceTokenConnectionArgsDict(TypedDict):
        a_sides: NotRequired[pulumi.Input[Sequence[pulumi.Input['ServiceTokenServiceTokenConnectionASideArgsDict']]]]
        """
        A-Side Connection link protocol,virtual device or network configuration
        """
        allow_custom_bandwidth: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Allow custom bandwidth value
        """
        allow_remote_connection: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Authorization to connect remotely
        """
        bandwidth_limit: NotRequired[pulumi.Input[_builtins.int]]
        """
        Connection bandwidth limit in Mbps
        """
        supported_bandwidths: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        List of permitted bandwidths'; For Port-based Service Tokens, the maximum allowable bandwidth is 50 Gbps, while for Virtual Device-based Service Tokens, it is limited to 10 Gbps
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type of Connection supported by Service Token you will create; EVPL*VC, EVPLAN*VC, EPLAN*VC, IPWAN*VC
        """
        uuid: NotRequired[pulumi.Input[_builtins.str]]
        """
        Equinix-assigned connection identifier
        """
        z_sides: NotRequired[pulumi.Input[Sequence[pulumi.Input['ServiceTokenServiceTokenConnectionZSideArgsDict']]]]
        """
        Z-Side Connection link protocol,virtual device or network configuration
        """
elif False:
    ServiceTokenServiceTokenConnectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceTokenServiceTokenConnectionArgs:
    def __init__(__self__, *,
                 a_sides: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceTokenServiceTokenConnectionASideArgs']]]] = None,
                 allow_custom_bandwidth: Optional[pulumi.Input[_builtins.bool]] = None,
                 allow_remote_connection: Optional[pulumi.Input[_builtins.bool]] = None,
                 bandwidth_limit: Optional[pulumi.Input[_builtins.int]] = None,
                 supported_bandwidths: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 uuid: Optional[pulumi.Input[_builtins.str]] = None,
                 z_sides: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceTokenServiceTokenConnectionZSideArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ServiceTokenServiceTokenConnectionASideArgs']]] a_sides: A-Side Connection link protocol,virtual device or network configuration
        :param pulumi.Input[_builtins.bool] allow_custom_bandwidth: Allow custom bandwidth value
        :param pulumi.Input[_builtins.bool] allow_remote_connection: Authorization to connect remotely
        :param pulumi.Input[_builtins.int] bandwidth_limit: Connection bandwidth limit in Mbps
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] supported_bandwidths: List of permitted bandwidths'; For Port-based Service Tokens, the maximum allowable bandwidth is 50 Gbps, while for Virtual Device-based Service Tokens, it is limited to 10 Gbps
        :param pulumi.Input[_builtins.str] type: Type of Connection supported by Service Token you will create; EVPL*VC, EVPLAN*VC, EPLAN*VC, IPWAN*VC
        :param pulumi.Input[_builtins.str] uuid: Equinix-assigned connection identifier
        :param pulumi.Input[Sequence[pulumi.Input['ServiceTokenServiceTokenConnectionZSideArgs']]] z_sides: Z-Side Connection link protocol,virtual device or network configuration
        """
        if a_sides is not None:
            pulumi.set(__self__, "a_sides", a_sides)
        if allow_custom_bandwidth is not None:
            pulumi.set(__self__, "allow_custom_bandwidth", allow_custom_bandwidth)
        if allow_remote_connection is not None:
            pulumi.set(__self__, "allow_remote_connection", allow_remote_connection)
        if bandwidth_limit is not None:
            pulumi.set(__self__, "bandwidth_limit", bandwidth_limit)
        if supported_bandwidths is not None:
            pulumi.set(__self__, "supported_bandwidths", supported_bandwidths)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)
        if z_sides is not None:
            pulumi.set(__self__, "z_sides", z_sides)

    @_builtins.property
    @pulumi.getter(name="aSides")
    def a_sides(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceTokenServiceTokenConnectionASideArgs']]]]:
        """
        A-Side Connection link protocol,virtual device or network configuration
        """
        return pulumi.get(self, "a_sides")

    @a_sides.setter
    def a_sides(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceTokenServiceTokenConnectionASideArgs']]]]):
        pulumi.set(self, "a_sides", value)

    @_builtins.property
    @pulumi.getter(name="allowCustomBandwidth")
    def allow_custom_bandwidth(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Allow custom bandwidth value
        """
        return pulumi.get(self, "allow_custom_bandwidth")

    @allow_custom_bandwidth.setter
    def allow_custom_bandwidth(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_custom_bandwidth", value)

    @_builtins.property
    @pulumi.getter(name="allowRemoteConnection")
    def allow_remote_connection(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Authorization to connect remotely
        """
        return pulumi.get(self, "allow_remote_connection")

    @allow_remote_connection.setter
    def allow_remote_connection(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_remote_connection", value)

    @_builtins.property
    @pulumi.getter(name="bandwidthLimit")
    def bandwidth_limit(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Connection bandwidth limit in Mbps
        """
        return pulumi.get(self, "bandwidth_limit")

    @bandwidth_limit.setter
    def bandwidth_limit(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "bandwidth_limit", value)

    @_builtins.property
    @pulumi.getter(name="supportedBandwidths")
    def supported_bandwidths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        List of permitted bandwidths'; For Port-based Service Tokens, the maximum allowable bandwidth is 50 Gbps, while for Virtual Device-based Service Tokens, it is limited to 10 Gbps
        """
        return pulumi.get(self, "supported_bandwidths")

    @supported_bandwidths.setter
    def supported_bandwidths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "supported_bandwidths", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type of Connection supported by Service Token you will create; EVPL*VC, EVPLAN*VC, EPLAN*VC, IPWAN*VC
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Equinix-assigned connection identifier
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uuid", value)

    @_builtins.property
    @pulumi.getter(name="zSides")
    def z_sides(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceTokenServiceTokenConnectionZSideArgs']]]]:
        """
        Z-Side Connection link protocol,virtual device or network configuration
        """
        return pulumi.get(self, "z_sides")

    @z_sides.setter
    def z_sides(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceTokenServiceTokenConnectionZSideArgs']]]]):
        pulumi.set(self, "z_sides", value)


if not MYPY:
    class ServiceTokenServiceTokenConnectionASideArgsDict(TypedDict):
        access_point_selectors: pulumi.Input[Sequence[pulumi.Input['ServiceTokenServiceTokenConnectionASideAccessPointSelectorArgsDict']]]
        """
        List of criteria for selecting network access points with optimal efficiency, security, compatibility, and availability
        """
elif False:
    ServiceTokenServiceTokenConnectionASideArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceTokenServiceTokenConnectionASideArgs:
    def __init__(__self__, *,
                 access_point_selectors: pulumi.Input[Sequence[pulumi.Input['ServiceTokenServiceTokenConnectionASideAccessPointSelectorArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ServiceTokenServiceTokenConnectionASideAccessPointSelectorArgs']]] access_point_selectors: List of criteria for selecting network access points with optimal efficiency, security, compatibility, and availability
        """
        pulumi.set(__self__, "access_point_selectors", access_point_selectors)

    @_builtins.property
    @pulumi.getter(name="accessPointSelectors")
    def access_point_selectors(self) -> pulumi.Input[Sequence[pulumi.Input['ServiceTokenServiceTokenConnectionASideAccessPointSelectorArgs']]]:
        """
        List of criteria for selecting network access points with optimal efficiency, security, compatibility, and availability
        """
        return pulumi.get(self, "access_point_selectors")

    @access_point_selectors.setter
    def access_point_selectors(self, value: pulumi.Input[Sequence[pulumi.Input['ServiceTokenServiceTokenConnectionASideAccessPointSelectorArgs']]]):
        pulumi.set(self, "access_point_selectors", value)


if not MYPY:
    class ServiceTokenServiceTokenConnectionASideAccessPointSelectorArgsDict(TypedDict):
        interface: NotRequired[pulumi.Input['ServiceTokenServiceTokenConnectionASideAccessPointSelectorInterfaceArgsDict']]
        """
        Virtual Device Interface Configuration
        """
        link_protocol: NotRequired[pulumi.Input['ServiceTokenServiceTokenConnectionASideAccessPointSelectorLinkProtocolArgsDict']]
        """
        Link protocol Configuration
        """
        network: NotRequired[pulumi.Input['ServiceTokenServiceTokenConnectionASideAccessPointSelectorNetworkArgsDict']]
        """
        Network Configuration
        """
        port: NotRequired[pulumi.Input['ServiceTokenServiceTokenConnectionASideAccessPointSelectorPortArgsDict']]
        """
        Port Configuration
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type of Access point; COLO, VD, NETWORK
        """
        virtual_device: NotRequired[pulumi.Input['ServiceTokenServiceTokenConnectionASideAccessPointSelectorVirtualDeviceArgsDict']]
        """
        Virtual Device Configuration
        """
elif False:
    ServiceTokenServiceTokenConnectionASideAccessPointSelectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceTokenServiceTokenConnectionASideAccessPointSelectorArgs:
    def __init__(__self__, *,
                 interface: Optional[pulumi.Input['ServiceTokenServiceTokenConnectionASideAccessPointSelectorInterfaceArgs']] = None,
                 link_protocol: Optional[pulumi.Input['ServiceTokenServiceTokenConnectionASideAccessPointSelectorLinkProtocolArgs']] = None,
                 network: Optional[pulumi.Input['ServiceTokenServiceTokenConnectionASideAccessPointSelectorNetworkArgs']] = None,
                 port: Optional[pulumi.Input['ServiceTokenServiceTokenConnectionASideAccessPointSelectorPortArgs']] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 virtual_device: Optional[pulumi.Input['ServiceTokenServiceTokenConnectionASideAccessPointSelectorVirtualDeviceArgs']] = None):
        """
        :param pulumi.Input['ServiceTokenServiceTokenConnectionASideAccessPointSelectorInterfaceArgs'] interface: Virtual Device Interface Configuration
        :param pulumi.Input['ServiceTokenServiceTokenConnectionASideAccessPointSelectorLinkProtocolArgs'] link_protocol: Link protocol Configuration
        :param pulumi.Input['ServiceTokenServiceTokenConnectionASideAccessPointSelectorNetworkArgs'] network: Network Configuration
        :param pulumi.Input['ServiceTokenServiceTokenConnectionASideAccessPointSelectorPortArgs'] port: Port Configuration
        :param pulumi.Input[_builtins.str] type: Type of Access point; COLO, VD, NETWORK
        :param pulumi.Input['ServiceTokenServiceTokenConnectionASideAccessPointSelectorVirtualDeviceArgs'] virtual_device: Virtual Device Configuration
        """
        if interface is not None:
            pulumi.set(__self__, "interface", interface)
        if link_protocol is not None:
            pulumi.set(__self__, "link_protocol", link_protocol)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if virtual_device is not None:
            pulumi.set(__self__, "virtual_device", virtual_device)

    @_builtins.property
    @pulumi.getter
    def interface(self) -> Optional[pulumi.Input['ServiceTokenServiceTokenConnectionASideAccessPointSelectorInterfaceArgs']]:
        """
        Virtual Device Interface Configuration
        """
        return pulumi.get(self, "interface")

    @interface.setter
    def interface(self, value: Optional[pulumi.Input['ServiceTokenServiceTokenConnectionASideAccessPointSelectorInterfaceArgs']]):
        pulumi.set(self, "interface", value)

    @_builtins.property
    @pulumi.getter(name="linkProtocol")
    def link_protocol(self) -> Optional[pulumi.Input['ServiceTokenServiceTokenConnectionASideAccessPointSelectorLinkProtocolArgs']]:
        """
        Link protocol Configuration
        """
        return pulumi.get(self, "link_protocol")

    @link_protocol.setter
    def link_protocol(self, value: Optional[pulumi.Input['ServiceTokenServiceTokenConnectionASideAccessPointSelectorLinkProtocolArgs']]):
        pulumi.set(self, "link_protocol", value)

    @_builtins.property
    @pulumi.getter
    def network(self) -> Optional[pulumi.Input['ServiceTokenServiceTokenConnectionASideAccessPointSelectorNetworkArgs']]:
        """
        Network Configuration
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: Optional[pulumi.Input['ServiceTokenServiceTokenConnectionASideAccessPointSelectorNetworkArgs']]):
        pulumi.set(self, "network", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input['ServiceTokenServiceTokenConnectionASideAccessPointSelectorPortArgs']]:
        """
        Port Configuration
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input['ServiceTokenServiceTokenConnectionASideAccessPointSelectorPortArgs']]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type of Access point; COLO, VD, NETWORK
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="virtualDevice")
    def virtual_device(self) -> Optional[pulumi.Input['ServiceTokenServiceTokenConnectionASideAccessPointSelectorVirtualDeviceArgs']]:
        """
        Virtual Device Configuration
        """
        return pulumi.get(self, "virtual_device")

    @virtual_device.setter
    def virtual_device(self, value: Optional[pulumi.Input['ServiceTokenServiceTokenConnectionASideAccessPointSelectorVirtualDeviceArgs']]):
        pulumi.set(self, "virtual_device", value)


if not MYPY:
    class ServiceTokenServiceTokenConnectionASideAccessPointSelectorInterfaceArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Interface type
        """
        id: NotRequired[pulumi.Input[_builtins.int]]
        """
        id
        """
        uuid: NotRequired[pulumi.Input[_builtins.str]]
        """
        Equinix-assigned interface identifier
        """
elif False:
    ServiceTokenServiceTokenConnectionASideAccessPointSelectorInterfaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceTokenServiceTokenConnectionASideAccessPointSelectorInterfaceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 id: Optional[pulumi.Input[_builtins.int]] = None,
                 uuid: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Interface type
        :param pulumi.Input[_builtins.int] id: id
        :param pulumi.Input[_builtins.str] uuid: Equinix-assigned interface identifier
        """
        pulumi.set(__self__, "type", type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Interface type
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        id
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Equinix-assigned interface identifier
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class ServiceTokenServiceTokenConnectionASideAccessPointSelectorLinkProtocolArgsDict(TypedDict):
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type of the link protocol - UNTAGGED, DOT1Q, QINQ, EVPN_VXLAN
        """
        vlan_c_tag: NotRequired[pulumi.Input[_builtins.int]]
        """
        Vlan Customer Tag information, vlanCTag value specified for QINQ connections
        """
        vlan_s_tag: NotRequired[pulumi.Input[_builtins.int]]
        """
        Vlan Provider Tag information, vlanSTag value specified for QINQ connections
        """
        vlan_tag: NotRequired[pulumi.Input[_builtins.int]]
        """
        Vlan Tag information, vlanTag value specified for DOT1Q connections
        """
elif False:
    ServiceTokenServiceTokenConnectionASideAccessPointSelectorLinkProtocolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceTokenServiceTokenConnectionASideAccessPointSelectorLinkProtocolArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 vlan_c_tag: Optional[pulumi.Input[_builtins.int]] = None,
                 vlan_s_tag: Optional[pulumi.Input[_builtins.int]] = None,
                 vlan_tag: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Type of the link protocol - UNTAGGED, DOT1Q, QINQ, EVPN_VXLAN
        :param pulumi.Input[_builtins.int] vlan_c_tag: Vlan Customer Tag information, vlanCTag value specified for QINQ connections
        :param pulumi.Input[_builtins.int] vlan_s_tag: Vlan Provider Tag information, vlanSTag value specified for QINQ connections
        :param pulumi.Input[_builtins.int] vlan_tag: Vlan Tag information, vlanTag value specified for DOT1Q connections
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if vlan_c_tag is not None:
            pulumi.set(__self__, "vlan_c_tag", vlan_c_tag)
        if vlan_s_tag is not None:
            pulumi.set(__self__, "vlan_s_tag", vlan_s_tag)
        if vlan_tag is not None:
            pulumi.set(__self__, "vlan_tag", vlan_tag)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type of the link protocol - UNTAGGED, DOT1Q, QINQ, EVPN_VXLAN
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="vlanCTag")
    def vlan_c_tag(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Vlan Customer Tag information, vlanCTag value specified for QINQ connections
        """
        return pulumi.get(self, "vlan_c_tag")

    @vlan_c_tag.setter
    def vlan_c_tag(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "vlan_c_tag", value)

    @_builtins.property
    @pulumi.getter(name="vlanSTag")
    def vlan_s_tag(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Vlan Provider Tag information, vlanSTag value specified for QINQ connections
        """
        return pulumi.get(self, "vlan_s_tag")

    @vlan_s_tag.setter
    def vlan_s_tag(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "vlan_s_tag", value)

    @_builtins.property
    @pulumi.getter(name="vlanTag")
    def vlan_tag(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Vlan Tag information, vlanTag value specified for DOT1Q connections
        """
        return pulumi.get(self, "vlan_tag")

    @vlan_tag.setter
    def vlan_tag(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "vlan_tag", value)


if not MYPY:
    class ServiceTokenServiceTokenConnectionASideAccessPointSelectorNetworkArgsDict(TypedDict):
        uuid: pulumi.Input[_builtins.str]
        """
        Equinix-assigned Network identifier
        """
        href: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unique Resource Identifier
        """
        locations: NotRequired[pulumi.Input[Sequence[pulumi.Input['ServiceTokenServiceTokenConnectionASideAccessPointSelectorNetworkLocationArgsDict']]]]
        """
        Location
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Network Name
        """
        scope: NotRequired[pulumi.Input[_builtins.str]]
        """
        Scope of Network
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type of Network
        """
elif False:
    ServiceTokenServiceTokenConnectionASideAccessPointSelectorNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceTokenServiceTokenConnectionASideAccessPointSelectorNetworkArgs:
    def __init__(__self__, *,
                 uuid: pulumi.Input[_builtins.str],
                 href: Optional[pulumi.Input[_builtins.str]] = None,
                 locations: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceTokenServiceTokenConnectionASideAccessPointSelectorNetworkLocationArgs']]]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 scope: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] uuid: Equinix-assigned Network identifier
        :param pulumi.Input[_builtins.str] href: Unique Resource Identifier
        :param pulumi.Input[Sequence[pulumi.Input['ServiceTokenServiceTokenConnectionASideAccessPointSelectorNetworkLocationArgs']]] locations: Location
        :param pulumi.Input[_builtins.str] name: Network Name
        :param pulumi.Input[_builtins.str] scope: Scope of Network
        :param pulumi.Input[_builtins.str] type: Type of Network
        """
        pulumi.set(__self__, "uuid", uuid)
        if href is not None:
            pulumi.set(__self__, "href", href)
        if locations is not None:
            pulumi.set(__self__, "locations", locations)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> pulumi.Input[_builtins.str]:
        """
        Equinix-assigned Network identifier
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "uuid", value)

    @_builtins.property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unique Resource Identifier
        """
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "href", value)

    @_builtins.property
    @pulumi.getter
    def locations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceTokenServiceTokenConnectionASideAccessPointSelectorNetworkLocationArgs']]]]:
        """
        Location
        """
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceTokenServiceTokenConnectionASideAccessPointSelectorNetworkLocationArgs']]]]):
        pulumi.set(self, "locations", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Network Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Scope of Network
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scope", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type of Network
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ServiceTokenServiceTokenConnectionASideAccessPointSelectorNetworkLocationArgsDict(TypedDict):
        ibx: NotRequired[pulumi.Input[_builtins.str]]
        """
        IBX Code
        """
        metro_code: NotRequired[pulumi.Input[_builtins.str]]
        """
        Access point metro code
        """
        metro_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Access point metro name
        """
        region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Access point region
        """
elif False:
    ServiceTokenServiceTokenConnectionASideAccessPointSelectorNetworkLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceTokenServiceTokenConnectionASideAccessPointSelectorNetworkLocationArgs:
    def __init__(__self__, *,
                 ibx: Optional[pulumi.Input[_builtins.str]] = None,
                 metro_code: Optional[pulumi.Input[_builtins.str]] = None,
                 metro_name: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ibx: IBX Code
        :param pulumi.Input[_builtins.str] metro_code: Access point metro code
        :param pulumi.Input[_builtins.str] metro_name: Access point metro name
        :param pulumi.Input[_builtins.str] region: Access point region
        """
        if ibx is not None:
            pulumi.set(__self__, "ibx", ibx)
        if metro_code is not None:
            pulumi.set(__self__, "metro_code", metro_code)
        if metro_name is not None:
            pulumi.set(__self__, "metro_name", metro_name)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def ibx(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IBX Code
        """
        return pulumi.get(self, "ibx")

    @ibx.setter
    def ibx(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ibx", value)

    @_builtins.property
    @pulumi.getter(name="metroCode")
    def metro_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Access point metro code
        """
        return pulumi.get(self, "metro_code")

    @metro_code.setter
    def metro_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metro_code", value)

    @_builtins.property
    @pulumi.getter(name="metroName")
    def metro_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Access point metro name
        """
        return pulumi.get(self, "metro_name")

    @metro_name.setter
    def metro_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metro_name", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Access point region
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)


if not MYPY:
    class ServiceTokenServiceTokenConnectionASideAccessPointSelectorPortArgsDict(TypedDict):
        uuid: pulumi.Input[_builtins.str]
        """
        Equinix-assigned Port identifier
        """
        account_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Account Name
        """
        bandwidth: NotRequired[pulumi.Input[_builtins.int]]
        """
        Port Bandwidth
        """
        cvp_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        Customer virtual port Id
        """
        encapsulation_protocol_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Port Encapsulation
        """
        href: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unique Resource Identifier
        """
        locations: NotRequired[pulumi.Input[Sequence[pulumi.Input['ServiceTokenServiceTokenConnectionASideAccessPointSelectorPortLocationArgsDict']]]]
        """
        Port Location
        """
        port_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Port Name
        """
        priority: NotRequired[pulumi.Input[_builtins.str]]
        """
        Port Priority
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type of Port
        """
elif False:
    ServiceTokenServiceTokenConnectionASideAccessPointSelectorPortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceTokenServiceTokenConnectionASideAccessPointSelectorPortArgs:
    def __init__(__self__, *,
                 uuid: pulumi.Input[_builtins.str],
                 account_name: Optional[pulumi.Input[_builtins.str]] = None,
                 bandwidth: Optional[pulumi.Input[_builtins.int]] = None,
                 cvp_id: Optional[pulumi.Input[_builtins.int]] = None,
                 encapsulation_protocol_type: Optional[pulumi.Input[_builtins.str]] = None,
                 href: Optional[pulumi.Input[_builtins.str]] = None,
                 locations: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceTokenServiceTokenConnectionASideAccessPointSelectorPortLocationArgs']]]] = None,
                 port_name: Optional[pulumi.Input[_builtins.str]] = None,
                 priority: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] uuid: Equinix-assigned Port identifier
        :param pulumi.Input[_builtins.str] account_name: Account Name
        :param pulumi.Input[_builtins.int] bandwidth: Port Bandwidth
        :param pulumi.Input[_builtins.int] cvp_id: Customer virtual port Id
        :param pulumi.Input[_builtins.str] encapsulation_protocol_type: Port Encapsulation
        :param pulumi.Input[_builtins.str] href: Unique Resource Identifier
        :param pulumi.Input[Sequence[pulumi.Input['ServiceTokenServiceTokenConnectionASideAccessPointSelectorPortLocationArgs']]] locations: Port Location
        :param pulumi.Input[_builtins.str] port_name: Port Name
        :param pulumi.Input[_builtins.str] priority: Port Priority
        :param pulumi.Input[_builtins.str] type: Type of Port
        """
        pulumi.set(__self__, "uuid", uuid)
        if account_name is not None:
            pulumi.set(__self__, "account_name", account_name)
        if bandwidth is not None:
            pulumi.set(__self__, "bandwidth", bandwidth)
        if cvp_id is not None:
            pulumi.set(__self__, "cvp_id", cvp_id)
        if encapsulation_protocol_type is not None:
            pulumi.set(__self__, "encapsulation_protocol_type", encapsulation_protocol_type)
        if href is not None:
            pulumi.set(__self__, "href", href)
        if locations is not None:
            pulumi.set(__self__, "locations", locations)
        if port_name is not None:
            pulumi.set(__self__, "port_name", port_name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> pulumi.Input[_builtins.str]:
        """
        Equinix-assigned Port identifier
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "uuid", value)

    @_builtins.property
    @pulumi.getter(name="accountName")
    def account_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Account Name
        """
        return pulumi.get(self, "account_name")

    @account_name.setter
    def account_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "account_name", value)

    @_builtins.property
    @pulumi.getter
    def bandwidth(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Port Bandwidth
        """
        return pulumi.get(self, "bandwidth")

    @bandwidth.setter
    def bandwidth(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "bandwidth", value)

    @_builtins.property
    @pulumi.getter(name="cvpId")
    def cvp_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Customer virtual port Id
        """
        return pulumi.get(self, "cvp_id")

    @cvp_id.setter
    def cvp_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "cvp_id", value)

    @_builtins.property
    @pulumi.getter(name="encapsulationProtocolType")
    def encapsulation_protocol_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Port Encapsulation
        """
        return pulumi.get(self, "encapsulation_protocol_type")

    @encapsulation_protocol_type.setter
    def encapsulation_protocol_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "encapsulation_protocol_type", value)

    @_builtins.property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unique Resource Identifier
        """
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "href", value)

    @_builtins.property
    @pulumi.getter
    def locations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceTokenServiceTokenConnectionASideAccessPointSelectorPortLocationArgs']]]]:
        """
        Port Location
        """
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceTokenServiceTokenConnectionASideAccessPointSelectorPortLocationArgs']]]]):
        pulumi.set(self, "locations", value)

    @_builtins.property
    @pulumi.getter(name="portName")
    def port_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Port Name
        """
        return pulumi.get(self, "port_name")

    @port_name.setter
    def port_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "port_name", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Port Priority
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type of Port
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ServiceTokenServiceTokenConnectionASideAccessPointSelectorPortLocationArgsDict(TypedDict):
        ibx: NotRequired[pulumi.Input[_builtins.str]]
        """
        IBX Code
        """
        metro_code: NotRequired[pulumi.Input[_builtins.str]]
        """
        Access point metro code
        """
        metro_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Access point metro name
        """
        region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Access point region
        """
elif False:
    ServiceTokenServiceTokenConnectionASideAccessPointSelectorPortLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceTokenServiceTokenConnectionASideAccessPointSelectorPortLocationArgs:
    def __init__(__self__, *,
                 ibx: Optional[pulumi.Input[_builtins.str]] = None,
                 metro_code: Optional[pulumi.Input[_builtins.str]] = None,
                 metro_name: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ibx: IBX Code
        :param pulumi.Input[_builtins.str] metro_code: Access point metro code
        :param pulumi.Input[_builtins.str] metro_name: Access point metro name
        :param pulumi.Input[_builtins.str] region: Access point region
        """
        if ibx is not None:
            pulumi.set(__self__, "ibx", ibx)
        if metro_code is not None:
            pulumi.set(__self__, "metro_code", metro_code)
        if metro_name is not None:
            pulumi.set(__self__, "metro_name", metro_name)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def ibx(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IBX Code
        """
        return pulumi.get(self, "ibx")

    @ibx.setter
    def ibx(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ibx", value)

    @_builtins.property
    @pulumi.getter(name="metroCode")
    def metro_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Access point metro code
        """
        return pulumi.get(self, "metro_code")

    @metro_code.setter
    def metro_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metro_code", value)

    @_builtins.property
    @pulumi.getter(name="metroName")
    def metro_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Access point metro name
        """
        return pulumi.get(self, "metro_name")

    @metro_name.setter
    def metro_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metro_name", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Access point region
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)


if not MYPY:
    class ServiceTokenServiceTokenConnectionASideAccessPointSelectorVirtualDeviceArgsDict(TypedDict):
        uuid: pulumi.Input[_builtins.str]
        """
        Equinix-assigned Virtual Device identifier
        """
        cluster: NotRequired[pulumi.Input[_builtins.str]]
        """
        Virtual Device Cluster Information
        """
        href: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unique Resource Identifier
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Customer-assigned Virtual Device Name
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Virtual Device type
        """
elif False:
    ServiceTokenServiceTokenConnectionASideAccessPointSelectorVirtualDeviceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceTokenServiceTokenConnectionASideAccessPointSelectorVirtualDeviceArgs:
    def __init__(__self__, *,
                 uuid: pulumi.Input[_builtins.str],
                 cluster: Optional[pulumi.Input[_builtins.str]] = None,
                 href: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] uuid: Equinix-assigned Virtual Device identifier
        :param pulumi.Input[_builtins.str] cluster: Virtual Device Cluster Information
        :param pulumi.Input[_builtins.str] href: Unique Resource Identifier
        :param pulumi.Input[_builtins.str] name: Customer-assigned Virtual Device Name
        :param pulumi.Input[_builtins.str] type: Virtual Device type
        """
        pulumi.set(__self__, "uuid", uuid)
        if cluster is not None:
            pulumi.set(__self__, "cluster", cluster)
        if href is not None:
            pulumi.set(__self__, "href", href)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> pulumi.Input[_builtins.str]:
        """
        Equinix-assigned Virtual Device identifier
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "uuid", value)

    @_builtins.property
    @pulumi.getter
    def cluster(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Virtual Device Cluster Information
        """
        return pulumi.get(self, "cluster")

    @cluster.setter
    def cluster(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cluster", value)

    @_builtins.property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unique Resource Identifier
        """
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "href", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Customer-assigned Virtual Device Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Virtual Device type
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ServiceTokenServiceTokenConnectionZSideArgsDict(TypedDict):
        access_point_selectors: pulumi.Input[Sequence[pulumi.Input['ServiceTokenServiceTokenConnectionZSideAccessPointSelectorArgsDict']]]
        """
        List of criteria for selecting network access points with optimal efficiency, security, compatibility, and availability
        """
elif False:
    ServiceTokenServiceTokenConnectionZSideArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceTokenServiceTokenConnectionZSideArgs:
    def __init__(__self__, *,
                 access_point_selectors: pulumi.Input[Sequence[pulumi.Input['ServiceTokenServiceTokenConnectionZSideAccessPointSelectorArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ServiceTokenServiceTokenConnectionZSideAccessPointSelectorArgs']]] access_point_selectors: List of criteria for selecting network access points with optimal efficiency, security, compatibility, and availability
        """
        pulumi.set(__self__, "access_point_selectors", access_point_selectors)

    @_builtins.property
    @pulumi.getter(name="accessPointSelectors")
    def access_point_selectors(self) -> pulumi.Input[Sequence[pulumi.Input['ServiceTokenServiceTokenConnectionZSideAccessPointSelectorArgs']]]:
        """
        List of criteria for selecting network access points with optimal efficiency, security, compatibility, and availability
        """
        return pulumi.get(self, "access_point_selectors")

    @access_point_selectors.setter
    def access_point_selectors(self, value: pulumi.Input[Sequence[pulumi.Input['ServiceTokenServiceTokenConnectionZSideAccessPointSelectorArgs']]]):
        pulumi.set(self, "access_point_selectors", value)


if not MYPY:
    class ServiceTokenServiceTokenConnectionZSideAccessPointSelectorArgsDict(TypedDict):
        interface: NotRequired[pulumi.Input['ServiceTokenServiceTokenConnectionZSideAccessPointSelectorInterfaceArgsDict']]
        """
        Virtual Device Interface Configuration
        """
        link_protocol: NotRequired[pulumi.Input['ServiceTokenServiceTokenConnectionZSideAccessPointSelectorLinkProtocolArgsDict']]
        """
        Link protocol Configuration
        """
        network: NotRequired[pulumi.Input['ServiceTokenServiceTokenConnectionZSideAccessPointSelectorNetworkArgsDict']]
        """
        Network Configuration
        """
        port: NotRequired[pulumi.Input['ServiceTokenServiceTokenConnectionZSideAccessPointSelectorPortArgsDict']]
        """
        Port Configuration
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type of Access point; COLO, VD, NETWORK
        """
        virtual_device: NotRequired[pulumi.Input['ServiceTokenServiceTokenConnectionZSideAccessPointSelectorVirtualDeviceArgsDict']]
        """
        Virtual Device Configuration
        """
elif False:
    ServiceTokenServiceTokenConnectionZSideAccessPointSelectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceTokenServiceTokenConnectionZSideAccessPointSelectorArgs:
    def __init__(__self__, *,
                 interface: Optional[pulumi.Input['ServiceTokenServiceTokenConnectionZSideAccessPointSelectorInterfaceArgs']] = None,
                 link_protocol: Optional[pulumi.Input['ServiceTokenServiceTokenConnectionZSideAccessPointSelectorLinkProtocolArgs']] = None,
                 network: Optional[pulumi.Input['ServiceTokenServiceTokenConnectionZSideAccessPointSelectorNetworkArgs']] = None,
                 port: Optional[pulumi.Input['ServiceTokenServiceTokenConnectionZSideAccessPointSelectorPortArgs']] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 virtual_device: Optional[pulumi.Input['ServiceTokenServiceTokenConnectionZSideAccessPointSelectorVirtualDeviceArgs']] = None):
        """
        :param pulumi.Input['ServiceTokenServiceTokenConnectionZSideAccessPointSelectorInterfaceArgs'] interface: Virtual Device Interface Configuration
        :param pulumi.Input['ServiceTokenServiceTokenConnectionZSideAccessPointSelectorLinkProtocolArgs'] link_protocol: Link protocol Configuration
        :param pulumi.Input['ServiceTokenServiceTokenConnectionZSideAccessPointSelectorNetworkArgs'] network: Network Configuration
        :param pulumi.Input['ServiceTokenServiceTokenConnectionZSideAccessPointSelectorPortArgs'] port: Port Configuration
        :param pulumi.Input[_builtins.str] type: Type of Access point; COLO, VD, NETWORK
        :param pulumi.Input['ServiceTokenServiceTokenConnectionZSideAccessPointSelectorVirtualDeviceArgs'] virtual_device: Virtual Device Configuration
        """
        if interface is not None:
            pulumi.set(__self__, "interface", interface)
        if link_protocol is not None:
            pulumi.set(__self__, "link_protocol", link_protocol)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if virtual_device is not None:
            pulumi.set(__self__, "virtual_device", virtual_device)

    @_builtins.property
    @pulumi.getter
    def interface(self) -> Optional[pulumi.Input['ServiceTokenServiceTokenConnectionZSideAccessPointSelectorInterfaceArgs']]:
        """
        Virtual Device Interface Configuration
        """
        return pulumi.get(self, "interface")

    @interface.setter
    def interface(self, value: Optional[pulumi.Input['ServiceTokenServiceTokenConnectionZSideAccessPointSelectorInterfaceArgs']]):
        pulumi.set(self, "interface", value)

    @_builtins.property
    @pulumi.getter(name="linkProtocol")
    def link_protocol(self) -> Optional[pulumi.Input['ServiceTokenServiceTokenConnectionZSideAccessPointSelectorLinkProtocolArgs']]:
        """
        Link protocol Configuration
        """
        return pulumi.get(self, "link_protocol")

    @link_protocol.setter
    def link_protocol(self, value: Optional[pulumi.Input['ServiceTokenServiceTokenConnectionZSideAccessPointSelectorLinkProtocolArgs']]):
        pulumi.set(self, "link_protocol", value)

    @_builtins.property
    @pulumi.getter
    def network(self) -> Optional[pulumi.Input['ServiceTokenServiceTokenConnectionZSideAccessPointSelectorNetworkArgs']]:
        """
        Network Configuration
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: Optional[pulumi.Input['ServiceTokenServiceTokenConnectionZSideAccessPointSelectorNetworkArgs']]):
        pulumi.set(self, "network", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input['ServiceTokenServiceTokenConnectionZSideAccessPointSelectorPortArgs']]:
        """
        Port Configuration
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input['ServiceTokenServiceTokenConnectionZSideAccessPointSelectorPortArgs']]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type of Access point; COLO, VD, NETWORK
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="virtualDevice")
    def virtual_device(self) -> Optional[pulumi.Input['ServiceTokenServiceTokenConnectionZSideAccessPointSelectorVirtualDeviceArgs']]:
        """
        Virtual Device Configuration
        """
        return pulumi.get(self, "virtual_device")

    @virtual_device.setter
    def virtual_device(self, value: Optional[pulumi.Input['ServiceTokenServiceTokenConnectionZSideAccessPointSelectorVirtualDeviceArgs']]):
        pulumi.set(self, "virtual_device", value)


if not MYPY:
    class ServiceTokenServiceTokenConnectionZSideAccessPointSelectorInterfaceArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Interface type
        """
        id: NotRequired[pulumi.Input[_builtins.int]]
        """
        id
        """
        uuid: NotRequired[pulumi.Input[_builtins.str]]
        """
        Equinix-assigned interface identifier
        """
elif False:
    ServiceTokenServiceTokenConnectionZSideAccessPointSelectorInterfaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceTokenServiceTokenConnectionZSideAccessPointSelectorInterfaceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 id: Optional[pulumi.Input[_builtins.int]] = None,
                 uuid: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Interface type
        :param pulumi.Input[_builtins.int] id: id
        :param pulumi.Input[_builtins.str] uuid: Equinix-assigned interface identifier
        """
        pulumi.set(__self__, "type", type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Interface type
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        id
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Equinix-assigned interface identifier
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class ServiceTokenServiceTokenConnectionZSideAccessPointSelectorLinkProtocolArgsDict(TypedDict):
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type of the link protocol - UNTAGGED, DOT1Q, QINQ, EVPN_VXLAN
        """
        vlan_c_tag: NotRequired[pulumi.Input[_builtins.int]]
        """
        Vlan Customer Tag information, vlanCTag value specified for QINQ connections
        """
        vlan_s_tag: NotRequired[pulumi.Input[_builtins.int]]
        """
        Vlan Provider Tag information, vlanSTag value specified for QINQ connections
        """
        vlan_tag: NotRequired[pulumi.Input[_builtins.int]]
        """
        Vlan Tag information, vlanTag value specified for DOT1Q connections
        """
elif False:
    ServiceTokenServiceTokenConnectionZSideAccessPointSelectorLinkProtocolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceTokenServiceTokenConnectionZSideAccessPointSelectorLinkProtocolArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 vlan_c_tag: Optional[pulumi.Input[_builtins.int]] = None,
                 vlan_s_tag: Optional[pulumi.Input[_builtins.int]] = None,
                 vlan_tag: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Type of the link protocol - UNTAGGED, DOT1Q, QINQ, EVPN_VXLAN
        :param pulumi.Input[_builtins.int] vlan_c_tag: Vlan Customer Tag information, vlanCTag value specified for QINQ connections
        :param pulumi.Input[_builtins.int] vlan_s_tag: Vlan Provider Tag information, vlanSTag value specified for QINQ connections
        :param pulumi.Input[_builtins.int] vlan_tag: Vlan Tag information, vlanTag value specified for DOT1Q connections
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if vlan_c_tag is not None:
            pulumi.set(__self__, "vlan_c_tag", vlan_c_tag)
        if vlan_s_tag is not None:
            pulumi.set(__self__, "vlan_s_tag", vlan_s_tag)
        if vlan_tag is not None:
            pulumi.set(__self__, "vlan_tag", vlan_tag)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type of the link protocol - UNTAGGED, DOT1Q, QINQ, EVPN_VXLAN
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="vlanCTag")
    def vlan_c_tag(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Vlan Customer Tag information, vlanCTag value specified for QINQ connections
        """
        return pulumi.get(self, "vlan_c_tag")

    @vlan_c_tag.setter
    def vlan_c_tag(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "vlan_c_tag", value)

    @_builtins.property
    @pulumi.getter(name="vlanSTag")
    def vlan_s_tag(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Vlan Provider Tag information, vlanSTag value specified for QINQ connections
        """
        return pulumi.get(self, "vlan_s_tag")

    @vlan_s_tag.setter
    def vlan_s_tag(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "vlan_s_tag", value)

    @_builtins.property
    @pulumi.getter(name="vlanTag")
    def vlan_tag(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Vlan Tag information, vlanTag value specified for DOT1Q connections
        """
        return pulumi.get(self, "vlan_tag")

    @vlan_tag.setter
    def vlan_tag(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "vlan_tag", value)


if not MYPY:
    class ServiceTokenServiceTokenConnectionZSideAccessPointSelectorNetworkArgsDict(TypedDict):
        uuid: pulumi.Input[_builtins.str]
        """
        Equinix-assigned Network identifier
        """
        href: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unique Resource Identifier
        """
        locations: NotRequired[pulumi.Input[Sequence[pulumi.Input['ServiceTokenServiceTokenConnectionZSideAccessPointSelectorNetworkLocationArgsDict']]]]
        """
        Location
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Network Name
        """
        scope: NotRequired[pulumi.Input[_builtins.str]]
        """
        Scope of Network
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type of Network
        """
elif False:
    ServiceTokenServiceTokenConnectionZSideAccessPointSelectorNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceTokenServiceTokenConnectionZSideAccessPointSelectorNetworkArgs:
    def __init__(__self__, *,
                 uuid: pulumi.Input[_builtins.str],
                 href: Optional[pulumi.Input[_builtins.str]] = None,
                 locations: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceTokenServiceTokenConnectionZSideAccessPointSelectorNetworkLocationArgs']]]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 scope: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] uuid: Equinix-assigned Network identifier
        :param pulumi.Input[_builtins.str] href: Unique Resource Identifier
        :param pulumi.Input[Sequence[pulumi.Input['ServiceTokenServiceTokenConnectionZSideAccessPointSelectorNetworkLocationArgs']]] locations: Location
        :param pulumi.Input[_builtins.str] name: Network Name
        :param pulumi.Input[_builtins.str] scope: Scope of Network
        :param pulumi.Input[_builtins.str] type: Type of Network
        """
        pulumi.set(__self__, "uuid", uuid)
        if href is not None:
            pulumi.set(__self__, "href", href)
        if locations is not None:
            pulumi.set(__self__, "locations", locations)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> pulumi.Input[_builtins.str]:
        """
        Equinix-assigned Network identifier
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "uuid", value)

    @_builtins.property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unique Resource Identifier
        """
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "href", value)

    @_builtins.property
    @pulumi.getter
    def locations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceTokenServiceTokenConnectionZSideAccessPointSelectorNetworkLocationArgs']]]]:
        """
        Location
        """
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceTokenServiceTokenConnectionZSideAccessPointSelectorNetworkLocationArgs']]]]):
        pulumi.set(self, "locations", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Network Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Scope of Network
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scope", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type of Network
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ServiceTokenServiceTokenConnectionZSideAccessPointSelectorNetworkLocationArgsDict(TypedDict):
        ibx: NotRequired[pulumi.Input[_builtins.str]]
        """
        IBX Code
        """
        metro_code: NotRequired[pulumi.Input[_builtins.str]]
        """
        Access point metro code
        """
        metro_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Access point metro name
        """
        region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Access point region
        """
elif False:
    ServiceTokenServiceTokenConnectionZSideAccessPointSelectorNetworkLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceTokenServiceTokenConnectionZSideAccessPointSelectorNetworkLocationArgs:
    def __init__(__self__, *,
                 ibx: Optional[pulumi.Input[_builtins.str]] = None,
                 metro_code: Optional[pulumi.Input[_builtins.str]] = None,
                 metro_name: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ibx: IBX Code
        :param pulumi.Input[_builtins.str] metro_code: Access point metro code
        :param pulumi.Input[_builtins.str] metro_name: Access point metro name
        :param pulumi.Input[_builtins.str] region: Access point region
        """
        if ibx is not None:
            pulumi.set(__self__, "ibx", ibx)
        if metro_code is not None:
            pulumi.set(__self__, "metro_code", metro_code)
        if metro_name is not None:
            pulumi.set(__self__, "metro_name", metro_name)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def ibx(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IBX Code
        """
        return pulumi.get(self, "ibx")

    @ibx.setter
    def ibx(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ibx", value)

    @_builtins.property
    @pulumi.getter(name="metroCode")
    def metro_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Access point metro code
        """
        return pulumi.get(self, "metro_code")

    @metro_code.setter
    def metro_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metro_code", value)

    @_builtins.property
    @pulumi.getter(name="metroName")
    def metro_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Access point metro name
        """
        return pulumi.get(self, "metro_name")

    @metro_name.setter
    def metro_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metro_name", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Access point region
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)


if not MYPY:
    class ServiceTokenServiceTokenConnectionZSideAccessPointSelectorPortArgsDict(TypedDict):
        uuid: pulumi.Input[_builtins.str]
        """
        Equinix-assigned Port identifier
        """
        account_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Account Name
        """
        bandwidth: NotRequired[pulumi.Input[_builtins.int]]
        """
        Port Bandwidth
        """
        cvp_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        Customer virtual port Id
        """
        encapsulation_protocol_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Port Encapsulation
        """
        href: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unique Resource Identifier
        """
        locations: NotRequired[pulumi.Input[Sequence[pulumi.Input['ServiceTokenServiceTokenConnectionZSideAccessPointSelectorPortLocationArgsDict']]]]
        """
        Port Location
        """
        port_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Port Name
        """
        priority: NotRequired[pulumi.Input[_builtins.str]]
        """
        Port Priority
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type of Port
        """
elif False:
    ServiceTokenServiceTokenConnectionZSideAccessPointSelectorPortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceTokenServiceTokenConnectionZSideAccessPointSelectorPortArgs:
    def __init__(__self__, *,
                 uuid: pulumi.Input[_builtins.str],
                 account_name: Optional[pulumi.Input[_builtins.str]] = None,
                 bandwidth: Optional[pulumi.Input[_builtins.int]] = None,
                 cvp_id: Optional[pulumi.Input[_builtins.int]] = None,
                 encapsulation_protocol_type: Optional[pulumi.Input[_builtins.str]] = None,
                 href: Optional[pulumi.Input[_builtins.str]] = None,
                 locations: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceTokenServiceTokenConnectionZSideAccessPointSelectorPortLocationArgs']]]] = None,
                 port_name: Optional[pulumi.Input[_builtins.str]] = None,
                 priority: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] uuid: Equinix-assigned Port identifier
        :param pulumi.Input[_builtins.str] account_name: Account Name
        :param pulumi.Input[_builtins.int] bandwidth: Port Bandwidth
        :param pulumi.Input[_builtins.int] cvp_id: Customer virtual port Id
        :param pulumi.Input[_builtins.str] encapsulation_protocol_type: Port Encapsulation
        :param pulumi.Input[_builtins.str] href: Unique Resource Identifier
        :param pulumi.Input[Sequence[pulumi.Input['ServiceTokenServiceTokenConnectionZSideAccessPointSelectorPortLocationArgs']]] locations: Port Location
        :param pulumi.Input[_builtins.str] port_name: Port Name
        :param pulumi.Input[_builtins.str] priority: Port Priority
        :param pulumi.Input[_builtins.str] type: Type of Port
        """
        pulumi.set(__self__, "uuid", uuid)
        if account_name is not None:
            pulumi.set(__self__, "account_name", account_name)
        if bandwidth is not None:
            pulumi.set(__self__, "bandwidth", bandwidth)
        if cvp_id is not None:
            pulumi.set(__self__, "cvp_id", cvp_id)
        if encapsulation_protocol_type is not None:
            pulumi.set(__self__, "encapsulation_protocol_type", encapsulation_protocol_type)
        if href is not None:
            pulumi.set(__self__, "href", href)
        if locations is not None:
            pulumi.set(__self__, "locations", locations)
        if port_name is not None:
            pulumi.set(__self__, "port_name", port_name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> pulumi.Input[_builtins.str]:
        """
        Equinix-assigned Port identifier
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "uuid", value)

    @_builtins.property
    @pulumi.getter(name="accountName")
    def account_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Account Name
        """
        return pulumi.get(self, "account_name")

    @account_name.setter
    def account_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "account_name", value)

    @_builtins.property
    @pulumi.getter
    def bandwidth(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Port Bandwidth
        """
        return pulumi.get(self, "bandwidth")

    @bandwidth.setter
    def bandwidth(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "bandwidth", value)

    @_builtins.property
    @pulumi.getter(name="cvpId")
    def cvp_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Customer virtual port Id
        """
        return pulumi.get(self, "cvp_id")

    @cvp_id.setter
    def cvp_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "cvp_id", value)

    @_builtins.property
    @pulumi.getter(name="encapsulationProtocolType")
    def encapsulation_protocol_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Port Encapsulation
        """
        return pulumi.get(self, "encapsulation_protocol_type")

    @encapsulation_protocol_type.setter
    def encapsulation_protocol_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "encapsulation_protocol_type", value)

    @_builtins.property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unique Resource Identifier
        """
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "href", value)

    @_builtins.property
    @pulumi.getter
    def locations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceTokenServiceTokenConnectionZSideAccessPointSelectorPortLocationArgs']]]]:
        """
        Port Location
        """
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceTokenServiceTokenConnectionZSideAccessPointSelectorPortLocationArgs']]]]):
        pulumi.set(self, "locations", value)

    @_builtins.property
    @pulumi.getter(name="portName")
    def port_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Port Name
        """
        return pulumi.get(self, "port_name")

    @port_name.setter
    def port_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "port_name", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Port Priority
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type of Port
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ServiceTokenServiceTokenConnectionZSideAccessPointSelectorPortLocationArgsDict(TypedDict):
        ibx: NotRequired[pulumi.Input[_builtins.str]]
        """
        IBX Code
        """
        metro_code: NotRequired[pulumi.Input[_builtins.str]]
        """
        Access point metro code
        """
        metro_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Access point metro name
        """
        region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Access point region
        """
elif False:
    ServiceTokenServiceTokenConnectionZSideAccessPointSelectorPortLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceTokenServiceTokenConnectionZSideAccessPointSelectorPortLocationArgs:
    def __init__(__self__, *,
                 ibx: Optional[pulumi.Input[_builtins.str]] = None,
                 metro_code: Optional[pulumi.Input[_builtins.str]] = None,
                 metro_name: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ibx: IBX Code
        :param pulumi.Input[_builtins.str] metro_code: Access point metro code
        :param pulumi.Input[_builtins.str] metro_name: Access point metro name
        :param pulumi.Input[_builtins.str] region: Access point region
        """
        if ibx is not None:
            pulumi.set(__self__, "ibx", ibx)
        if metro_code is not None:
            pulumi.set(__self__, "metro_code", metro_code)
        if metro_name is not None:
            pulumi.set(__self__, "metro_name", metro_name)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def ibx(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IBX Code
        """
        return pulumi.get(self, "ibx")

    @ibx.setter
    def ibx(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ibx", value)

    @_builtins.property
    @pulumi.getter(name="metroCode")
    def metro_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Access point metro code
        """
        return pulumi.get(self, "metro_code")

    @metro_code.setter
    def metro_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metro_code", value)

    @_builtins.property
    @pulumi.getter(name="metroName")
    def metro_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Access point metro name
        """
        return pulumi.get(self, "metro_name")

    @metro_name.setter
    def metro_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metro_name", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Access point region
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)


if not MYPY:
    class ServiceTokenServiceTokenConnectionZSideAccessPointSelectorVirtualDeviceArgsDict(TypedDict):
        uuid: pulumi.Input[_builtins.str]
        """
        Equinix-assigned Virtual Device identifier
        """
        cluster: NotRequired[pulumi.Input[_builtins.str]]
        """
        Virtual Device Cluster Information
        """
        href: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unique Resource Identifier
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Customer-assigned Virtual Device Name
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Virtual Device type
        """
elif False:
    ServiceTokenServiceTokenConnectionZSideAccessPointSelectorVirtualDeviceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceTokenServiceTokenConnectionZSideAccessPointSelectorVirtualDeviceArgs:
    def __init__(__self__, *,
                 uuid: pulumi.Input[_builtins.str],
                 cluster: Optional[pulumi.Input[_builtins.str]] = None,
                 href: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] uuid: Equinix-assigned Virtual Device identifier
        :param pulumi.Input[_builtins.str] cluster: Virtual Device Cluster Information
        :param pulumi.Input[_builtins.str] href: Unique Resource Identifier
        :param pulumi.Input[_builtins.str] name: Customer-assigned Virtual Device Name
        :param pulumi.Input[_builtins.str] type: Virtual Device type
        """
        pulumi.set(__self__, "uuid", uuid)
        if cluster is not None:
            pulumi.set(__self__, "cluster", cluster)
        if href is not None:
            pulumi.set(__self__, "href", href)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> pulumi.Input[_builtins.str]:
        """
        Equinix-assigned Virtual Device identifier
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "uuid", value)

    @_builtins.property
    @pulumi.getter
    def cluster(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Virtual Device Cluster Information
        """
        return pulumi.get(self, "cluster")

    @cluster.setter
    def cluster(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cluster", value)

    @_builtins.property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unique Resource Identifier
        """
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "href", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Customer-assigned Virtual Device Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Virtual Device type
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class StreamAlertRuleChangeLogArgsDict(TypedDict):
        created_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        User name of creator of the stream resource
        """
        created_by_email: NotRequired[pulumi.Input[_builtins.str]]
        """
        Email of creator of the stream resource
        """
        created_by_full_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Legal name of creator of the stream resource
        """
        created_date_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Creation time of the stream resource
        """
        deleted_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        User name of deleter of the stream resource
        """
        deleted_by_email: NotRequired[pulumi.Input[_builtins.str]]
        """
        Email of deleter of the stream resource
        """
        deleted_by_full_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Legal name of deleter of the stream resource
        """
        deleted_date_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Deletion time of the stream resource
        """
        updated_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        User name of last updater of the stream resource
        """
        updated_by_email: NotRequired[pulumi.Input[_builtins.str]]
        """
        Email of last updater of the stream resource
        """
        updated_by_full_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Legal name of last updater of the stream resource
        """
        updated_date_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Last update time of the stream resource
        """
elif False:
    StreamAlertRuleChangeLogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamAlertRuleChangeLogArgs:
    def __init__(__self__, *,
                 created_by: Optional[pulumi.Input[_builtins.str]] = None,
                 created_by_email: Optional[pulumi.Input[_builtins.str]] = None,
                 created_by_full_name: Optional[pulumi.Input[_builtins.str]] = None,
                 created_date_time: Optional[pulumi.Input[_builtins.str]] = None,
                 deleted_by: Optional[pulumi.Input[_builtins.str]] = None,
                 deleted_by_email: Optional[pulumi.Input[_builtins.str]] = None,
                 deleted_by_full_name: Optional[pulumi.Input[_builtins.str]] = None,
                 deleted_date_time: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_by: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_by_email: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_by_full_name: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_date_time: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] created_by: User name of creator of the stream resource
        :param pulumi.Input[_builtins.str] created_by_email: Email of creator of the stream resource
        :param pulumi.Input[_builtins.str] created_by_full_name: Legal name of creator of the stream resource
        :param pulumi.Input[_builtins.str] created_date_time: Creation time of the stream resource
        :param pulumi.Input[_builtins.str] deleted_by: User name of deleter of the stream resource
        :param pulumi.Input[_builtins.str] deleted_by_email: Email of deleter of the stream resource
        :param pulumi.Input[_builtins.str] deleted_by_full_name: Legal name of deleter of the stream resource
        :param pulumi.Input[_builtins.str] deleted_date_time: Deletion time of the stream resource
        :param pulumi.Input[_builtins.str] updated_by: User name of last updater of the stream resource
        :param pulumi.Input[_builtins.str] updated_by_email: Email of last updater of the stream resource
        :param pulumi.Input[_builtins.str] updated_by_full_name: Legal name of last updater of the stream resource
        :param pulumi.Input[_builtins.str] updated_date_time: Last update time of the stream resource
        """
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if created_by_email is not None:
            pulumi.set(__self__, "created_by_email", created_by_email)
        if created_by_full_name is not None:
            pulumi.set(__self__, "created_by_full_name", created_by_full_name)
        if created_date_time is not None:
            pulumi.set(__self__, "created_date_time", created_date_time)
        if deleted_by is not None:
            pulumi.set(__self__, "deleted_by", deleted_by)
        if deleted_by_email is not None:
            pulumi.set(__self__, "deleted_by_email", deleted_by_email)
        if deleted_by_full_name is not None:
            pulumi.set(__self__, "deleted_by_full_name", deleted_by_full_name)
        if deleted_date_time is not None:
            pulumi.set(__self__, "deleted_date_time", deleted_date_time)
        if updated_by is not None:
            pulumi.set(__self__, "updated_by", updated_by)
        if updated_by_email is not None:
            pulumi.set(__self__, "updated_by_email", updated_by_email)
        if updated_by_full_name is not None:
            pulumi.set(__self__, "updated_by_full_name", updated_by_full_name)
        if updated_date_time is not None:
            pulumi.set(__self__, "updated_date_time", updated_date_time)

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        User name of creator of the stream resource
        """
        return pulumi.get(self, "created_by")

    @created_by.setter
    def created_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_by", value)

    @_builtins.property
    @pulumi.getter(name="createdByEmail")
    def created_by_email(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Email of creator of the stream resource
        """
        return pulumi.get(self, "created_by_email")

    @created_by_email.setter
    def created_by_email(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_by_email", value)

    @_builtins.property
    @pulumi.getter(name="createdByFullName")
    def created_by_full_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Legal name of creator of the stream resource
        """
        return pulumi.get(self, "created_by_full_name")

    @created_by_full_name.setter
    def created_by_full_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_by_full_name", value)

    @_builtins.property
    @pulumi.getter(name="createdDateTime")
    def created_date_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Creation time of the stream resource
        """
        return pulumi.get(self, "created_date_time")

    @created_date_time.setter
    def created_date_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_date_time", value)

    @_builtins.property
    @pulumi.getter(name="deletedBy")
    def deleted_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        User name of deleter of the stream resource
        """
        return pulumi.get(self, "deleted_by")

    @deleted_by.setter
    def deleted_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deleted_by", value)

    @_builtins.property
    @pulumi.getter(name="deletedByEmail")
    def deleted_by_email(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Email of deleter of the stream resource
        """
        return pulumi.get(self, "deleted_by_email")

    @deleted_by_email.setter
    def deleted_by_email(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deleted_by_email", value)

    @_builtins.property
    @pulumi.getter(name="deletedByFullName")
    def deleted_by_full_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Legal name of deleter of the stream resource
        """
        return pulumi.get(self, "deleted_by_full_name")

    @deleted_by_full_name.setter
    def deleted_by_full_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deleted_by_full_name", value)

    @_builtins.property
    @pulumi.getter(name="deletedDateTime")
    def deleted_date_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Deletion time of the stream resource
        """
        return pulumi.get(self, "deleted_date_time")

    @deleted_date_time.setter
    def deleted_date_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deleted_date_time", value)

    @_builtins.property
    @pulumi.getter(name="updatedBy")
    def updated_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        User name of last updater of the stream resource
        """
        return pulumi.get(self, "updated_by")

    @updated_by.setter
    def updated_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_by", value)

    @_builtins.property
    @pulumi.getter(name="updatedByEmail")
    def updated_by_email(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Email of last updater of the stream resource
        """
        return pulumi.get(self, "updated_by_email")

    @updated_by_email.setter
    def updated_by_email(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_by_email", value)

    @_builtins.property
    @pulumi.getter(name="updatedByFullName")
    def updated_by_full_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Legal name of last updater of the stream resource
        """
        return pulumi.get(self, "updated_by_full_name")

    @updated_by_full_name.setter
    def updated_by_full_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_by_full_name", value)

    @_builtins.property
    @pulumi.getter(name="updatedDateTime")
    def updated_date_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Last update time of the stream resource
        """
        return pulumi.get(self, "updated_date_time")

    @updated_date_time.setter
    def updated_date_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_date_time", value)


if not MYPY:
    class StreamAlertRuleResourceSelectorArgsDict(TypedDict):
        includes: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        List of metrics to include
        """
elif False:
    StreamAlertRuleResourceSelectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamAlertRuleResourceSelectorArgs:
    def __init__(__self__, *,
                 includes: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] includes: List of metrics to include
        """
        pulumi.set(__self__, "includes", includes)

    @_builtins.property
    @pulumi.getter
    def includes(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List of metrics to include
        """
        return pulumi.get(self, "includes")

    @includes.setter
    def includes(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "includes", value)


if not MYPY:
    class StreamAlertRuleTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        read: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    StreamAlertRuleTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamAlertRuleTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 read: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if read is not None:
            pulumi.set(__self__, "read", read)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def read(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @read.setter
    def read(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "read", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class StreamAttachmentTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        read: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    StreamAttachmentTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamAttachmentTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 read: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if read is not None:
            pulumi.set(__self__, "read", read)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def read(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @read.setter
    def read(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "read", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class StreamChangeLogArgsDict(TypedDict):
        created_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        User name of creator of the stream resource
        """
        created_by_email: NotRequired[pulumi.Input[_builtins.str]]
        """
        Email of creator of the stream resource
        """
        created_by_full_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Legal name of creator of the stream resource
        """
        created_date_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Creation time of the stream resource
        """
        deleted_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        User name of deleter of the stream resource
        """
        deleted_by_email: NotRequired[pulumi.Input[_builtins.str]]
        """
        Email of deleter of the stream resource
        """
        deleted_by_full_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Legal name of deleter of the stream resource
        """
        deleted_date_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Deletion time of the stream resource
        """
        updated_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        User name of last updater of the stream resource
        """
        updated_by_email: NotRequired[pulumi.Input[_builtins.str]]
        """
        Email of last updater of the stream resource
        """
        updated_by_full_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Legal name of last updater of the stream resource
        """
        updated_date_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Last update time of the stream resource
        """
elif False:
    StreamChangeLogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamChangeLogArgs:
    def __init__(__self__, *,
                 created_by: Optional[pulumi.Input[_builtins.str]] = None,
                 created_by_email: Optional[pulumi.Input[_builtins.str]] = None,
                 created_by_full_name: Optional[pulumi.Input[_builtins.str]] = None,
                 created_date_time: Optional[pulumi.Input[_builtins.str]] = None,
                 deleted_by: Optional[pulumi.Input[_builtins.str]] = None,
                 deleted_by_email: Optional[pulumi.Input[_builtins.str]] = None,
                 deleted_by_full_name: Optional[pulumi.Input[_builtins.str]] = None,
                 deleted_date_time: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_by: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_by_email: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_by_full_name: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_date_time: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] created_by: User name of creator of the stream resource
        :param pulumi.Input[_builtins.str] created_by_email: Email of creator of the stream resource
        :param pulumi.Input[_builtins.str] created_by_full_name: Legal name of creator of the stream resource
        :param pulumi.Input[_builtins.str] created_date_time: Creation time of the stream resource
        :param pulumi.Input[_builtins.str] deleted_by: User name of deleter of the stream resource
        :param pulumi.Input[_builtins.str] deleted_by_email: Email of deleter of the stream resource
        :param pulumi.Input[_builtins.str] deleted_by_full_name: Legal name of deleter of the stream resource
        :param pulumi.Input[_builtins.str] deleted_date_time: Deletion time of the stream resource
        :param pulumi.Input[_builtins.str] updated_by: User name of last updater of the stream resource
        :param pulumi.Input[_builtins.str] updated_by_email: Email of last updater of the stream resource
        :param pulumi.Input[_builtins.str] updated_by_full_name: Legal name of last updater of the stream resource
        :param pulumi.Input[_builtins.str] updated_date_time: Last update time of the stream resource
        """
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if created_by_email is not None:
            pulumi.set(__self__, "created_by_email", created_by_email)
        if created_by_full_name is not None:
            pulumi.set(__self__, "created_by_full_name", created_by_full_name)
        if created_date_time is not None:
            pulumi.set(__self__, "created_date_time", created_date_time)
        if deleted_by is not None:
            pulumi.set(__self__, "deleted_by", deleted_by)
        if deleted_by_email is not None:
            pulumi.set(__self__, "deleted_by_email", deleted_by_email)
        if deleted_by_full_name is not None:
            pulumi.set(__self__, "deleted_by_full_name", deleted_by_full_name)
        if deleted_date_time is not None:
            pulumi.set(__self__, "deleted_date_time", deleted_date_time)
        if updated_by is not None:
            pulumi.set(__self__, "updated_by", updated_by)
        if updated_by_email is not None:
            pulumi.set(__self__, "updated_by_email", updated_by_email)
        if updated_by_full_name is not None:
            pulumi.set(__self__, "updated_by_full_name", updated_by_full_name)
        if updated_date_time is not None:
            pulumi.set(__self__, "updated_date_time", updated_date_time)

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        User name of creator of the stream resource
        """
        return pulumi.get(self, "created_by")

    @created_by.setter
    def created_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_by", value)

    @_builtins.property
    @pulumi.getter(name="createdByEmail")
    def created_by_email(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Email of creator of the stream resource
        """
        return pulumi.get(self, "created_by_email")

    @created_by_email.setter
    def created_by_email(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_by_email", value)

    @_builtins.property
    @pulumi.getter(name="createdByFullName")
    def created_by_full_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Legal name of creator of the stream resource
        """
        return pulumi.get(self, "created_by_full_name")

    @created_by_full_name.setter
    def created_by_full_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_by_full_name", value)

    @_builtins.property
    @pulumi.getter(name="createdDateTime")
    def created_date_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Creation time of the stream resource
        """
        return pulumi.get(self, "created_date_time")

    @created_date_time.setter
    def created_date_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_date_time", value)

    @_builtins.property
    @pulumi.getter(name="deletedBy")
    def deleted_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        User name of deleter of the stream resource
        """
        return pulumi.get(self, "deleted_by")

    @deleted_by.setter
    def deleted_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deleted_by", value)

    @_builtins.property
    @pulumi.getter(name="deletedByEmail")
    def deleted_by_email(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Email of deleter of the stream resource
        """
        return pulumi.get(self, "deleted_by_email")

    @deleted_by_email.setter
    def deleted_by_email(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deleted_by_email", value)

    @_builtins.property
    @pulumi.getter(name="deletedByFullName")
    def deleted_by_full_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Legal name of deleter of the stream resource
        """
        return pulumi.get(self, "deleted_by_full_name")

    @deleted_by_full_name.setter
    def deleted_by_full_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deleted_by_full_name", value)

    @_builtins.property
    @pulumi.getter(name="deletedDateTime")
    def deleted_date_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Deletion time of the stream resource
        """
        return pulumi.get(self, "deleted_date_time")

    @deleted_date_time.setter
    def deleted_date_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deleted_date_time", value)

    @_builtins.property
    @pulumi.getter(name="updatedBy")
    def updated_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        User name of last updater of the stream resource
        """
        return pulumi.get(self, "updated_by")

    @updated_by.setter
    def updated_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_by", value)

    @_builtins.property
    @pulumi.getter(name="updatedByEmail")
    def updated_by_email(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Email of last updater of the stream resource
        """
        return pulumi.get(self, "updated_by_email")

    @updated_by_email.setter
    def updated_by_email(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_by_email", value)

    @_builtins.property
    @pulumi.getter(name="updatedByFullName")
    def updated_by_full_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Legal name of last updater of the stream resource
        """
        return pulumi.get(self, "updated_by_full_name")

    @updated_by_full_name.setter
    def updated_by_full_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_by_full_name", value)

    @_builtins.property
    @pulumi.getter(name="updatedDateTime")
    def updated_date_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Last update time of the stream resource
        """
        return pulumi.get(self, "updated_date_time")

    @updated_date_time.setter
    def updated_date_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_date_time", value)


if not MYPY:
    class StreamProjectArgsDict(TypedDict):
        project_id: pulumi.Input[_builtins.str]
        """
        Equinix Subscriber-assigned project ID
        """
elif False:
    StreamProjectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamProjectArgs:
    def __init__(__self__, *,
                 project_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] project_id: Equinix Subscriber-assigned project ID
        """
        pulumi.set(__self__, "project_id", project_id)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> pulumi.Input[_builtins.str]:
        """
        Equinix Subscriber-assigned project ID
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "project_id", value)


if not MYPY:
    class StreamSubscriptionChangeLogArgsDict(TypedDict):
        created_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        User name of creator of the stream resource
        """
        created_by_email: NotRequired[pulumi.Input[_builtins.str]]
        """
        Email of creator of the stream resource
        """
        created_by_full_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Legal name of creator of the stream resource
        """
        created_date_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Creation time of the stream resource
        """
        deleted_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        User name of deleter of the stream resource
        """
        deleted_by_email: NotRequired[pulumi.Input[_builtins.str]]
        """
        Email of deleter of the stream resource
        """
        deleted_by_full_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Legal name of deleter of the stream resource
        """
        deleted_date_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Deletion time of the stream resource
        """
        updated_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        User name of last updater of the stream resource
        """
        updated_by_email: NotRequired[pulumi.Input[_builtins.str]]
        """
        Email of last updater of the stream resource
        """
        updated_by_full_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Legal name of last updater of the stream resource
        """
        updated_date_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Last update time of the stream resource
        """
elif False:
    StreamSubscriptionChangeLogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamSubscriptionChangeLogArgs:
    def __init__(__self__, *,
                 created_by: Optional[pulumi.Input[_builtins.str]] = None,
                 created_by_email: Optional[pulumi.Input[_builtins.str]] = None,
                 created_by_full_name: Optional[pulumi.Input[_builtins.str]] = None,
                 created_date_time: Optional[pulumi.Input[_builtins.str]] = None,
                 deleted_by: Optional[pulumi.Input[_builtins.str]] = None,
                 deleted_by_email: Optional[pulumi.Input[_builtins.str]] = None,
                 deleted_by_full_name: Optional[pulumi.Input[_builtins.str]] = None,
                 deleted_date_time: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_by: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_by_email: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_by_full_name: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_date_time: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] created_by: User name of creator of the stream resource
        :param pulumi.Input[_builtins.str] created_by_email: Email of creator of the stream resource
        :param pulumi.Input[_builtins.str] created_by_full_name: Legal name of creator of the stream resource
        :param pulumi.Input[_builtins.str] created_date_time: Creation time of the stream resource
        :param pulumi.Input[_builtins.str] deleted_by: User name of deleter of the stream resource
        :param pulumi.Input[_builtins.str] deleted_by_email: Email of deleter of the stream resource
        :param pulumi.Input[_builtins.str] deleted_by_full_name: Legal name of deleter of the stream resource
        :param pulumi.Input[_builtins.str] deleted_date_time: Deletion time of the stream resource
        :param pulumi.Input[_builtins.str] updated_by: User name of last updater of the stream resource
        :param pulumi.Input[_builtins.str] updated_by_email: Email of last updater of the stream resource
        :param pulumi.Input[_builtins.str] updated_by_full_name: Legal name of last updater of the stream resource
        :param pulumi.Input[_builtins.str] updated_date_time: Last update time of the stream resource
        """
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if created_by_email is not None:
            pulumi.set(__self__, "created_by_email", created_by_email)
        if created_by_full_name is not None:
            pulumi.set(__self__, "created_by_full_name", created_by_full_name)
        if created_date_time is not None:
            pulumi.set(__self__, "created_date_time", created_date_time)
        if deleted_by is not None:
            pulumi.set(__self__, "deleted_by", deleted_by)
        if deleted_by_email is not None:
            pulumi.set(__self__, "deleted_by_email", deleted_by_email)
        if deleted_by_full_name is not None:
            pulumi.set(__self__, "deleted_by_full_name", deleted_by_full_name)
        if deleted_date_time is not None:
            pulumi.set(__self__, "deleted_date_time", deleted_date_time)
        if updated_by is not None:
            pulumi.set(__self__, "updated_by", updated_by)
        if updated_by_email is not None:
            pulumi.set(__self__, "updated_by_email", updated_by_email)
        if updated_by_full_name is not None:
            pulumi.set(__self__, "updated_by_full_name", updated_by_full_name)
        if updated_date_time is not None:
            pulumi.set(__self__, "updated_date_time", updated_date_time)

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        User name of creator of the stream resource
        """
        return pulumi.get(self, "created_by")

    @created_by.setter
    def created_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_by", value)

    @_builtins.property
    @pulumi.getter(name="createdByEmail")
    def created_by_email(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Email of creator of the stream resource
        """
        return pulumi.get(self, "created_by_email")

    @created_by_email.setter
    def created_by_email(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_by_email", value)

    @_builtins.property
    @pulumi.getter(name="createdByFullName")
    def created_by_full_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Legal name of creator of the stream resource
        """
        return pulumi.get(self, "created_by_full_name")

    @created_by_full_name.setter
    def created_by_full_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_by_full_name", value)

    @_builtins.property
    @pulumi.getter(name="createdDateTime")
    def created_date_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Creation time of the stream resource
        """
        return pulumi.get(self, "created_date_time")

    @created_date_time.setter
    def created_date_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_date_time", value)

    @_builtins.property
    @pulumi.getter(name="deletedBy")
    def deleted_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        User name of deleter of the stream resource
        """
        return pulumi.get(self, "deleted_by")

    @deleted_by.setter
    def deleted_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deleted_by", value)

    @_builtins.property
    @pulumi.getter(name="deletedByEmail")
    def deleted_by_email(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Email of deleter of the stream resource
        """
        return pulumi.get(self, "deleted_by_email")

    @deleted_by_email.setter
    def deleted_by_email(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deleted_by_email", value)

    @_builtins.property
    @pulumi.getter(name="deletedByFullName")
    def deleted_by_full_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Legal name of deleter of the stream resource
        """
        return pulumi.get(self, "deleted_by_full_name")

    @deleted_by_full_name.setter
    def deleted_by_full_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deleted_by_full_name", value)

    @_builtins.property
    @pulumi.getter(name="deletedDateTime")
    def deleted_date_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Deletion time of the stream resource
        """
        return pulumi.get(self, "deleted_date_time")

    @deleted_date_time.setter
    def deleted_date_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deleted_date_time", value)

    @_builtins.property
    @pulumi.getter(name="updatedBy")
    def updated_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        User name of last updater of the stream resource
        """
        return pulumi.get(self, "updated_by")

    @updated_by.setter
    def updated_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_by", value)

    @_builtins.property
    @pulumi.getter(name="updatedByEmail")
    def updated_by_email(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Email of last updater of the stream resource
        """
        return pulumi.get(self, "updated_by_email")

    @updated_by_email.setter
    def updated_by_email(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_by_email", value)

    @_builtins.property
    @pulumi.getter(name="updatedByFullName")
    def updated_by_full_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Legal name of last updater of the stream resource
        """
        return pulumi.get(self, "updated_by_full_name")

    @updated_by_full_name.setter
    def updated_by_full_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_by_full_name", value)

    @_builtins.property
    @pulumi.getter(name="updatedDateTime")
    def updated_date_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Last update time of the stream resource
        """
        return pulumi.get(self, "updated_date_time")

    @updated_date_time.setter
    def updated_date_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_date_time", value)


if not MYPY:
    class StreamSubscriptionEventSelectorArgsDict(TypedDict):
        includes: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        List of events to include
        """
        excepts: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of events to exclude
        """
elif False:
    StreamSubscriptionEventSelectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamSubscriptionEventSelectorArgs:
    def __init__(__self__, *,
                 includes: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 excepts: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] includes: List of events to include
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] excepts: List of events to exclude
        """
        pulumi.set(__self__, "includes", includes)
        if excepts is not None:
            pulumi.set(__self__, "excepts", excepts)

    @_builtins.property
    @pulumi.getter
    def includes(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List of events to include
        """
        return pulumi.get(self, "includes")

    @includes.setter
    def includes(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "includes", value)

    @_builtins.property
    @pulumi.getter
    def excepts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of events to exclude
        """
        return pulumi.get(self, "excepts")

    @excepts.setter
    def excepts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excepts", value)


if not MYPY:
    class StreamSubscriptionMetricSelectorArgsDict(TypedDict):
        includes: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        List of metrics to include
        """
        excepts: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of metrics to exclude
        """
elif False:
    StreamSubscriptionMetricSelectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamSubscriptionMetricSelectorArgs:
    def __init__(__self__, *,
                 includes: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 excepts: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] includes: List of metrics to include
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] excepts: List of metrics to exclude
        """
        pulumi.set(__self__, "includes", includes)
        if excepts is not None:
            pulumi.set(__self__, "excepts", excepts)

    @_builtins.property
    @pulumi.getter
    def includes(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List of metrics to include
        """
        return pulumi.get(self, "includes")

    @includes.setter
    def includes(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "includes", value)

    @_builtins.property
    @pulumi.getter
    def excepts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of metrics to exclude
        """
        return pulumi.get(self, "excepts")

    @excepts.setter
    def excepts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excepts", value)


if not MYPY:
    class StreamSubscriptionSinkArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Type of the subscriber
        """
        batch_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Boolean switch enabling batch delivery of data
        """
        batch_size_max: NotRequired[pulumi.Input[_builtins.int]]
        """
        Maximum size of the batch delivery if enabled
        """
        batch_wait_time_max: NotRequired[pulumi.Input[_builtins.int]]
        """
        Maximum time to wait for batch delivery if enabled
        """
        credential: NotRequired[pulumi.Input['StreamSubscriptionSinkCredentialArgsDict']]
        """
        Access details for the specified sink type
        """
        host: NotRequired[pulumi.Input[_builtins.str]]
        """
        Known hostname of certain data stream subscription products. Not to be confused with a variable URI
        """
        settings: NotRequired[pulumi.Input['StreamSubscriptionSinkSettingsArgsDict']]
        """
        Stream subscription sink settings
        """
        uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        Publicly reachable http endpoint destination for data stream
        """
elif False:
    StreamSubscriptionSinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamSubscriptionSinkArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 batch_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 batch_size_max: Optional[pulumi.Input[_builtins.int]] = None,
                 batch_wait_time_max: Optional[pulumi.Input[_builtins.int]] = None,
                 credential: Optional[pulumi.Input['StreamSubscriptionSinkCredentialArgs']] = None,
                 host: Optional[pulumi.Input[_builtins.str]] = None,
                 settings: Optional[pulumi.Input['StreamSubscriptionSinkSettingsArgs']] = None,
                 uri: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Type of the subscriber
        :param pulumi.Input[_builtins.bool] batch_enabled: Boolean switch enabling batch delivery of data
        :param pulumi.Input[_builtins.int] batch_size_max: Maximum size of the batch delivery if enabled
        :param pulumi.Input[_builtins.int] batch_wait_time_max: Maximum time to wait for batch delivery if enabled
        :param pulumi.Input['StreamSubscriptionSinkCredentialArgs'] credential: Access details for the specified sink type
        :param pulumi.Input[_builtins.str] host: Known hostname of certain data stream subscription products. Not to be confused with a variable URI
        :param pulumi.Input['StreamSubscriptionSinkSettingsArgs'] settings: Stream subscription sink settings
        :param pulumi.Input[_builtins.str] uri: Publicly reachable http endpoint destination for data stream
        """
        pulumi.set(__self__, "type", type)
        if batch_enabled is not None:
            pulumi.set(__self__, "batch_enabled", batch_enabled)
        if batch_size_max is not None:
            pulumi.set(__self__, "batch_size_max", batch_size_max)
        if batch_wait_time_max is not None:
            pulumi.set(__self__, "batch_wait_time_max", batch_wait_time_max)
        if credential is not None:
            pulumi.set(__self__, "credential", credential)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Type of the subscriber
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="batchEnabled")
    def batch_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Boolean switch enabling batch delivery of data
        """
        return pulumi.get(self, "batch_enabled")

    @batch_enabled.setter
    def batch_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "batch_enabled", value)

    @_builtins.property
    @pulumi.getter(name="batchSizeMax")
    def batch_size_max(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximum size of the batch delivery if enabled
        """
        return pulumi.get(self, "batch_size_max")

    @batch_size_max.setter
    def batch_size_max(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "batch_size_max", value)

    @_builtins.property
    @pulumi.getter(name="batchWaitTimeMax")
    def batch_wait_time_max(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximum time to wait for batch delivery if enabled
        """
        return pulumi.get(self, "batch_wait_time_max")

    @batch_wait_time_max.setter
    def batch_wait_time_max(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "batch_wait_time_max", value)

    @_builtins.property
    @pulumi.getter
    def credential(self) -> Optional[pulumi.Input['StreamSubscriptionSinkCredentialArgs']]:
        """
        Access details for the specified sink type
        """
        return pulumi.get(self, "credential")

    @credential.setter
    def credential(self, value: Optional[pulumi.Input['StreamSubscriptionSinkCredentialArgs']]):
        pulumi.set(self, "credential", value)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Known hostname of certain data stream subscription products. Not to be confused with a variable URI
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input['StreamSubscriptionSinkSettingsArgs']]:
        """
        Stream subscription sink settings
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input['StreamSubscriptionSinkSettingsArgs']]):
        pulumi.set(self, "settings", value)

    @_builtins.property
    @pulumi.getter
    def uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Publicly reachable http endpoint destination for data stream
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uri", value)


if not MYPY:
    class StreamSubscriptionSinkCredentialArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Type of the credential being passed
        """
        access_token: NotRequired[pulumi.Input[_builtins.str]]
        """
        Passed as Authorization header value
        """
        api_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Passed as Authorization header value
        """
        integration_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Passed as Authorization header value
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        Passed as Authorization header value
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        Passed as Authorization header value
        """
elif False:
    StreamSubscriptionSinkCredentialArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamSubscriptionSinkCredentialArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 access_token: Optional[pulumi.Input[_builtins.str]] = None,
                 api_key: Optional[pulumi.Input[_builtins.str]] = None,
                 integration_key: Optional[pulumi.Input[_builtins.str]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Type of the credential being passed
        :param pulumi.Input[_builtins.str] access_token: Passed as Authorization header value
        :param pulumi.Input[_builtins.str] api_key: Passed as Authorization header value
        :param pulumi.Input[_builtins.str] integration_key: Passed as Authorization header value
        :param pulumi.Input[_builtins.str] password: Passed as Authorization header value
        :param pulumi.Input[_builtins.str] username: Passed as Authorization header value
        """
        pulumi.set(__self__, "type", type)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if integration_key is not None:
            pulumi.set(__self__, "integration_key", integration_key)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Type of the credential being passed
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Passed as Authorization header value
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_token", value)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Passed as Authorization header value
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "api_key", value)

    @_builtins.property
    @pulumi.getter(name="integrationKey")
    def integration_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Passed as Authorization header value
        """
        return pulumi.get(self, "integration_key")

    @integration_key.setter
    def integration_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "integration_key", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Passed as Authorization header value
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Passed as Authorization header value
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class StreamSubscriptionSinkSettingsArgsDict(TypedDict):
        application_key: NotRequired[pulumi.Input[_builtins.str]]
        event_index: NotRequired[pulumi.Input[_builtins.str]]
        event_uri: NotRequired[pulumi.Input[_builtins.str]]
        format: NotRequired[pulumi.Input[_builtins.str]]
        metric_index: NotRequired[pulumi.Input[_builtins.str]]
        metric_uri: NotRequired[pulumi.Input[_builtins.str]]
        source: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    StreamSubscriptionSinkSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamSubscriptionSinkSettingsArgs:
    def __init__(__self__, *,
                 application_key: Optional[pulumi.Input[_builtins.str]] = None,
                 event_index: Optional[pulumi.Input[_builtins.str]] = None,
                 event_uri: Optional[pulumi.Input[_builtins.str]] = None,
                 format: Optional[pulumi.Input[_builtins.str]] = None,
                 metric_index: Optional[pulumi.Input[_builtins.str]] = None,
                 metric_uri: Optional[pulumi.Input[_builtins.str]] = None,
                 source: Optional[pulumi.Input[_builtins.str]] = None):
        if application_key is not None:
            pulumi.set(__self__, "application_key", application_key)
        if event_index is not None:
            pulumi.set(__self__, "event_index", event_index)
        if event_uri is not None:
            pulumi.set(__self__, "event_uri", event_uri)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if metric_index is not None:
            pulumi.set(__self__, "metric_index", metric_index)
        if metric_uri is not None:
            pulumi.set(__self__, "metric_uri", metric_uri)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter(name="applicationKey")
    def application_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "application_key")

    @application_key.setter
    def application_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "application_key", value)

    @_builtins.property
    @pulumi.getter(name="eventIndex")
    def event_index(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "event_index")

    @event_index.setter
    def event_index(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "event_index", value)

    @_builtins.property
    @pulumi.getter(name="eventUri")
    def event_uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "event_uri")

    @event_uri.setter
    def event_uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "event_uri", value)

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "format", value)

    @_builtins.property
    @pulumi.getter(name="metricIndex")
    def metric_index(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "metric_index")

    @metric_index.setter
    def metric_index(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metric_index", value)

    @_builtins.property
    @pulumi.getter(name="metricUri")
    def metric_uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "metric_uri")

    @metric_uri.setter
    def metric_uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metric_uri", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source", value)


if not MYPY:
    class StreamSubscriptionTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        read: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    StreamSubscriptionTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamSubscriptionTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 read: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if read is not None:
            pulumi.set(__self__, "read", read)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def read(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @read.setter
    def read(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "read", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class StreamTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        read: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    StreamTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 read: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if read is not None:
            pulumi.set(__self__, "read", read)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def read(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @read.setter
    def read(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "read", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class GetCloudRoutersFilterArgsDict(TypedDict):
        operator: _builtins.str
        """
        Possible operators to use on the filter property. Can be one of the following: [= - equal, != - not equal, > - greater than, >= - greater than or equal to, < - less than, <= - less than or equal to, [NOT] BETWEEN - (not) between, [NOT] LIKE - (not) like, [NOT] IN - (not) in
        """
        property: _builtins.str
        """
        The API response property which you want to filter your request on. Can be one of the following: "/project/projectId", "/name", "/uuid", "/state", "/location/metroCode", "/location/metroName", "/package/code", "/*"
        """
        values: Sequence[_builtins.str]
        """
        The values that you want to apply the property+operator combination to in order to filter your data search
        """
        or_: NotRequired[_builtins.bool]
        """
        Boolean flag indicating whether this filter is included in the OR group. There can only be one OR group and it can have a maximum of 3 filters. The OR group only counts as 1 of the 8 possible filters
        """
elif False:
    GetCloudRoutersFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudRoutersFilterArgs:
    def __init__(__self__, *,
                 operator: _builtins.str,
                 property: _builtins.str,
                 values: Sequence[_builtins.str],
                 or_: Optional[_builtins.bool] = None):
        """
        :param _builtins.str operator: Possible operators to use on the filter property. Can be one of the following: [= - equal, != - not equal, > - greater than, >= - greater than or equal to, < - less than, <= - less than or equal to, [NOT] BETWEEN - (not) between, [NOT] LIKE - (not) like, [NOT] IN - (not) in
        :param _builtins.str property: The API response property which you want to filter your request on. Can be one of the following: "/project/projectId", "/name", "/uuid", "/state", "/location/metroCode", "/location/metroName", "/package/code", "/*"
        :param Sequence[_builtins.str] values: The values that you want to apply the property+operator combination to in order to filter your data search
        :param _builtins.bool or_: Boolean flag indicating whether this filter is included in the OR group. There can only be one OR group and it can have a maximum of 3 filters. The OR group only counts as 1 of the 8 possible filters
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "property", property)
        pulumi.set(__self__, "values", values)
        if or_ is not None:
            pulumi.set(__self__, "or_", or_)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        Possible operators to use on the filter property. Can be one of the following: [= - equal, != - not equal, > - greater than, >= - greater than or equal to, < - less than, <= - less than or equal to, [NOT] BETWEEN - (not) between, [NOT] LIKE - (not) like, [NOT] IN - (not) in
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: _builtins.str):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def property(self) -> _builtins.str:
        """
        The API response property which you want to filter your request on. Can be one of the following: "/project/projectId", "/name", "/uuid", "/state", "/location/metroCode", "/location/metroName", "/package/code", "/*"
        """
        return pulumi.get(self, "property")

    @property.setter
    def property(self, value: _builtins.str):
        pulumi.set(self, "property", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        The values that you want to apply the property+operator combination to in order to filter your data search
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter(name="or")
    def or_(self) -> Optional[_builtins.bool]:
        """
        Boolean flag indicating whether this filter is included in the OR group. There can only be one OR group and it can have a maximum of 3 filters. The OR group only counts as 1 of the 8 possible filters
        """
        return pulumi.get(self, "or_")

    @or_.setter
    def or_(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "or_", value)


if not MYPY:
    class GetCloudRoutersPaginationArgsDict(TypedDict):
        limit: NotRequired[_builtins.int]
        """
        Number of elements to be requested per page. Number must be between 1 and 100. Default is 20
        """
        offset: NotRequired[_builtins.int]
        """
        The page offset for the pagination request. Index of the first element. Default is 0.
        """
elif False:
    GetCloudRoutersPaginationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudRoutersPaginationArgs:
    def __init__(__self__, *,
                 limit: Optional[_builtins.int] = None,
                 offset: Optional[_builtins.int] = None):
        """
        :param _builtins.int limit: Number of elements to be requested per page. Number must be between 1 and 100. Default is 20
        :param _builtins.int offset: The page offset for the pagination request. Index of the first element. Default is 0.
        """
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if offset is not None:
            pulumi.set(__self__, "offset", offset)

    @_builtins.property
    @pulumi.getter
    def limit(self) -> Optional[_builtins.int]:
        """
        Number of elements to be requested per page. Number must be between 1 and 100. Default is 20
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[_builtins.int]):
        pulumi.set(self, "limit", value)

    @_builtins.property
    @pulumi.getter
    def offset(self) -> Optional[_builtins.int]:
        """
        The page offset for the pagination request. Index of the first element. Default is 0.
        """
        return pulumi.get(self, "offset")

    @offset.setter
    def offset(self, value: Optional[_builtins.int]):
        pulumi.set(self, "offset", value)


if not MYPY:
    class GetCloudRoutersSortArgsDict(TypedDict):
        direction: NotRequired[_builtins.str]
        """
        The sorting direction. Can be one of: [DESC, ASC], Defaults to DESC
        """
        property: NotRequired[_builtins.str]
        """
        The property name to use in sorting. Can be one of the following: [/name, /uuid, /state, /location/metroCode, /location/metroName, /package/code, /changeLog/createdDateTime, /changeLog/updatedDateTime], Defaults to /changeLog/updatedDateTime
        """
elif False:
    GetCloudRoutersSortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudRoutersSortArgs:
    def __init__(__self__, *,
                 direction: Optional[_builtins.str] = None,
                 property: Optional[_builtins.str] = None):
        """
        :param _builtins.str direction: The sorting direction. Can be one of: [DESC, ASC], Defaults to DESC
        :param _builtins.str property: The property name to use in sorting. Can be one of the following: [/name, /uuid, /state, /location/metroCode, /location/metroName, /package/code, /changeLog/createdDateTime, /changeLog/updatedDateTime], Defaults to /changeLog/updatedDateTime
        """
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if property is not None:
            pulumi.set(__self__, "property", property)

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        """
        The sorting direction. Can be one of: [DESC, ASC], Defaults to DESC
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[_builtins.str]):
        pulumi.set(self, "direction", value)

    @_builtins.property
    @pulumi.getter
    def property(self) -> Optional[_builtins.str]:
        """
        The property name to use in sorting. Can be one of the following: [/name, /uuid, /state, /location/metroCode, /location/metroName, /package/code, /changeLog/createdDateTime, /changeLog/updatedDateTime], Defaults to /changeLog/updatedDateTime
        """
        return pulumi.get(self, "property")

    @property.setter
    def property(self, value: Optional[_builtins.str]):
        pulumi.set(self, "property", value)


if not MYPY:
    class GetConnectionRouteAggregationsPaginationArgsDict(TypedDict):
        limit: _builtins.int
        """
        Maximum number of search results returned per page. Number must be between 1 and 100, and the default is 20
        """
        next: _builtins.str
        """
        The URL relative to the next item in the response
        """
        offset: _builtins.int
        """
        Index of the first item returned in the response. The default is 0
        """
        previous: _builtins.str
        """
        The URL relative to the previous item in the response
        """
        total: _builtins.int
        """
        The total number of connection route aggregations available to the user making the request
        """
elif False:
    GetConnectionRouteAggregationsPaginationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetConnectionRouteAggregationsPaginationArgs:
    def __init__(__self__, *,
                 limit: _builtins.int,
                 next: _builtins.str,
                 offset: _builtins.int,
                 previous: _builtins.str,
                 total: _builtins.int):
        """
        :param _builtins.int limit: Maximum number of search results returned per page. Number must be between 1 and 100, and the default is 20
        :param _builtins.str next: The URL relative to the next item in the response
        :param _builtins.int offset: Index of the first item returned in the response. The default is 0
        :param _builtins.str previous: The URL relative to the previous item in the response
        :param _builtins.int total: The total number of connection route aggregations available to the user making the request
        """
        pulumi.set(__self__, "limit", limit)
        pulumi.set(__self__, "next", next)
        pulumi.set(__self__, "offset", offset)
        pulumi.set(__self__, "previous", previous)
        pulumi.set(__self__, "total", total)

    @_builtins.property
    @pulumi.getter
    def limit(self) -> _builtins.int:
        """
        Maximum number of search results returned per page. Number must be between 1 and 100, and the default is 20
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: _builtins.int):
        pulumi.set(self, "limit", value)

    @_builtins.property
    @pulumi.getter
    def next(self) -> _builtins.str:
        """
        The URL relative to the next item in the response
        """
        return pulumi.get(self, "next")

    @next.setter
    def next(self, value: _builtins.str):
        pulumi.set(self, "next", value)

    @_builtins.property
    @pulumi.getter
    def offset(self) -> _builtins.int:
        """
        Index of the first item returned in the response. The default is 0
        """
        return pulumi.get(self, "offset")

    @offset.setter
    def offset(self, value: _builtins.int):
        pulumi.set(self, "offset", value)

    @_builtins.property
    @pulumi.getter
    def previous(self) -> _builtins.str:
        """
        The URL relative to the previous item in the response
        """
        return pulumi.get(self, "previous")

    @previous.setter
    def previous(self, value: _builtins.str):
        pulumi.set(self, "previous", value)

    @_builtins.property
    @pulumi.getter
    def total(self) -> _builtins.int:
        """
        The total number of connection route aggregations available to the user making the request
        """
        return pulumi.get(self, "total")

    @total.setter
    def total(self, value: _builtins.int):
        pulumi.set(self, "total", value)


if not MYPY:
    class GetConnectionsFilterArgsDict(TypedDict):
        operator: _builtins.str
        """
        Operators to use on your filtered field with the values given. One of [ =, !=, >, >=, <, <=, BETWEEN, NOT BETWEEN, LIKE, NOT LIKE, IN, NOT IN, IS NOT NULL, IS NULL]
        """
        property: _builtins.str
        """
        Possible field names to use on filters. One of [/isRemote /name /uuid /type /geoScope /account/orgId /aSide/accessPoint/account/accountName /aSide/accessPoint/account/accountNumber /aSide/accessPoint/router/uuid /aSide/accessPoint/linkProtocol/vlanCTag /aSide/accessPoint/linkProtocol/vlanSTag /aSide/accessPoint/linkProtocol/vlanTagMin /aSide/accessPoint/linkProtocol/vlanTagMax /aSide/accessPoint/location/metroCode /aSide/accessPoint/location/metroName /aSide/accessPoint/name /aSide/accessPoint/port/uuid /aSide/accessPoint/port/name /aSide/accessPoint/type /aSide/accessPoint/virtualDevice/name /aSide/accessPoint/virtualDevice/uuid /aSide/serviceToken/uuid /change/status /operation/equinixStatus /operation/providerStatus /project/projectId /redundancy/group /redundancy/priority /zSide/accessPoint/account/accountName /zSide/accessPoint/authenticationKey /zSide/accessPoint/linkProtocol/vlanCTag /zSide/accessPoint/linkProtocol/vlanSTag /zSide/accessPoint/linkProtocol/vlanTagMin /zSide/accessPoint/linkProtocol/vlanTagMax /zSide/accessPoint/location/metroCode /zSide/accessPoint/location/metroName /zSide/accessPoint/name /zSide/accessPoint/port/uuid /zSide/accessPoint/network/uuid /zSide/accessPoint/port/name /zSide/accessPoint/profile/uuid /zSide/accessPoint/type /zSide/accessPoint/role /zSide/accessPoint/virtualDevice/name /zSide/accessPoint/virtualDevice/uuid /zSide/serviceToken/uuid /zSide/internetAccess/uuid *]
        """
        values: Sequence[_builtins.str]
        """
        The values that you want to apply the property+operator combination to in order to filter your data search
        """
        group: NotRequired[_builtins.str]
        """
        Optional custom id parameter to assign this filter to an inner AND or OR group. Group id must be prefixed with AND_ or OR_. Ensure intended grouped elements have the same given id. Ungrouped filters will be placed in the filter list group by themselves.
        """
elif False:
    GetConnectionsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetConnectionsFilterArgs:
    def __init__(__self__, *,
                 operator: _builtins.str,
                 property: _builtins.str,
                 values: Sequence[_builtins.str],
                 group: Optional[_builtins.str] = None):
        """
        :param _builtins.str operator: Operators to use on your filtered field with the values given. One of [ =, !=, >, >=, <, <=, BETWEEN, NOT BETWEEN, LIKE, NOT LIKE, IN, NOT IN, IS NOT NULL, IS NULL]
        :param _builtins.str property: Possible field names to use on filters. One of [/isRemote /name /uuid /type /geoScope /account/orgId /aSide/accessPoint/account/accountName /aSide/accessPoint/account/accountNumber /aSide/accessPoint/router/uuid /aSide/accessPoint/linkProtocol/vlanCTag /aSide/accessPoint/linkProtocol/vlanSTag /aSide/accessPoint/linkProtocol/vlanTagMin /aSide/accessPoint/linkProtocol/vlanTagMax /aSide/accessPoint/location/metroCode /aSide/accessPoint/location/metroName /aSide/accessPoint/name /aSide/accessPoint/port/uuid /aSide/accessPoint/port/name /aSide/accessPoint/type /aSide/accessPoint/virtualDevice/name /aSide/accessPoint/virtualDevice/uuid /aSide/serviceToken/uuid /change/status /operation/equinixStatus /operation/providerStatus /project/projectId /redundancy/group /redundancy/priority /zSide/accessPoint/account/accountName /zSide/accessPoint/authenticationKey /zSide/accessPoint/linkProtocol/vlanCTag /zSide/accessPoint/linkProtocol/vlanSTag /zSide/accessPoint/linkProtocol/vlanTagMin /zSide/accessPoint/linkProtocol/vlanTagMax /zSide/accessPoint/location/metroCode /zSide/accessPoint/location/metroName /zSide/accessPoint/name /zSide/accessPoint/port/uuid /zSide/accessPoint/network/uuid /zSide/accessPoint/port/name /zSide/accessPoint/profile/uuid /zSide/accessPoint/type /zSide/accessPoint/role /zSide/accessPoint/virtualDevice/name /zSide/accessPoint/virtualDevice/uuid /zSide/serviceToken/uuid /zSide/internetAccess/uuid *]
        :param Sequence[_builtins.str] values: The values that you want to apply the property+operator combination to in order to filter your data search
        :param _builtins.str group: Optional custom id parameter to assign this filter to an inner AND or OR group. Group id must be prefixed with AND_ or OR_. Ensure intended grouped elements have the same given id. Ungrouped filters will be placed in the filter list group by themselves.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "property", property)
        pulumi.set(__self__, "values", values)
        if group is not None:
            pulumi.set(__self__, "group", group)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        Operators to use on your filtered field with the values given. One of [ =, !=, >, >=, <, <=, BETWEEN, NOT BETWEEN, LIKE, NOT LIKE, IN, NOT IN, IS NOT NULL, IS NULL]
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: _builtins.str):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def property(self) -> _builtins.str:
        """
        Possible field names to use on filters. One of [/isRemote /name /uuid /type /geoScope /account/orgId /aSide/accessPoint/account/accountName /aSide/accessPoint/account/accountNumber /aSide/accessPoint/router/uuid /aSide/accessPoint/linkProtocol/vlanCTag /aSide/accessPoint/linkProtocol/vlanSTag /aSide/accessPoint/linkProtocol/vlanTagMin /aSide/accessPoint/linkProtocol/vlanTagMax /aSide/accessPoint/location/metroCode /aSide/accessPoint/location/metroName /aSide/accessPoint/name /aSide/accessPoint/port/uuid /aSide/accessPoint/port/name /aSide/accessPoint/type /aSide/accessPoint/virtualDevice/name /aSide/accessPoint/virtualDevice/uuid /aSide/serviceToken/uuid /change/status /operation/equinixStatus /operation/providerStatus /project/projectId /redundancy/group /redundancy/priority /zSide/accessPoint/account/accountName /zSide/accessPoint/authenticationKey /zSide/accessPoint/linkProtocol/vlanCTag /zSide/accessPoint/linkProtocol/vlanSTag /zSide/accessPoint/linkProtocol/vlanTagMin /zSide/accessPoint/linkProtocol/vlanTagMax /zSide/accessPoint/location/metroCode /zSide/accessPoint/location/metroName /zSide/accessPoint/name /zSide/accessPoint/port/uuid /zSide/accessPoint/network/uuid /zSide/accessPoint/port/name /zSide/accessPoint/profile/uuid /zSide/accessPoint/type /zSide/accessPoint/role /zSide/accessPoint/virtualDevice/name /zSide/accessPoint/virtualDevice/uuid /zSide/serviceToken/uuid /zSide/internetAccess/uuid *]
        """
        return pulumi.get(self, "property")

    @property.setter
    def property(self, value: _builtins.str):
        pulumi.set(self, "property", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        The values that you want to apply the property+operator combination to in order to filter your data search
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def group(self) -> Optional[_builtins.str]:
        """
        Optional custom id parameter to assign this filter to an inner AND or OR group. Group id must be prefixed with AND_ or OR_. Ensure intended grouped elements have the same given id. Ungrouped filters will be placed in the filter list group by themselves.
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[_builtins.str]):
        pulumi.set(self, "group", value)


if not MYPY:
    class GetConnectionsPaginationArgsDict(TypedDict):
        limit: NotRequired[_builtins.int]
        """
        Number of elements to be requested per page. Number must be between 1 and 100. Default is 20
        """
        offset: NotRequired[_builtins.int]
        """
        The page offset for the pagination request. Index of the first element. Default is 0.
        """
elif False:
    GetConnectionsPaginationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetConnectionsPaginationArgs:
    def __init__(__self__, *,
                 limit: Optional[_builtins.int] = None,
                 offset: Optional[_builtins.int] = None):
        """
        :param _builtins.int limit: Number of elements to be requested per page. Number must be between 1 and 100. Default is 20
        :param _builtins.int offset: The page offset for the pagination request. Index of the first element. Default is 0.
        """
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if offset is not None:
            pulumi.set(__self__, "offset", offset)

    @_builtins.property
    @pulumi.getter
    def limit(self) -> Optional[_builtins.int]:
        """
        Number of elements to be requested per page. Number must be between 1 and 100. Default is 20
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[_builtins.int]):
        pulumi.set(self, "limit", value)

    @_builtins.property
    @pulumi.getter
    def offset(self) -> Optional[_builtins.int]:
        """
        The page offset for the pagination request. Index of the first element. Default is 0.
        """
        return pulumi.get(self, "offset")

    @offset.setter
    def offset(self, value: Optional[_builtins.int]):
        pulumi.set(self, "offset", value)


if not MYPY:
    class GetConnectionsSortArgsDict(TypedDict):
        direction: NotRequired[_builtins.str]
        """
        The sorting direction. Can be one of: [DESC, ASC], Defaults to DESC
        """
        property: NotRequired[_builtins.str]
        """
        The property name to use in sorting. One of [/name /direction /aSide/accessPoint/name /aSide/accessPoint/type /aSide/accessPoint/account/accountName /aSide/accessPoint/location/metroName /aSide/accessPoint/location/metroCode /aSide/accessPoint/linkProtocol/vlanCTag /aSide/accessPoint/linkProtocol/vlanSTag /zSide/accessPoint/name /zSide/accessPoint/type /zSide/accessPoint/role /zSide/accessPoint/account/accountName /zSide/accessPoint/location/metroName /zSide/accessPoint/location/metroCode /zSide/accessPoint/linkProtocol/vlanCTag /zSide/accessPoint/linkProtocol/vlanSTag /zSide/accessPoint/authenticationKey /bandwidth /geoScope /uuid /changeLog/createdDateTime /changeLog/updatedDateTime /operation/equinixStatus /operation/providerStatus /redundancy/priority]. Defaults to /changeLog/updatedDateTime
        """
elif False:
    GetConnectionsSortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetConnectionsSortArgs:
    def __init__(__self__, *,
                 direction: Optional[_builtins.str] = None,
                 property: Optional[_builtins.str] = None):
        """
        :param _builtins.str direction: The sorting direction. Can be one of: [DESC, ASC], Defaults to DESC
        :param _builtins.str property: The property name to use in sorting. One of [/name /direction /aSide/accessPoint/name /aSide/accessPoint/type /aSide/accessPoint/account/accountName /aSide/accessPoint/location/metroName /aSide/accessPoint/location/metroCode /aSide/accessPoint/linkProtocol/vlanCTag /aSide/accessPoint/linkProtocol/vlanSTag /zSide/accessPoint/name /zSide/accessPoint/type /zSide/accessPoint/role /zSide/accessPoint/account/accountName /zSide/accessPoint/location/metroName /zSide/accessPoint/location/metroCode /zSide/accessPoint/linkProtocol/vlanCTag /zSide/accessPoint/linkProtocol/vlanSTag /zSide/accessPoint/authenticationKey /bandwidth /geoScope /uuid /changeLog/createdDateTime /changeLog/updatedDateTime /operation/equinixStatus /operation/providerStatus /redundancy/priority]. Defaults to /changeLog/updatedDateTime
        """
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if property is not None:
            pulumi.set(__self__, "property", property)

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        """
        The sorting direction. Can be one of: [DESC, ASC], Defaults to DESC
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[_builtins.str]):
        pulumi.set(self, "direction", value)

    @_builtins.property
    @pulumi.getter
    def property(self) -> Optional[_builtins.str]:
        """
        The property name to use in sorting. One of [/name /direction /aSide/accessPoint/name /aSide/accessPoint/type /aSide/accessPoint/account/accountName /aSide/accessPoint/location/metroName /aSide/accessPoint/location/metroCode /aSide/accessPoint/linkProtocol/vlanCTag /aSide/accessPoint/linkProtocol/vlanSTag /zSide/accessPoint/name /zSide/accessPoint/type /zSide/accessPoint/role /zSide/accessPoint/account/accountName /zSide/accessPoint/location/metroName /zSide/accessPoint/location/metroCode /zSide/accessPoint/linkProtocol/vlanCTag /zSide/accessPoint/linkProtocol/vlanSTag /zSide/accessPoint/authenticationKey /bandwidth /geoScope /uuid /changeLog/createdDateTime /changeLog/updatedDateTime /operation/equinixStatus /operation/providerStatus /redundancy/priority]. Defaults to /changeLog/updatedDateTime
        """
        return pulumi.get(self, "property")

    @property.setter
    def property(self, value: Optional[_builtins.str]):
        pulumi.set(self, "property", value)


if not MYPY:
    class GetMetrosPaginationArgsDict(TypedDict):
        next: _builtins.str
        """
        URL relative to the next item in the response.
        """
        previous: _builtins.str
        """
        URL relative to the previous item in the response.
        """
        total: _builtins.int
        """
        The total number of metro returned
        """
        limit: NotRequired[_builtins.int]
        """
        Maximum number of search results returned per page.
        """
        offset: NotRequired[_builtins.int]
        """
        Index of the first item returned in the response.
        """
elif False:
    GetMetrosPaginationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMetrosPaginationArgs:
    def __init__(__self__, *,
                 next: _builtins.str,
                 previous: _builtins.str,
                 total: _builtins.int,
                 limit: Optional[_builtins.int] = None,
                 offset: Optional[_builtins.int] = None):
        """
        :param _builtins.str next: URL relative to the next item in the response.
        :param _builtins.str previous: URL relative to the previous item in the response.
        :param _builtins.int total: The total number of metro returned
        :param _builtins.int limit: Maximum number of search results returned per page.
        :param _builtins.int offset: Index of the first item returned in the response.
        """
        pulumi.set(__self__, "next", next)
        pulumi.set(__self__, "previous", previous)
        pulumi.set(__self__, "total", total)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if offset is not None:
            pulumi.set(__self__, "offset", offset)

    @_builtins.property
    @pulumi.getter
    def next(self) -> _builtins.str:
        """
        URL relative to the next item in the response.
        """
        return pulumi.get(self, "next")

    @next.setter
    def next(self, value: _builtins.str):
        pulumi.set(self, "next", value)

    @_builtins.property
    @pulumi.getter
    def previous(self) -> _builtins.str:
        """
        URL relative to the previous item in the response.
        """
        return pulumi.get(self, "previous")

    @previous.setter
    def previous(self, value: _builtins.str):
        pulumi.set(self, "previous", value)

    @_builtins.property
    @pulumi.getter
    def total(self) -> _builtins.int:
        """
        The total number of metro returned
        """
        return pulumi.get(self, "total")

    @total.setter
    def total(self, value: _builtins.int):
        pulumi.set(self, "total", value)

    @_builtins.property
    @pulumi.getter
    def limit(self) -> Optional[_builtins.int]:
        """
        Maximum number of search results returned per page.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[_builtins.int]):
        pulumi.set(self, "limit", value)

    @_builtins.property
    @pulumi.getter
    def offset(self) -> Optional[_builtins.int]:
        """
        Index of the first item returned in the response.
        """
        return pulumi.get(self, "offset")

    @offset.setter
    def offset(self, value: Optional[_builtins.int]):
        pulumi.set(self, "offset", value)


if not MYPY:
    class GetNetworksFilterArgsDict(TypedDict):
        operator: _builtins.str
        """
        Operators to use on your filtered field with the values given. One of [ =, !=, >, >=, <, <=, BETWEEN, NOT BETWEEN, LIKE, NOT LIKE, ILIKE, NOT ILIKE, IN, NOT IN]
        """
        property: _builtins.str
        """
        Possible field names to use on filters. One of [/name /uuid /scope /type /operation/equinixStatus /location/region /project/projectId /account/globalCustId /account/orgId /deletedDate /_*]
        """
        values: Sequence[_builtins.str]
        """
        The values that you want to apply the property+operator combination to in order to filter your data search
        """
        group: NotRequired[_builtins.str]
        """
        Optional custom id parameter to assign this filter to an inner AND or OR group. Group id must be prefixed with AND_ or OR_. Ensure intended grouped elements have the same given id. Ungrouped filters will be placed in the filter list group by themselves.
        """
elif False:
    GetNetworksFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetNetworksFilterArgs:
    def __init__(__self__, *,
                 operator: _builtins.str,
                 property: _builtins.str,
                 values: Sequence[_builtins.str],
                 group: Optional[_builtins.str] = None):
        """
        :param _builtins.str operator: Operators to use on your filtered field with the values given. One of [ =, !=, >, >=, <, <=, BETWEEN, NOT BETWEEN, LIKE, NOT LIKE, ILIKE, NOT ILIKE, IN, NOT IN]
        :param _builtins.str property: Possible field names to use on filters. One of [/name /uuid /scope /type /operation/equinixStatus /location/region /project/projectId /account/globalCustId /account/orgId /deletedDate /_*]
        :param Sequence[_builtins.str] values: The values that you want to apply the property+operator combination to in order to filter your data search
        :param _builtins.str group: Optional custom id parameter to assign this filter to an inner AND or OR group. Group id must be prefixed with AND_ or OR_. Ensure intended grouped elements have the same given id. Ungrouped filters will be placed in the filter list group by themselves.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "property", property)
        pulumi.set(__self__, "values", values)
        if group is not None:
            pulumi.set(__self__, "group", group)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        Operators to use on your filtered field with the values given. One of [ =, !=, >, >=, <, <=, BETWEEN, NOT BETWEEN, LIKE, NOT LIKE, ILIKE, NOT ILIKE, IN, NOT IN]
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: _builtins.str):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def property(self) -> _builtins.str:
        """
        Possible field names to use on filters. One of [/name /uuid /scope /type /operation/equinixStatus /location/region /project/projectId /account/globalCustId /account/orgId /deletedDate /_*]
        """
        return pulumi.get(self, "property")

    @property.setter
    def property(self, value: _builtins.str):
        pulumi.set(self, "property", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        The values that you want to apply the property+operator combination to in order to filter your data search
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def group(self) -> Optional[_builtins.str]:
        """
        Optional custom id parameter to assign this filter to an inner AND or OR group. Group id must be prefixed with AND_ or OR_. Ensure intended grouped elements have the same given id. Ungrouped filters will be placed in the filter list group by themselves.
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[_builtins.str]):
        pulumi.set(self, "group", value)


if not MYPY:
    class GetNetworksPaginationArgsDict(TypedDict):
        limit: NotRequired[_builtins.int]
        """
        Number of elements to be requested per page. Number must be between 1 and 100. Default is 20
        """
        offset: NotRequired[_builtins.int]
        """
        The page offset for the pagination request. Index of the first element. Default is 0.
        """
elif False:
    GetNetworksPaginationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetNetworksPaginationArgs:
    def __init__(__self__, *,
                 limit: Optional[_builtins.int] = None,
                 offset: Optional[_builtins.int] = None):
        """
        :param _builtins.int limit: Number of elements to be requested per page. Number must be between 1 and 100. Default is 20
        :param _builtins.int offset: The page offset for the pagination request. Index of the first element. Default is 0.
        """
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if offset is not None:
            pulumi.set(__self__, "offset", offset)

    @_builtins.property
    @pulumi.getter
    def limit(self) -> Optional[_builtins.int]:
        """
        Number of elements to be requested per page. Number must be between 1 and 100. Default is 20
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[_builtins.int]):
        pulumi.set(self, "limit", value)

    @_builtins.property
    @pulumi.getter
    def offset(self) -> Optional[_builtins.int]:
        """
        The page offset for the pagination request. Index of the first element. Default is 0.
        """
        return pulumi.get(self, "offset")

    @offset.setter
    def offset(self, value: Optional[_builtins.int]):
        pulumi.set(self, "offset", value)


if not MYPY:
    class GetNetworksSortArgsDict(TypedDict):
        direction: NotRequired[_builtins.str]
        """
        The sorting direction. Can be one of: [DESC, ASC], Defaults to DESC
        """
        property: NotRequired[_builtins.str]
        """
        The property name to use in sorting. One of [/name /uuid /scope /operation/equinixStatus /location/region /changeLog/createdDateTime /changeLog/updatedDateTime]. Defaults to /changeLog/updatedDateTime
        """
elif False:
    GetNetworksSortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetNetworksSortArgs:
    def __init__(__self__, *,
                 direction: Optional[_builtins.str] = None,
                 property: Optional[_builtins.str] = None):
        """
        :param _builtins.str direction: The sorting direction. Can be one of: [DESC, ASC], Defaults to DESC
        :param _builtins.str property: The property name to use in sorting. One of [/name /uuid /scope /operation/equinixStatus /location/region /changeLog/createdDateTime /changeLog/updatedDateTime]. Defaults to /changeLog/updatedDateTime
        """
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if property is not None:
            pulumi.set(__self__, "property", property)

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        """
        The sorting direction. Can be one of: [DESC, ASC], Defaults to DESC
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[_builtins.str]):
        pulumi.set(self, "direction", value)

    @_builtins.property
    @pulumi.getter
    def property(self) -> Optional[_builtins.str]:
        """
        The property name to use in sorting. One of [/name /uuid /scope /operation/equinixStatus /location/region /changeLog/createdDateTime /changeLog/updatedDateTime]. Defaults to /changeLog/updatedDateTime
        """
        return pulumi.get(self, "property")

    @property.setter
    def property(self, value: Optional[_builtins.str]):
        pulumi.set(self, "property", value)


if not MYPY:
    class GetPortsFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        Query Parameter to Get Ports By Name
        """
elif False:
    GetPortsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPortsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Query Parameter to Get Ports By Name
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Query Parameter to Get Ports By Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)


if not MYPY:
    class GetPrecisionTimeServiceNtpAdvancedConfigurationArgsDict(TypedDict):
        key: NotRequired[_builtins.str]
        """
        The plaintext authentication key. For ASCII type, the key\\
        \\ must contain printable ASCII characters, range 10-20 characters. For\\
        \\ HEX type, range should be 10-40 characters
        """
        key_number: NotRequired[_builtins.int]
        """
        The authentication Key ID
        """
        type: NotRequired[_builtins.str]
        """
        md5 Authentication type
        """
elif False:
    GetPrecisionTimeServiceNtpAdvancedConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPrecisionTimeServiceNtpAdvancedConfigurationArgs:
    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 key_number: Optional[_builtins.int] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: The plaintext authentication key. For ASCII type, the key\\
               \\ must contain printable ASCII characters, range 10-20 characters. For\\
               \\ HEX type, range should be 10-40 characters
        :param _builtins.int key_number: The authentication Key ID
        :param _builtins.str type: md5 Authentication type
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if key_number is not None:
            pulumi.set(__self__, "key_number", key_number)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        The plaintext authentication key. For ASCII type, the key\\
        \\ must contain printable ASCII characters, range 10-20 characters. For\\
        \\ HEX type, range should be 10-40 characters
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="keyNumber")
    def key_number(self) -> Optional[_builtins.int]:
        """
        The authentication Key ID
        """
        return pulumi.get(self, "key_number")

    @key_number.setter
    def key_number(self, value: Optional[_builtins.int]):
        pulumi.set(self, "key_number", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        md5 Authentication type
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class GetPrecisionTimeServiceProjectArgsDict(TypedDict):
        project_id: _builtins.str
        """
        Equinix Subscriber-assigned project ID
        """
elif False:
    GetPrecisionTimeServiceProjectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPrecisionTimeServiceProjectArgs:
    def __init__(__self__, *,
                 project_id: _builtins.str):
        """
        :param _builtins.str project_id: Equinix Subscriber-assigned project ID
        """
        pulumi.set(__self__, "project_id", project_id)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        Equinix Subscriber-assigned project ID
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: _builtins.str):
        pulumi.set(self, "project_id", value)


if not MYPY:
    class GetPrecisionTimeServicePtpAdvancedConfigurationArgsDict(TypedDict):
        domain: NotRequired[_builtins.int]
        """
        The PTP domain value
        """
        grant_time: NotRequired[_builtins.int]
        """
        Unicast Grant Time in seconds. For Multicast and Hybrid transport modes, grant time defaults to 300 seconds. For Unicast mode, grant time can be between 30 to 7200
        """
        log_announce_interval: NotRequired[_builtins.int]
        """
        Logarithmic value that controls the rate of PTP Announce packets from the PTP time server. Default is 1 (1 packet every 2 seconds), Unit packets/second
        """
        log_delay_req_interval: NotRequired[_builtins.int]
        """
        Logarithmic value that controls the rate of PTP DelayReq packets. Default is -4 (16 packets per second), Unit packets/second..
        """
        log_sync_interval: NotRequired[_builtins.int]
        """
        Logarithmic value that controls the rate of PTP Sync packets. Default is -4 (16 packets per second), Unit packets/second..
        """
        priority1: NotRequired[_builtins.int]
        """
        The priority1 value determines the best primary clock, Lower value indicates higher priority
        """
        priority2: NotRequired[_builtins.int]
        """
        The priority2 value differentiates and prioritizes the primary clock to avoid confusion when priority1-value is the same for different primary clocks in a network
        """
        time_scale: NotRequired[_builtins.str]
        """
        Time Scale value, ARB denotes Arbitrary and PTP denotes Precision Time Protocol
        """
        transport_mode: NotRequired[_builtins.str]
        """
        ptp transport mode
        """
elif False:
    GetPrecisionTimeServicePtpAdvancedConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPrecisionTimeServicePtpAdvancedConfigurationArgs:
    def __init__(__self__, *,
                 domain: Optional[_builtins.int] = None,
                 grant_time: Optional[_builtins.int] = None,
                 log_announce_interval: Optional[_builtins.int] = None,
                 log_delay_req_interval: Optional[_builtins.int] = None,
                 log_sync_interval: Optional[_builtins.int] = None,
                 priority1: Optional[_builtins.int] = None,
                 priority2: Optional[_builtins.int] = None,
                 time_scale: Optional[_builtins.str] = None,
                 transport_mode: Optional[_builtins.str] = None):
        """
        :param _builtins.int domain: The PTP domain value
        :param _builtins.int grant_time: Unicast Grant Time in seconds. For Multicast and Hybrid transport modes, grant time defaults to 300 seconds. For Unicast mode, grant time can be between 30 to 7200
        :param _builtins.int log_announce_interval: Logarithmic value that controls the rate of PTP Announce packets from the PTP time server. Default is 1 (1 packet every 2 seconds), Unit packets/second
        :param _builtins.int log_delay_req_interval: Logarithmic value that controls the rate of PTP DelayReq packets. Default is -4 (16 packets per second), Unit packets/second..
        :param _builtins.int log_sync_interval: Logarithmic value that controls the rate of PTP Sync packets. Default is -4 (16 packets per second), Unit packets/second..
        :param _builtins.int priority1: The priority1 value determines the best primary clock, Lower value indicates higher priority
        :param _builtins.int priority2: The priority2 value differentiates and prioritizes the primary clock to avoid confusion when priority1-value is the same for different primary clocks in a network
        :param _builtins.str time_scale: Time Scale value, ARB denotes Arbitrary and PTP denotes Precision Time Protocol
        :param _builtins.str transport_mode: ptp transport mode
        """
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if grant_time is not None:
            pulumi.set(__self__, "grant_time", grant_time)
        if log_announce_interval is not None:
            pulumi.set(__self__, "log_announce_interval", log_announce_interval)
        if log_delay_req_interval is not None:
            pulumi.set(__self__, "log_delay_req_interval", log_delay_req_interval)
        if log_sync_interval is not None:
            pulumi.set(__self__, "log_sync_interval", log_sync_interval)
        if priority1 is not None:
            pulumi.set(__self__, "priority1", priority1)
        if priority2 is not None:
            pulumi.set(__self__, "priority2", priority2)
        if time_scale is not None:
            pulumi.set(__self__, "time_scale", time_scale)
        if transport_mode is not None:
            pulumi.set(__self__, "transport_mode", transport_mode)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> Optional[_builtins.int]:
        """
        The PTP domain value
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: Optional[_builtins.int]):
        pulumi.set(self, "domain", value)

    @_builtins.property
    @pulumi.getter(name="grantTime")
    def grant_time(self) -> Optional[_builtins.int]:
        """
        Unicast Grant Time in seconds. For Multicast and Hybrid transport modes, grant time defaults to 300 seconds. For Unicast mode, grant time can be between 30 to 7200
        """
        return pulumi.get(self, "grant_time")

    @grant_time.setter
    def grant_time(self, value: Optional[_builtins.int]):
        pulumi.set(self, "grant_time", value)

    @_builtins.property
    @pulumi.getter(name="logAnnounceInterval")
    def log_announce_interval(self) -> Optional[_builtins.int]:
        """
        Logarithmic value that controls the rate of PTP Announce packets from the PTP time server. Default is 1 (1 packet every 2 seconds), Unit packets/second
        """
        return pulumi.get(self, "log_announce_interval")

    @log_announce_interval.setter
    def log_announce_interval(self, value: Optional[_builtins.int]):
        pulumi.set(self, "log_announce_interval", value)

    @_builtins.property
    @pulumi.getter(name="logDelayReqInterval")
    def log_delay_req_interval(self) -> Optional[_builtins.int]:
        """
        Logarithmic value that controls the rate of PTP DelayReq packets. Default is -4 (16 packets per second), Unit packets/second..
        """
        return pulumi.get(self, "log_delay_req_interval")

    @log_delay_req_interval.setter
    def log_delay_req_interval(self, value: Optional[_builtins.int]):
        pulumi.set(self, "log_delay_req_interval", value)

    @_builtins.property
    @pulumi.getter(name="logSyncInterval")
    def log_sync_interval(self) -> Optional[_builtins.int]:
        """
        Logarithmic value that controls the rate of PTP Sync packets. Default is -4 (16 packets per second), Unit packets/second..
        """
        return pulumi.get(self, "log_sync_interval")

    @log_sync_interval.setter
    def log_sync_interval(self, value: Optional[_builtins.int]):
        pulumi.set(self, "log_sync_interval", value)

    @_builtins.property
    @pulumi.getter
    def priority1(self) -> Optional[_builtins.int]:
        """
        The priority1 value determines the best primary clock, Lower value indicates higher priority
        """
        return pulumi.get(self, "priority1")

    @priority1.setter
    def priority1(self, value: Optional[_builtins.int]):
        pulumi.set(self, "priority1", value)

    @_builtins.property
    @pulumi.getter
    def priority2(self) -> Optional[_builtins.int]:
        """
        The priority2 value differentiates and prioritizes the primary clock to avoid confusion when priority1-value is the same for different primary clocks in a network
        """
        return pulumi.get(self, "priority2")

    @priority2.setter
    def priority2(self, value: Optional[_builtins.int]):
        pulumi.set(self, "priority2", value)

    @_builtins.property
    @pulumi.getter(name="timeScale")
    def time_scale(self) -> Optional[_builtins.str]:
        """
        Time Scale value, ARB denotes Arbitrary and PTP denotes Precision Time Protocol
        """
        return pulumi.get(self, "time_scale")

    @time_scale.setter
    def time_scale(self, value: Optional[_builtins.str]):
        pulumi.set(self, "time_scale", value)

    @_builtins.property
    @pulumi.getter(name="transportMode")
    def transport_mode(self) -> Optional[_builtins.str]:
        """
        ptp transport mode
        """
        return pulumi.get(self, "transport_mode")

    @transport_mode.setter
    def transport_mode(self, value: Optional[_builtins.str]):
        pulumi.set(self, "transport_mode", value)


if not MYPY:
    class GetPrecisionTimeServicesFilterArgsDict(TypedDict):
        operator: _builtins.str
        """
        Operation applied to the values of the filter
        """
        property: _builtins.str
        """
        Property to apply the filter to
        """
        values: Sequence[_builtins.str]
        """
        List of values to apply the operation to for the specified property
        """
        or_: NotRequired[_builtins.bool]
        """
        Boolean value to specify if this filter is a part of the OR group. Has a maximum of 3 and only counts for 1 of the 8 possible filters
        """
elif False:
    GetPrecisionTimeServicesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPrecisionTimeServicesFilterArgs:
    def __init__(__self__, *,
                 operator: _builtins.str,
                 property: _builtins.str,
                 values: Sequence[_builtins.str],
                 or_: Optional[_builtins.bool] = None):
        """
        :param _builtins.str operator: Operation applied to the values of the filter
        :param _builtins.str property: Property to apply the filter to
        :param Sequence[_builtins.str] values: List of values to apply the operation to for the specified property
        :param _builtins.bool or_: Boolean value to specify if this filter is a part of the OR group. Has a maximum of 3 and only counts for 1 of the 8 possible filters
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "property", property)
        pulumi.set(__self__, "values", values)
        if or_ is not None:
            pulumi.set(__self__, "or_", or_)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        Operation applied to the values of the filter
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: _builtins.str):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def property(self) -> _builtins.str:
        """
        Property to apply the filter to
        """
        return pulumi.get(self, "property")

    @property.setter
    def property(self, value: _builtins.str):
        pulumi.set(self, "property", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        List of values to apply the operation to for the specified property
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter(name="or")
    def or_(self) -> Optional[_builtins.bool]:
        """
        Boolean value to specify if this filter is a part of the OR group. Has a maximum of 3 and only counts for 1 of the 8 possible filters
        """
        return pulumi.get(self, "or_")

    @or_.setter
    def or_(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "or_", value)


if not MYPY:
    class GetPrecisionTimeServicesPaginationArgsDict(TypedDict):
        limit: _builtins.int
        """
        Maximum number of search results returned per page. Number must be between 1 and 100, and the default is 20
        """
        offset: _builtins.int
        """
        Index of the first item returned in the response. The default is 0
        """
elif False:
    GetPrecisionTimeServicesPaginationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPrecisionTimeServicesPaginationArgs:
    def __init__(__self__, *,
                 limit: _builtins.int,
                 offset: _builtins.int):
        """
        :param _builtins.int limit: Maximum number of search results returned per page. Number must be between 1 and 100, and the default is 20
        :param _builtins.int offset: Index of the first item returned in the response. The default is 0
        """
        pulumi.set(__self__, "limit", limit)
        pulumi.set(__self__, "offset", offset)

    @_builtins.property
    @pulumi.getter
    def limit(self) -> _builtins.int:
        """
        Maximum number of search results returned per page. Number must be between 1 and 100, and the default is 20
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: _builtins.int):
        pulumi.set(self, "limit", value)

    @_builtins.property
    @pulumi.getter
    def offset(self) -> _builtins.int:
        """
        Index of the first item returned in the response. The default is 0
        """
        return pulumi.get(self, "offset")

    @offset.setter
    def offset(self, value: _builtins.int):
        pulumi.set(self, "offset", value)


if not MYPY:
    class GetPrecisionTimeServicesSortArgsDict(TypedDict):
        direction: NotRequired[_builtins.str]
        """
        The sorting direction. Can be one of: [DESC, ASC], Defaults to DESC
        """
        property: NotRequired[_builtins.str]
        """
        The property name to use in sorting. One of [/name /uuid /state /type /package/code /changeLog/createdDateTime /changeLog/updatedDateTime] Defaults to /name
        """
elif False:
    GetPrecisionTimeServicesSortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPrecisionTimeServicesSortArgs:
    def __init__(__self__, *,
                 direction: Optional[_builtins.str] = None,
                 property: Optional[_builtins.str] = None):
        """
        :param _builtins.str direction: The sorting direction. Can be one of: [DESC, ASC], Defaults to DESC
        :param _builtins.str property: The property name to use in sorting. One of [/name /uuid /state /type /package/code /changeLog/createdDateTime /changeLog/updatedDateTime] Defaults to /name
        """
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if property is not None:
            pulumi.set(__self__, "property", property)

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        """
        The sorting direction. Can be one of: [DESC, ASC], Defaults to DESC
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[_builtins.str]):
        pulumi.set(self, "direction", value)

    @_builtins.property
    @pulumi.getter
    def property(self) -> Optional[_builtins.str]:
        """
        The property name to use in sorting. One of [/name /uuid /state /type /package/code /changeLog/createdDateTime /changeLog/updatedDateTime] Defaults to /name
        """
        return pulumi.get(self, "property")

    @property.setter
    def property(self, value: Optional[_builtins.str]):
        pulumi.set(self, "property", value)


if not MYPY:
    class GetRouteAggregationRulesPaginationArgsDict(TypedDict):
        limit: _builtins.int
        """
        Maximum number of search results returned per page. Number must be between 1 and 100, and the default is 20
        """
        next: _builtins.str
        """
        The URL relative to the next item in the response
        """
        offset: _builtins.int
        """
        Index of the first item returned in the response. The default is 0
        """
        previous: _builtins.str
        """
        The URL relative to the previous item in the response
        """
        total: _builtins.int
        """
        The total number of route agrgegation rules available to the user making the request
        """
elif False:
    GetRouteAggregationRulesPaginationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRouteAggregationRulesPaginationArgs:
    def __init__(__self__, *,
                 limit: _builtins.int,
                 next: _builtins.str,
                 offset: _builtins.int,
                 previous: _builtins.str,
                 total: _builtins.int):
        """
        :param _builtins.int limit: Maximum number of search results returned per page. Number must be between 1 and 100, and the default is 20
        :param _builtins.str next: The URL relative to the next item in the response
        :param _builtins.int offset: Index of the first item returned in the response. The default is 0
        :param _builtins.str previous: The URL relative to the previous item in the response
        :param _builtins.int total: The total number of route agrgegation rules available to the user making the request
        """
        pulumi.set(__self__, "limit", limit)
        pulumi.set(__self__, "next", next)
        pulumi.set(__self__, "offset", offset)
        pulumi.set(__self__, "previous", previous)
        pulumi.set(__self__, "total", total)

    @_builtins.property
    @pulumi.getter
    def limit(self) -> _builtins.int:
        """
        Maximum number of search results returned per page. Number must be between 1 and 100, and the default is 20
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: _builtins.int):
        pulumi.set(self, "limit", value)

    @_builtins.property
    @pulumi.getter
    def next(self) -> _builtins.str:
        """
        The URL relative to the next item in the response
        """
        return pulumi.get(self, "next")

    @next.setter
    def next(self, value: _builtins.str):
        pulumi.set(self, "next", value)

    @_builtins.property
    @pulumi.getter
    def offset(self) -> _builtins.int:
        """
        Index of the first item returned in the response. The default is 0
        """
        return pulumi.get(self, "offset")

    @offset.setter
    def offset(self, value: _builtins.int):
        pulumi.set(self, "offset", value)

    @_builtins.property
    @pulumi.getter
    def previous(self) -> _builtins.str:
        """
        The URL relative to the previous item in the response
        """
        return pulumi.get(self, "previous")

    @previous.setter
    def previous(self, value: _builtins.str):
        pulumi.set(self, "previous", value)

    @_builtins.property
    @pulumi.getter
    def total(self) -> _builtins.int:
        """
        The total number of route agrgegation rules available to the user making the request
        """
        return pulumi.get(self, "total")

    @total.setter
    def total(self, value: _builtins.int):
        pulumi.set(self, "total", value)


if not MYPY:
    class GetRouteAggregationsFilterArgsDict(TypedDict):
        operator: _builtins.str
        """
        Operators to use on your filtered field with the values given. One of [ =, !=, >, >=, <, <=, BETWEEN, NOT BETWEEN, LIKE, NOT LIKE, IN, NOT IN, IS NOT NULL, IS NULL]
        """
        property: _builtins.str
        """
        possible field names to use on filters. One of [/type /name /project/projectId /uuid /state]
        """
        values: Sequence[_builtins.str]
        """
        The values that you want to apply the property+operator combination to in order to filter your data search
        """
elif False:
    GetRouteAggregationsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRouteAggregationsFilterArgs:
    def __init__(__self__, *,
                 operator: _builtins.str,
                 property: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str operator: Operators to use on your filtered field with the values given. One of [ =, !=, >, >=, <, <=, BETWEEN, NOT BETWEEN, LIKE, NOT LIKE, IN, NOT IN, IS NOT NULL, IS NULL]
        :param _builtins.str property: possible field names to use on filters. One of [/type /name /project/projectId /uuid /state]
        :param Sequence[_builtins.str] values: The values that you want to apply the property+operator combination to in order to filter your data search
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "property", property)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        Operators to use on your filtered field with the values given. One of [ =, !=, >, >=, <, <=, BETWEEN, NOT BETWEEN, LIKE, NOT LIKE, IN, NOT IN, IS NOT NULL, IS NULL]
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: _builtins.str):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def property(self) -> _builtins.str:
        """
        possible field names to use on filters. One of [/type /name /project/projectId /uuid /state]
        """
        return pulumi.get(self, "property")

    @property.setter
    def property(self, value: _builtins.str):
        pulumi.set(self, "property", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        The values that you want to apply the property+operator combination to in order to filter your data search
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetRouteAggregationsPaginationArgsDict(TypedDict):
        limit: _builtins.int
        """
        Maximum number of search results returned per page. Number must be between 1 and 100, and the default is 20
        """
        next: _builtins.str
        """
        The URL relative to the next item in the response
        """
        offset: _builtins.int
        """
        Index of the first item returned in the response. The default is 0
        """
        previous: _builtins.str
        """
        The URL relative to the previous item in the response
        """
        total: _builtins.int
        """
        The total number of route aggregations available to the user making the request
        """
elif False:
    GetRouteAggregationsPaginationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRouteAggregationsPaginationArgs:
    def __init__(__self__, *,
                 limit: _builtins.int,
                 next: _builtins.str,
                 offset: _builtins.int,
                 previous: _builtins.str,
                 total: _builtins.int):
        """
        :param _builtins.int limit: Maximum number of search results returned per page. Number must be between 1 and 100, and the default is 20
        :param _builtins.str next: The URL relative to the next item in the response
        :param _builtins.int offset: Index of the first item returned in the response. The default is 0
        :param _builtins.str previous: The URL relative to the previous item in the response
        :param _builtins.int total: The total number of route aggregations available to the user making the request
        """
        pulumi.set(__self__, "limit", limit)
        pulumi.set(__self__, "next", next)
        pulumi.set(__self__, "offset", offset)
        pulumi.set(__self__, "previous", previous)
        pulumi.set(__self__, "total", total)

    @_builtins.property
    @pulumi.getter
    def limit(self) -> _builtins.int:
        """
        Maximum number of search results returned per page. Number must be between 1 and 100, and the default is 20
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: _builtins.int):
        pulumi.set(self, "limit", value)

    @_builtins.property
    @pulumi.getter
    def next(self) -> _builtins.str:
        """
        The URL relative to the next item in the response
        """
        return pulumi.get(self, "next")

    @next.setter
    def next(self, value: _builtins.str):
        pulumi.set(self, "next", value)

    @_builtins.property
    @pulumi.getter
    def offset(self) -> _builtins.int:
        """
        Index of the first item returned in the response. The default is 0
        """
        return pulumi.get(self, "offset")

    @offset.setter
    def offset(self, value: _builtins.int):
        pulumi.set(self, "offset", value)

    @_builtins.property
    @pulumi.getter
    def previous(self) -> _builtins.str:
        """
        The URL relative to the previous item in the response
        """
        return pulumi.get(self, "previous")

    @previous.setter
    def previous(self, value: _builtins.str):
        pulumi.set(self, "previous", value)

    @_builtins.property
    @pulumi.getter
    def total(self) -> _builtins.int:
        """
        The total number of route aggregations available to the user making the request
        """
        return pulumi.get(self, "total")

    @total.setter
    def total(self, value: _builtins.int):
        pulumi.set(self, "total", value)


if not MYPY:
    class GetRouteAggregationsSortArgsDict(TypedDict):
        direction: NotRequired[_builtins.str]
        """
        The sorting direction. Can be one of: [DESC, ASC], Defaults to DESC
        """
        property: NotRequired[_builtins.str]
        """
        The property name to use in sorting. One of [/type /name /project/projectId /uuid /state] Defaults to /name
        """
elif False:
    GetRouteAggregationsSortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRouteAggregationsSortArgs:
    def __init__(__self__, *,
                 direction: Optional[_builtins.str] = None,
                 property: Optional[_builtins.str] = None):
        """
        :param _builtins.str direction: The sorting direction. Can be one of: [DESC, ASC], Defaults to DESC
        :param _builtins.str property: The property name to use in sorting. One of [/type /name /project/projectId /uuid /state] Defaults to /name
        """
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if property is not None:
            pulumi.set(__self__, "property", property)

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        """
        The sorting direction. Can be one of: [DESC, ASC], Defaults to DESC
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[_builtins.str]):
        pulumi.set(self, "direction", value)

    @_builtins.property
    @pulumi.getter
    def property(self) -> Optional[_builtins.str]:
        """
        The property name to use in sorting. One of [/type /name /project/projectId /uuid /state] Defaults to /name
        """
        return pulumi.get(self, "property")

    @property.setter
    def property(self, value: Optional[_builtins.str]):
        pulumi.set(self, "property", value)


if not MYPY:
    class GetRouteFiltersFilterArgsDict(TypedDict):
        operator: _builtins.str
        """
        Possible operators to use on the filter property. Can be one of the following: [ "=", "!=", "[NOT] LIKE", "[NOT] IN", "ILIKE" ]
        """
        property: _builtins.str
        """
        The API response property which you want to filter your request on. Can be one of the following: "/type", "/name", "/project/projectId", "/uuid", "/state"
        """
        values: Sequence[_builtins.str]
        """
        The values that you want to apply the property+operator combination to in order to filter your data search
        """
elif False:
    GetRouteFiltersFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRouteFiltersFilterArgs:
    def __init__(__self__, *,
                 operator: _builtins.str,
                 property: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str operator: Possible operators to use on the filter property. Can be one of the following: [ "=", "!=", "[NOT] LIKE", "[NOT] IN", "ILIKE" ]
        :param _builtins.str property: The API response property which you want to filter your request on. Can be one of the following: "/type", "/name", "/project/projectId", "/uuid", "/state"
        :param Sequence[_builtins.str] values: The values that you want to apply the property+operator combination to in order to filter your data search
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "property", property)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        Possible operators to use on the filter property. Can be one of the following: [ "=", "!=", "[NOT] LIKE", "[NOT] IN", "ILIKE" ]
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: _builtins.str):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def property(self) -> _builtins.str:
        """
        The API response property which you want to filter your request on. Can be one of the following: "/type", "/name", "/project/projectId", "/uuid", "/state"
        """
        return pulumi.get(self, "property")

    @property.setter
    def property(self, value: _builtins.str):
        pulumi.set(self, "property", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        The values that you want to apply the property+operator combination to in order to filter your data search
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetRouteFiltersPaginationArgsDict(TypedDict):
        limit: _builtins.int
        """
        Number of elements to be requested per page. Number must be between 1 and 100. Default is 20
        """
        next: _builtins.str
        """
        URL relative to the last item in the response.
        """
        offset: _builtins.int
        """
        The page offset for the pagination request. Index of the first element. Default is 0.
        """
        previous: _builtins.str
        """
        URL relative to the first item in the response.
        """
        total: _builtins.int
        """
        Total number of elements returned.
        """
elif False:
    GetRouteFiltersPaginationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRouteFiltersPaginationArgs:
    def __init__(__self__, *,
                 limit: _builtins.int,
                 next: _builtins.str,
                 offset: _builtins.int,
                 previous: _builtins.str,
                 total: _builtins.int):
        """
        :param _builtins.int limit: Number of elements to be requested per page. Number must be between 1 and 100. Default is 20
        :param _builtins.str next: URL relative to the last item in the response.
        :param _builtins.int offset: The page offset for the pagination request. Index of the first element. Default is 0.
        :param _builtins.str previous: URL relative to the first item in the response.
        :param _builtins.int total: Total number of elements returned.
        """
        pulumi.set(__self__, "limit", limit)
        pulumi.set(__self__, "next", next)
        pulumi.set(__self__, "offset", offset)
        pulumi.set(__self__, "previous", previous)
        pulumi.set(__self__, "total", total)

    @_builtins.property
    @pulumi.getter
    def limit(self) -> _builtins.int:
        """
        Number of elements to be requested per page. Number must be between 1 and 100. Default is 20
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: _builtins.int):
        pulumi.set(self, "limit", value)

    @_builtins.property
    @pulumi.getter
    def next(self) -> _builtins.str:
        """
        URL relative to the last item in the response.
        """
        return pulumi.get(self, "next")

    @next.setter
    def next(self, value: _builtins.str):
        pulumi.set(self, "next", value)

    @_builtins.property
    @pulumi.getter
    def offset(self) -> _builtins.int:
        """
        The page offset for the pagination request. Index of the first element. Default is 0.
        """
        return pulumi.get(self, "offset")

    @offset.setter
    def offset(self, value: _builtins.int):
        pulumi.set(self, "offset", value)

    @_builtins.property
    @pulumi.getter
    def previous(self) -> _builtins.str:
        """
        URL relative to the first item in the response.
        """
        return pulumi.get(self, "previous")

    @previous.setter
    def previous(self, value: _builtins.str):
        pulumi.set(self, "previous", value)

    @_builtins.property
    @pulumi.getter
    def total(self) -> _builtins.int:
        """
        Total number of elements returned.
        """
        return pulumi.get(self, "total")

    @total.setter
    def total(self, value: _builtins.int):
        pulumi.set(self, "total", value)


if not MYPY:
    class GetRouteFiltersSortArgsDict(TypedDict):
        direction: NotRequired[_builtins.str]
        """
        The sorting direction. Can be one of: [DESC, ASC], Defaults to DESC
        """
        property: NotRequired[_builtins.str]
        """
        The property name to use in sorting. Can be one of the following: [/type, /uuid, /name, /project/projectId, /state, /notMatchedRuleAction, /connectionsCount, /changeLog/createdDateTime, /changeLog/updatedDateTime], Defaults to /changeLog/updatedDateTime
        """
elif False:
    GetRouteFiltersSortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRouteFiltersSortArgs:
    def __init__(__self__, *,
                 direction: Optional[_builtins.str] = None,
                 property: Optional[_builtins.str] = None):
        """
        :param _builtins.str direction: The sorting direction. Can be one of: [DESC, ASC], Defaults to DESC
        :param _builtins.str property: The property name to use in sorting. Can be one of the following: [/type, /uuid, /name, /project/projectId, /state, /notMatchedRuleAction, /connectionsCount, /changeLog/createdDateTime, /changeLog/updatedDateTime], Defaults to /changeLog/updatedDateTime
        """
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if property is not None:
            pulumi.set(__self__, "property", property)

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        """
        The sorting direction. Can be one of: [DESC, ASC], Defaults to DESC
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[_builtins.str]):
        pulumi.set(self, "direction", value)

    @_builtins.property
    @pulumi.getter
    def property(self) -> Optional[_builtins.str]:
        """
        The property name to use in sorting. Can be one of the following: [/type, /uuid, /name, /project/projectId, /state, /notMatchedRuleAction, /connectionsCount, /changeLog/createdDateTime, /changeLog/updatedDateTime], Defaults to /changeLog/updatedDateTime
        """
        return pulumi.get(self, "property")

    @property.setter
    def property(self, value: Optional[_builtins.str]):
        pulumi.set(self, "property", value)


if not MYPY:
    class GetServiceProfilesFilterArgsDict(TypedDict):
        operator: _builtins.str
        """
        Operators to use on your filtered field with the values given. One of [=]
        """
        property: _builtins.str
        """
        Property to apply operator and values to. One of [/name /uuid /state /metros/code /visibility /type /project/projectId]
        """
        values: Sequence[_builtins.str]
        """
        The values that you want to apply the property+operator combination to in order to filter your data search
        """
elif False:
    GetServiceProfilesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetServiceProfilesFilterArgs:
    def __init__(__self__, *,
                 operator: _builtins.str,
                 property: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str operator: Operators to use on your filtered field with the values given. One of [=]
        :param _builtins.str property: Property to apply operator and values to. One of [/name /uuid /state /metros/code /visibility /type /project/projectId]
        :param Sequence[_builtins.str] values: The values that you want to apply the property+operator combination to in order to filter your data search
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "property", property)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        Operators to use on your filtered field with the values given. One of [=]
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: _builtins.str):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def property(self) -> _builtins.str:
        """
        Property to apply operator and values to. One of [/name /uuid /state /metros/code /visibility /type /project/projectId]
        """
        return pulumi.get(self, "property")

    @property.setter
    def property(self, value: _builtins.str):
        pulumi.set(self, "property", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        The values that you want to apply the property+operator combination to in order to filter your data search
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetServiceProfilesPaginationArgsDict(TypedDict):
        limit: NotRequired[_builtins.int]
        """
        Number of elements to be requested per page. Number must be between 1 and 100. Default is 20
        """
        offset: NotRequired[_builtins.int]
        """
        The page offset for the pagination request. Index of the first element. Default is 0.
        """
elif False:
    GetServiceProfilesPaginationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetServiceProfilesPaginationArgs:
    def __init__(__self__, *,
                 limit: Optional[_builtins.int] = None,
                 offset: Optional[_builtins.int] = None):
        """
        :param _builtins.int limit: Number of elements to be requested per page. Number must be between 1 and 100. Default is 20
        :param _builtins.int offset: The page offset for the pagination request. Index of the first element. Default is 0.
        """
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if offset is not None:
            pulumi.set(__self__, "offset", offset)

    @_builtins.property
    @pulumi.getter
    def limit(self) -> Optional[_builtins.int]:
        """
        Number of elements to be requested per page. Number must be between 1 and 100. Default is 20
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[_builtins.int]):
        pulumi.set(self, "limit", value)

    @_builtins.property
    @pulumi.getter
    def offset(self) -> Optional[_builtins.int]:
        """
        The page offset for the pagination request. Index of the first element. Default is 0.
        """
        return pulumi.get(self, "offset")

    @offset.setter
    def offset(self, value: Optional[_builtins.int]):
        pulumi.set(self, "offset", value)


if not MYPY:
    class GetServiceProfilesSortArgsDict(TypedDict):
        direction: NotRequired[_builtins.str]
        """
        The sorting direction. Can be one of: [DESC, ASC], Defaults to DESC
        """
        property: NotRequired[_builtins.str]
        """
        The property name to use in sorting. One of [/name /uuid /state /location/metroCode /location/metroName /package/code /changeLog/createdDateTime /changeLog/updatedDateTime]. Defaults to /changeLog/updatedDateTime
        """
elif False:
    GetServiceProfilesSortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetServiceProfilesSortArgs:
    def __init__(__self__, *,
                 direction: Optional[_builtins.str] = None,
                 property: Optional[_builtins.str] = None):
        """
        :param _builtins.str direction: The sorting direction. Can be one of: [DESC, ASC], Defaults to DESC
        :param _builtins.str property: The property name to use in sorting. One of [/name /uuid /state /location/metroCode /location/metroName /package/code /changeLog/createdDateTime /changeLog/updatedDateTime]. Defaults to /changeLog/updatedDateTime
        """
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if property is not None:
            pulumi.set(__self__, "property", property)

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        """
        The sorting direction. Can be one of: [DESC, ASC], Defaults to DESC
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[_builtins.str]):
        pulumi.set(self, "direction", value)

    @_builtins.property
    @pulumi.getter
    def property(self) -> Optional[_builtins.str]:
        """
        The property name to use in sorting. One of [/name /uuid /state /location/metroCode /location/metroName /package/code /changeLog/createdDateTime /changeLog/updatedDateTime]. Defaults to /changeLog/updatedDateTime
        """
        return pulumi.get(self, "property")

    @property.setter
    def property(self, value: Optional[_builtins.str]):
        pulumi.set(self, "property", value)


if not MYPY:
    class GetServiceTokensFilterArgsDict(TypedDict):
        operator: _builtins.str
        """
        Possible operators to use on the filter property. Can be one of the following: [ "=", "!=", "[NOT] LIKE", "[NOT] IN", "ILIKE" ]
        """
        property: _builtins.str
        """
        The API response property which you want to filter your request on. Can be one of the following: "/type", "/name", "/project/projectId", "/uuid", "/state"
        """
        values: Sequence[_builtins.str]
        """
        The values that you want to apply the property+operator combination to in order to filter your data search
        """
elif False:
    GetServiceTokensFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetServiceTokensFilterArgs:
    def __init__(__self__, *,
                 operator: _builtins.str,
                 property: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str operator: Possible operators to use on the filter property. Can be one of the following: [ "=", "!=", "[NOT] LIKE", "[NOT] IN", "ILIKE" ]
        :param _builtins.str property: The API response property which you want to filter your request on. Can be one of the following: "/type", "/name", "/project/projectId", "/uuid", "/state"
        :param Sequence[_builtins.str] values: The values that you want to apply the property+operator combination to in order to filter your data search
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "property", property)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        Possible operators to use on the filter property. Can be one of the following: [ "=", "!=", "[NOT] LIKE", "[NOT] IN", "ILIKE" ]
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: _builtins.str):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def property(self) -> _builtins.str:
        """
        The API response property which you want to filter your request on. Can be one of the following: "/type", "/name", "/project/projectId", "/uuid", "/state"
        """
        return pulumi.get(self, "property")

    @property.setter
    def property(self, value: _builtins.str):
        pulumi.set(self, "property", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        The values that you want to apply the property+operator combination to in order to filter your data search
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetServiceTokensPaginationArgsDict(TypedDict):
        limit: _builtins.int
        """
        Number of elements to be requested per page. Number must be between 1 and 100. Default is 20
        """
        next: _builtins.str
        """
        URL relative to the last item in the response.
        """
        offset: _builtins.int
        """
        The page offset for the pagination request. Index of the first element. Default is 0.
        """
        previous: _builtins.str
        """
        URL relative to the first item in the response.
        """
        total: _builtins.int
        """
        Total number of elements returned.
        """
elif False:
    GetServiceTokensPaginationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetServiceTokensPaginationArgs:
    def __init__(__self__, *,
                 limit: _builtins.int,
                 next: _builtins.str,
                 offset: _builtins.int,
                 previous: _builtins.str,
                 total: _builtins.int):
        """
        :param _builtins.int limit: Number of elements to be requested per page. Number must be between 1 and 100. Default is 20
        :param _builtins.str next: URL relative to the last item in the response.
        :param _builtins.int offset: The page offset for the pagination request. Index of the first element. Default is 0.
        :param _builtins.str previous: URL relative to the first item in the response.
        :param _builtins.int total: Total number of elements returned.
        """
        pulumi.set(__self__, "limit", limit)
        pulumi.set(__self__, "next", next)
        pulumi.set(__self__, "offset", offset)
        pulumi.set(__self__, "previous", previous)
        pulumi.set(__self__, "total", total)

    @_builtins.property
    @pulumi.getter
    def limit(self) -> _builtins.int:
        """
        Number of elements to be requested per page. Number must be between 1 and 100. Default is 20
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: _builtins.int):
        pulumi.set(self, "limit", value)

    @_builtins.property
    @pulumi.getter
    def next(self) -> _builtins.str:
        """
        URL relative to the last item in the response.
        """
        return pulumi.get(self, "next")

    @next.setter
    def next(self, value: _builtins.str):
        pulumi.set(self, "next", value)

    @_builtins.property
    @pulumi.getter
    def offset(self) -> _builtins.int:
        """
        The page offset for the pagination request. Index of the first element. Default is 0.
        """
        return pulumi.get(self, "offset")

    @offset.setter
    def offset(self, value: _builtins.int):
        pulumi.set(self, "offset", value)

    @_builtins.property
    @pulumi.getter
    def previous(self) -> _builtins.str:
        """
        URL relative to the first item in the response.
        """
        return pulumi.get(self, "previous")

    @previous.setter
    def previous(self, value: _builtins.str):
        pulumi.set(self, "previous", value)

    @_builtins.property
    @pulumi.getter
    def total(self) -> _builtins.int:
        """
        Total number of elements returned.
        """
        return pulumi.get(self, "total")

    @total.setter
    def total(self, value: _builtins.int):
        pulumi.set(self, "total", value)


if not MYPY:
    class GetStreamAlertRulesPaginationArgsDict(TypedDict):
        limit: _builtins.int
        """
        Maximum number of search results returned per page. Number must be between 1 and 100, and the default is 20
        """
        next: _builtins.str
        """
        The URL relative to the next item in the response
        """
        offset: _builtins.int
        """
        Index of the first item returned in the response. The default is 0
        """
        previous: _builtins.str
        """
        The URL relative to the previous item in the response
        """
        total: _builtins.int
        """
        The total number of alert rules available to the user making the request
        """
elif False:
    GetStreamAlertRulesPaginationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetStreamAlertRulesPaginationArgs:
    def __init__(__self__, *,
                 limit: _builtins.int,
                 next: _builtins.str,
                 offset: _builtins.int,
                 previous: _builtins.str,
                 total: _builtins.int):
        """
        :param _builtins.int limit: Maximum number of search results returned per page. Number must be between 1 and 100, and the default is 20
        :param _builtins.str next: The URL relative to the next item in the response
        :param _builtins.int offset: Index of the first item returned in the response. The default is 0
        :param _builtins.str previous: The URL relative to the previous item in the response
        :param _builtins.int total: The total number of alert rules available to the user making the request
        """
        pulumi.set(__self__, "limit", limit)
        pulumi.set(__self__, "next", next)
        pulumi.set(__self__, "offset", offset)
        pulumi.set(__self__, "previous", previous)
        pulumi.set(__self__, "total", total)

    @_builtins.property
    @pulumi.getter
    def limit(self) -> _builtins.int:
        """
        Maximum number of search results returned per page. Number must be between 1 and 100, and the default is 20
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: _builtins.int):
        pulumi.set(self, "limit", value)

    @_builtins.property
    @pulumi.getter
    def next(self) -> _builtins.str:
        """
        The URL relative to the next item in the response
        """
        return pulumi.get(self, "next")

    @next.setter
    def next(self, value: _builtins.str):
        pulumi.set(self, "next", value)

    @_builtins.property
    @pulumi.getter
    def offset(self) -> _builtins.int:
        """
        Index of the first item returned in the response. The default is 0
        """
        return pulumi.get(self, "offset")

    @offset.setter
    def offset(self, value: _builtins.int):
        pulumi.set(self, "offset", value)

    @_builtins.property
    @pulumi.getter
    def previous(self) -> _builtins.str:
        """
        The URL relative to the previous item in the response
        """
        return pulumi.get(self, "previous")

    @previous.setter
    def previous(self, value: _builtins.str):
        pulumi.set(self, "previous", value)

    @_builtins.property
    @pulumi.getter
    def total(self) -> _builtins.int:
        """
        The total number of alert rules available to the user making the request
        """
        return pulumi.get(self, "total")

    @total.setter
    def total(self, value: _builtins.int):
        pulumi.set(self, "total", value)


if not MYPY:
    class GetStreamAttachmentsFilterArgsDict(TypedDict):
        operator: _builtins.str
        """
        Operation applied to the values of the filter
        """
        property: _builtins.str
        """
        Property to apply the filter to
        """
        values: Sequence[_builtins.str]
        """
        List of values to apply the operation to for the specified property
        """
        or_: NotRequired[_builtins.bool]
        """
        Boolean value to specify if this filter is a part of the OR group. Has a maximum of 3 and only counts for 1 of the 8 possible filters
        """
elif False:
    GetStreamAttachmentsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetStreamAttachmentsFilterArgs:
    def __init__(__self__, *,
                 operator: _builtins.str,
                 property: _builtins.str,
                 values: Sequence[_builtins.str],
                 or_: Optional[_builtins.bool] = None):
        """
        :param _builtins.str operator: Operation applied to the values of the filter
        :param _builtins.str property: Property to apply the filter to
        :param Sequence[_builtins.str] values: List of values to apply the operation to for the specified property
        :param _builtins.bool or_: Boolean value to specify if this filter is a part of the OR group. Has a maximum of 3 and only counts for 1 of the 8 possible filters
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "property", property)
        pulumi.set(__self__, "values", values)
        if or_ is not None:
            pulumi.set(__self__, "or_", or_)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        Operation applied to the values of the filter
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: _builtins.str):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def property(self) -> _builtins.str:
        """
        Property to apply the filter to
        """
        return pulumi.get(self, "property")

    @property.setter
    def property(self, value: _builtins.str):
        pulumi.set(self, "property", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        List of values to apply the operation to for the specified property
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter(name="or")
    def or_(self) -> Optional[_builtins.bool]:
        """
        Boolean value to specify if this filter is a part of the OR group. Has a maximum of 3 and only counts for 1 of the 8 possible filters
        """
        return pulumi.get(self, "or_")

    @or_.setter
    def or_(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "or_", value)


if not MYPY:
    class GetStreamAttachmentsPaginationArgsDict(TypedDict):
        limit: _builtins.int
        """
        Maximum number of search results returned per page. Number must be between 1 and 100, and the default is 20
        """
        next: _builtins.str
        """
        The URL relative to the next item in the response
        """
        offset: _builtins.int
        """
        Index of the first item returned in the response. The default is 0
        """
        previous: _builtins.str
        """
        The URL relative to the previous item in the response
        """
        total: _builtins.int
        """
        The total number of streams available to the user making the request
        """
elif False:
    GetStreamAttachmentsPaginationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetStreamAttachmentsPaginationArgs:
    def __init__(__self__, *,
                 limit: _builtins.int,
                 next: _builtins.str,
                 offset: _builtins.int,
                 previous: _builtins.str,
                 total: _builtins.int):
        """
        :param _builtins.int limit: Maximum number of search results returned per page. Number must be between 1 and 100, and the default is 20
        :param _builtins.str next: The URL relative to the next item in the response
        :param _builtins.int offset: Index of the first item returned in the response. The default is 0
        :param _builtins.str previous: The URL relative to the previous item in the response
        :param _builtins.int total: The total number of streams available to the user making the request
        """
        pulumi.set(__self__, "limit", limit)
        pulumi.set(__self__, "next", next)
        pulumi.set(__self__, "offset", offset)
        pulumi.set(__self__, "previous", previous)
        pulumi.set(__self__, "total", total)

    @_builtins.property
    @pulumi.getter
    def limit(self) -> _builtins.int:
        """
        Maximum number of search results returned per page. Number must be between 1 and 100, and the default is 20
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: _builtins.int):
        pulumi.set(self, "limit", value)

    @_builtins.property
    @pulumi.getter
    def next(self) -> _builtins.str:
        """
        The URL relative to the next item in the response
        """
        return pulumi.get(self, "next")

    @next.setter
    def next(self, value: _builtins.str):
        pulumi.set(self, "next", value)

    @_builtins.property
    @pulumi.getter
    def offset(self) -> _builtins.int:
        """
        Index of the first item returned in the response. The default is 0
        """
        return pulumi.get(self, "offset")

    @offset.setter
    def offset(self, value: _builtins.int):
        pulumi.set(self, "offset", value)

    @_builtins.property
    @pulumi.getter
    def previous(self) -> _builtins.str:
        """
        The URL relative to the previous item in the response
        """
        return pulumi.get(self, "previous")

    @previous.setter
    def previous(self, value: _builtins.str):
        pulumi.set(self, "previous", value)

    @_builtins.property
    @pulumi.getter
    def total(self) -> _builtins.int:
        """
        The total number of streams available to the user making the request
        """
        return pulumi.get(self, "total")

    @total.setter
    def total(self, value: _builtins.int):
        pulumi.set(self, "total", value)


if not MYPY:
    class GetStreamAttachmentsSortArgsDict(TypedDict):
        direction: _builtins.str
        """
        The sorting direction of the property chosen. ASC or DESC
        """
        property: _builtins.str
        """
        The field name the sorting is performed on
        """
elif False:
    GetStreamAttachmentsSortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetStreamAttachmentsSortArgs:
    def __init__(__self__, *,
                 direction: _builtins.str,
                 property: _builtins.str):
        """
        :param _builtins.str direction: The sorting direction of the property chosen. ASC or DESC
        :param _builtins.str property: The field name the sorting is performed on
        """
        pulumi.set(__self__, "direction", direction)
        pulumi.set(__self__, "property", property)

    @_builtins.property
    @pulumi.getter
    def direction(self) -> _builtins.str:
        """
        The sorting direction of the property chosen. ASC or DESC
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: _builtins.str):
        pulumi.set(self, "direction", value)

    @_builtins.property
    @pulumi.getter
    def property(self) -> _builtins.str:
        """
        The field name the sorting is performed on
        """
        return pulumi.get(self, "property")

    @property.setter
    def property(self, value: _builtins.str):
        pulumi.set(self, "property", value)


if not MYPY:
    class GetStreamSubscriptionsPaginationArgsDict(TypedDict):
        limit: _builtins.int
        """
        Maximum number of search results returned per page. Number must be between 1 and 100, and the default is 20
        """
        next: _builtins.str
        """
        The URL relative to the next item in the response
        """
        offset: _builtins.int
        """
        Index of the first item returned in the response. The default is 0
        """
        previous: _builtins.str
        """
        The URL relative to the previous item in the response
        """
        total: _builtins.int
        """
        The total number of streams available to the user making the request
        """
elif False:
    GetStreamSubscriptionsPaginationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetStreamSubscriptionsPaginationArgs:
    def __init__(__self__, *,
                 limit: _builtins.int,
                 next: _builtins.str,
                 offset: _builtins.int,
                 previous: _builtins.str,
                 total: _builtins.int):
        """
        :param _builtins.int limit: Maximum number of search results returned per page. Number must be between 1 and 100, and the default is 20
        :param _builtins.str next: The URL relative to the next item in the response
        :param _builtins.int offset: Index of the first item returned in the response. The default is 0
        :param _builtins.str previous: The URL relative to the previous item in the response
        :param _builtins.int total: The total number of streams available to the user making the request
        """
        pulumi.set(__self__, "limit", limit)
        pulumi.set(__self__, "next", next)
        pulumi.set(__self__, "offset", offset)
        pulumi.set(__self__, "previous", previous)
        pulumi.set(__self__, "total", total)

    @_builtins.property
    @pulumi.getter
    def limit(self) -> _builtins.int:
        """
        Maximum number of search results returned per page. Number must be between 1 and 100, and the default is 20
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: _builtins.int):
        pulumi.set(self, "limit", value)

    @_builtins.property
    @pulumi.getter
    def next(self) -> _builtins.str:
        """
        The URL relative to the next item in the response
        """
        return pulumi.get(self, "next")

    @next.setter
    def next(self, value: _builtins.str):
        pulumi.set(self, "next", value)

    @_builtins.property
    @pulumi.getter
    def offset(self) -> _builtins.int:
        """
        Index of the first item returned in the response. The default is 0
        """
        return pulumi.get(self, "offset")

    @offset.setter
    def offset(self, value: _builtins.int):
        pulumi.set(self, "offset", value)

    @_builtins.property
    @pulumi.getter
    def previous(self) -> _builtins.str:
        """
        The URL relative to the previous item in the response
        """
        return pulumi.get(self, "previous")

    @previous.setter
    def previous(self, value: _builtins.str):
        pulumi.set(self, "previous", value)

    @_builtins.property
    @pulumi.getter
    def total(self) -> _builtins.int:
        """
        The total number of streams available to the user making the request
        """
        return pulumi.get(self, "total")

    @total.setter
    def total(self, value: _builtins.int):
        pulumi.set(self, "total", value)


if not MYPY:
    class GetStreamsPaginationArgsDict(TypedDict):
        limit: _builtins.int
        """
        Maximum number of search results returned per page. Number must be between 1 and 100, and the default is 20
        """
        next: _builtins.str
        """
        The URL relative to the next item in the response
        """
        offset: _builtins.int
        """
        Index of the first item returned in the response. The default is 0
        """
        previous: _builtins.str
        """
        The URL relative to the previous item in the response
        """
        total: _builtins.int
        """
        The total number of streams available to the user making the request
        """
elif False:
    GetStreamsPaginationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetStreamsPaginationArgs:
    def __init__(__self__, *,
                 limit: _builtins.int,
                 next: _builtins.str,
                 offset: _builtins.int,
                 previous: _builtins.str,
                 total: _builtins.int):
        """
        :param _builtins.int limit: Maximum number of search results returned per page. Number must be between 1 and 100, and the default is 20
        :param _builtins.str next: The URL relative to the next item in the response
        :param _builtins.int offset: Index of the first item returned in the response. The default is 0
        :param _builtins.str previous: The URL relative to the previous item in the response
        :param _builtins.int total: The total number of streams available to the user making the request
        """
        pulumi.set(__self__, "limit", limit)
        pulumi.set(__self__, "next", next)
        pulumi.set(__self__, "offset", offset)
        pulumi.set(__self__, "previous", previous)
        pulumi.set(__self__, "total", total)

    @_builtins.property
    @pulumi.getter
    def limit(self) -> _builtins.int:
        """
        Maximum number of search results returned per page. Number must be between 1 and 100, and the default is 20
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: _builtins.int):
        pulumi.set(self, "limit", value)

    @_builtins.property
    @pulumi.getter
    def next(self) -> _builtins.str:
        """
        The URL relative to the next item in the response
        """
        return pulumi.get(self, "next")

    @next.setter
    def next(self, value: _builtins.str):
        pulumi.set(self, "next", value)

    @_builtins.property
    @pulumi.getter
    def offset(self) -> _builtins.int:
        """
        Index of the first item returned in the response. The default is 0
        """
        return pulumi.get(self, "offset")

    @offset.setter
    def offset(self, value: _builtins.int):
        pulumi.set(self, "offset", value)

    @_builtins.property
    @pulumi.getter
    def previous(self) -> _builtins.str:
        """
        The URL relative to the previous item in the response
        """
        return pulumi.get(self, "previous")

    @previous.setter
    def previous(self, value: _builtins.str):
        pulumi.set(self, "previous", value)

    @_builtins.property
    @pulumi.getter
    def total(self) -> _builtins.int:
        """
        The total number of streams available to the user making the request
        """
        return pulumi.get(self, "total")

    @total.setter
    def total(self, value: _builtins.int):
        pulumi.set(self, "total", value)


