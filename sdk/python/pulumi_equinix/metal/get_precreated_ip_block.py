# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'GetPrecreatedIpBlockResult',
    'AwaitableGetPrecreatedIpBlockResult',
    'get_precreated_ip_block',
    'get_precreated_ip_block_output',
]

@pulumi.output_type
class GetPrecreatedIpBlockResult:
    """
    A collection of values returned by getPrecreatedIpBlock.
    """
    def __init__(__self__, address=None, address_family=None, cidr=None, cidr_notation=None, facility=None, gateway=None, global_=None, id=None, manageable=None, management=None, metro=None, netmask=None, network=None, project_id=None, public=None, quantity=None, type=None, vrf_id=None):
        if address and not isinstance(address, str):
            raise TypeError("Expected argument 'address' to be a str")
        pulumi.set(__self__, "address", address)
        if address_family and not isinstance(address_family, int):
            raise TypeError("Expected argument 'address_family' to be a int")
        pulumi.set(__self__, "address_family", address_family)
        if cidr and not isinstance(cidr, int):
            raise TypeError("Expected argument 'cidr' to be a int")
        pulumi.set(__self__, "cidr", cidr)
        if cidr_notation and not isinstance(cidr_notation, str):
            raise TypeError("Expected argument 'cidr_notation' to be a str")
        pulumi.set(__self__, "cidr_notation", cidr_notation)
        if facility and not isinstance(facility, str):
            raise TypeError("Expected argument 'facility' to be a str")
        pulumi.set(__self__, "facility", facility)
        if gateway and not isinstance(gateway, str):
            raise TypeError("Expected argument 'gateway' to be a str")
        pulumi.set(__self__, "gateway", gateway)
        if global_ and not isinstance(global_, bool):
            raise TypeError("Expected argument 'global_' to be a bool")
        pulumi.set(__self__, "global_", global_)
        if id and not isinstance(id, str):
            raise TypeError("Expected argument 'id' to be a str")
        pulumi.set(__self__, "id", id)
        if manageable and not isinstance(manageable, bool):
            raise TypeError("Expected argument 'manageable' to be a bool")
        pulumi.set(__self__, "manageable", manageable)
        if management and not isinstance(management, bool):
            raise TypeError("Expected argument 'management' to be a bool")
        pulumi.set(__self__, "management", management)
        if metro and not isinstance(metro, str):
            raise TypeError("Expected argument 'metro' to be a str")
        pulumi.set(__self__, "metro", metro)
        if netmask and not isinstance(netmask, str):
            raise TypeError("Expected argument 'netmask' to be a str")
        pulumi.set(__self__, "netmask", netmask)
        if network and not isinstance(network, str):
            raise TypeError("Expected argument 'network' to be a str")
        pulumi.set(__self__, "network", network)
        if project_id and not isinstance(project_id, str):
            raise TypeError("Expected argument 'project_id' to be a str")
        pulumi.set(__self__, "project_id", project_id)
        if public and not isinstance(public, bool):
            raise TypeError("Expected argument 'public' to be a bool")
        pulumi.set(__self__, "public", public)
        if quantity and not isinstance(quantity, int):
            raise TypeError("Expected argument 'quantity' to be a int")
        pulumi.set(__self__, "quantity", quantity)
        if type and not isinstance(type, str):
            raise TypeError("Expected argument 'type' to be a str")
        pulumi.set(__self__, "type", type)
        if vrf_id and not isinstance(vrf_id, str):
            raise TypeError("Expected argument 'vrf_id' to be a str")
        pulumi.set(__self__, "vrf_id", vrf_id)

    @_builtins.property
    @pulumi.getter
    def address(self) -> _builtins.str:
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter(name="addressFamily")
    def address_family(self) -> _builtins.int:
        return pulumi.get(self, "address_family")

    @_builtins.property
    @pulumi.getter
    def cidr(self) -> _builtins.int:
        return pulumi.get(self, "cidr")

    @_builtins.property
    @pulumi.getter(name="cidrNotation")
    def cidr_notation(self) -> _builtins.str:
        """
        CIDR notation of the looked up block.
        """
        return pulumi.get(self, "cidr_notation")

    @_builtins.property
    @pulumi.getter
    def facility(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "facility")

    @_builtins.property
    @pulumi.getter
    def gateway(self) -> _builtins.str:
        return pulumi.get(self, "gateway")

    @_builtins.property
    @pulumi.getter(name="global")
    def global_(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "global_")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The provider-assigned unique ID for this managed resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def manageable(self) -> _builtins.bool:
        return pulumi.get(self, "manageable")

    @_builtins.property
    @pulumi.getter
    def management(self) -> _builtins.bool:
        return pulumi.get(self, "management")

    @_builtins.property
    @pulumi.getter
    def metro(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "metro")

    @_builtins.property
    @pulumi.getter
    def netmask(self) -> _builtins.str:
        return pulumi.get(self, "netmask")

    @_builtins.property
    @pulumi.getter
    def network(self) -> _builtins.str:
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter
    def public(self) -> _builtins.bool:
        return pulumi.get(self, "public")

    @_builtins.property
    @pulumi.getter
    def quantity(self) -> _builtins.int:
        return pulumi.get(self, "quantity")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="vrfId")
    def vrf_id(self) -> _builtins.str:
        return pulumi.get(self, "vrf_id")


class AwaitableGetPrecreatedIpBlockResult(GetPrecreatedIpBlockResult):
    # pylint: disable=using-constant-test
    def __await__(self):
        if False:
            yield self
        return GetPrecreatedIpBlockResult(
            address=self.address,
            address_family=self.address_family,
            cidr=self.cidr,
            cidr_notation=self.cidr_notation,
            facility=self.facility,
            gateway=self.gateway,
            global_=self.global_,
            id=self.id,
            manageable=self.manageable,
            management=self.management,
            metro=self.metro,
            netmask=self.netmask,
            network=self.network,
            project_id=self.project_id,
            public=self.public,
            quantity=self.quantity,
            type=self.type,
            vrf_id=self.vrf_id)


def get_precreated_ip_block(address_family: Optional[_builtins.int] = None,
                            facility: Optional[_builtins.str] = None,
                            global_: Optional[_builtins.bool] = None,
                            metro: Optional[_builtins.str] = None,
                            project_id: Optional[_builtins.str] = None,
                            public: Optional[_builtins.bool] = None,
                            opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetPrecreatedIpBlockResult:
    """
    Use this data source to get CIDR expression for precreated (management) IPv6 and IPv4 blocks in Equinix Metal. You can then use the cidrsubnet TF builtin function to derive subnets.

    > For backward compatibility, this data source will also return reserved (elastic) IP blocks.

    > Precreated (management) IP blocks for a metro will not be available until first device is created in that metro.

    > Public IPv4 blocks auto-assigned (management) to a device cannot be retrieved. If you need that information, consider using the metal.Device data source instead.

    ## Example Usage

    ```python
    import pulumi
    import pulumi_equinix as equinix
    import pulumi_std as std

    project_id = "<UUID_of_your_project>"
    web1 = equinix.metal.Device("web1",
        hostname="web1",
        plan=equinix.metal.Plan.C3_SMALL_X86,
        metro="sv",
        operating_system="ubuntu_24_04",
        billing_cycle=equinix.metal.BillingCycle.HOURLY,
        project_id=project_id)
    test = equinix.metal.get_precreated_ip_block(metro="sv",
        project_id=project_id,
        address_family=6,
        public=True)
    # The precreated IPv6 blocks are /56, so to get /64, we specify 8 more bits for network.
    # The cirdsubnet interpolation will pick second /64 subnet from the precreated block.
    from_ipv6_block = equinix.metal.IpAttachment("from_ipv6_block",
        device_id=web1.id,
        cidr_notation=std.cidrsubnet(input=test.cidr_notation,
            newbits=8,
            netnum=2).result)
    ```


    :param _builtins.int address_family: 4 or 6, depending on which block you are looking for.
    :param _builtins.str facility: Facility of the searched block. (for non-global blocks). Use metro instead; read the facility to metro migration guide
    :param _builtins.bool global_: Whether to look for global block. Default is false for backward compatibility.
    :param _builtins.str metro: Metro of the searched block (for non-global blocks).
    :param _builtins.str project_id: ID of the project where the searched block should be.
    :param _builtins.bool public: Whether to look for public or private block.
    """
    __args__ = dict()
    __args__['addressFamily'] = address_family
    __args__['facility'] = facility
    __args__['global'] = global_
    __args__['metro'] = metro
    __args__['projectId'] = project_id
    __args__['public'] = public
    opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
    __ret__ = pulumi.runtime.invoke('equinix:metal/getPrecreatedIpBlock:getPrecreatedIpBlock', __args__, opts=opts, typ=GetPrecreatedIpBlockResult).value

    return AwaitableGetPrecreatedIpBlockResult(
        address=pulumi.get(__ret__, 'address'),
        address_family=pulumi.get(__ret__, 'address_family'),
        cidr=pulumi.get(__ret__, 'cidr'),
        cidr_notation=pulumi.get(__ret__, 'cidr_notation'),
        facility=pulumi.get(__ret__, 'facility'),
        gateway=pulumi.get(__ret__, 'gateway'),
        global_=pulumi.get(__ret__, 'global_'),
        id=pulumi.get(__ret__, 'id'),
        manageable=pulumi.get(__ret__, 'manageable'),
        management=pulumi.get(__ret__, 'management'),
        metro=pulumi.get(__ret__, 'metro'),
        netmask=pulumi.get(__ret__, 'netmask'),
        network=pulumi.get(__ret__, 'network'),
        project_id=pulumi.get(__ret__, 'project_id'),
        public=pulumi.get(__ret__, 'public'),
        quantity=pulumi.get(__ret__, 'quantity'),
        type=pulumi.get(__ret__, 'type'),
        vrf_id=pulumi.get(__ret__, 'vrf_id'))
def get_precreated_ip_block_output(address_family: Optional[pulumi.Input[_builtins.int]] = None,
                                   facility: Optional[pulumi.Input[Optional[_builtins.str]]] = None,
                                   global_: Optional[pulumi.Input[Optional[_builtins.bool]]] = None,
                                   metro: Optional[pulumi.Input[Optional[_builtins.str]]] = None,
                                   project_id: Optional[pulumi.Input[_builtins.str]] = None,
                                   public: Optional[pulumi.Input[_builtins.bool]] = None,
                                   opts: Optional[Union[pulumi.InvokeOptions, pulumi.InvokeOutputOptions]] = None) -> pulumi.Output[GetPrecreatedIpBlockResult]:
    """
    Use this data source to get CIDR expression for precreated (management) IPv6 and IPv4 blocks in Equinix Metal. You can then use the cidrsubnet TF builtin function to derive subnets.

    > For backward compatibility, this data source will also return reserved (elastic) IP blocks.

    > Precreated (management) IP blocks for a metro will not be available until first device is created in that metro.

    > Public IPv4 blocks auto-assigned (management) to a device cannot be retrieved. If you need that information, consider using the metal.Device data source instead.

    ## Example Usage

    ```python
    import pulumi
    import pulumi_equinix as equinix
    import pulumi_std as std

    project_id = "<UUID_of_your_project>"
    web1 = equinix.metal.Device("web1",
        hostname="web1",
        plan=equinix.metal.Plan.C3_SMALL_X86,
        metro="sv",
        operating_system="ubuntu_24_04",
        billing_cycle=equinix.metal.BillingCycle.HOURLY,
        project_id=project_id)
    test = equinix.metal.get_precreated_ip_block(metro="sv",
        project_id=project_id,
        address_family=6,
        public=True)
    # The precreated IPv6 blocks are /56, so to get /64, we specify 8 more bits for network.
    # The cirdsubnet interpolation will pick second /64 subnet from the precreated block.
    from_ipv6_block = equinix.metal.IpAttachment("from_ipv6_block",
        device_id=web1.id,
        cidr_notation=std.cidrsubnet(input=test.cidr_notation,
            newbits=8,
            netnum=2).result)
    ```


    :param _builtins.int address_family: 4 or 6, depending on which block you are looking for.
    :param _builtins.str facility: Facility of the searched block. (for non-global blocks). Use metro instead; read the facility to metro migration guide
    :param _builtins.bool global_: Whether to look for global block. Default is false for backward compatibility.
    :param _builtins.str metro: Metro of the searched block (for non-global blocks).
    :param _builtins.str project_id: ID of the project where the searched block should be.
    :param _builtins.bool public: Whether to look for public or private block.
    """
    __args__ = dict()
    __args__['addressFamily'] = address_family
    __args__['facility'] = facility
    __args__['global'] = global_
    __args__['metro'] = metro
    __args__['projectId'] = project_id
    __args__['public'] = public
    opts = pulumi.InvokeOutputOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
    __ret__ = pulumi.runtime.invoke_output('equinix:metal/getPrecreatedIpBlock:getPrecreatedIpBlock', __args__, opts=opts, typ=GetPrecreatedIpBlockResult)
    return __ret__.apply(lambda __response__: GetPrecreatedIpBlockResult(
        address=pulumi.get(__response__, 'address'),
        address_family=pulumi.get(__response__, 'address_family'),
        cidr=pulumi.get(__response__, 'cidr'),
        cidr_notation=pulumi.get(__response__, 'cidr_notation'),
        facility=pulumi.get(__response__, 'facility'),
        gateway=pulumi.get(__response__, 'gateway'),
        global_=pulumi.get(__response__, 'global_'),
        id=pulumi.get(__response__, 'id'),
        manageable=pulumi.get(__response__, 'manageable'),
        management=pulumi.get(__response__, 'management'),
        metro=pulumi.get(__response__, 'metro'),
        netmask=pulumi.get(__response__, 'netmask'),
        network=pulumi.get(__response__, 'network'),
        project_id=pulumi.get(__response__, 'project_id'),
        public=pulumi.get(__response__, 'public'),
        quantity=pulumi.get(__response__, 'quantity'),
        type=pulumi.get(__response__, 'type'),
        vrf_id=pulumi.get(__response__, 'vrf_id')))
