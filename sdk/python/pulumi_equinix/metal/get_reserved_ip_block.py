# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'GetReservedIpBlockResult',
    'AwaitableGetReservedIpBlockResult',
    'get_reserved_ip_block',
    'get_reserved_ip_block_output',
]

@pulumi.output_type
class GetReservedIpBlockResult:
    """
    A collection of values returned by getReservedIpBlock.
    """
    def __init__(__self__, address=None, address_family=None, cidr=None, cidr_notation=None, facility=None, gateway=None, global_=None, id=None, ip_address=None, manageable=None, management=None, metro=None, netmask=None, network=None, project_id=None, public=None, quantity=None, type=None, vrf_id=None):
        if address and not isinstance(address, str):
            raise TypeError("Expected argument 'address' to be a str")
        pulumi.set(__self__, "address", address)
        if address_family and not isinstance(address_family, int):
            raise TypeError("Expected argument 'address_family' to be a int")
        pulumi.set(__self__, "address_family", address_family)
        if cidr and not isinstance(cidr, int):
            raise TypeError("Expected argument 'cidr' to be a int")
        pulumi.set(__self__, "cidr", cidr)
        if cidr_notation and not isinstance(cidr_notation, str):
            raise TypeError("Expected argument 'cidr_notation' to be a str")
        pulumi.set(__self__, "cidr_notation", cidr_notation)
        if facility and not isinstance(facility, str):
            raise TypeError("Expected argument 'facility' to be a str")
        pulumi.set(__self__, "facility", facility)
        if gateway and not isinstance(gateway, str):
            raise TypeError("Expected argument 'gateway' to be a str")
        pulumi.set(__self__, "gateway", gateway)
        if global_ and not isinstance(global_, bool):
            raise TypeError("Expected argument 'global_' to be a bool")
        pulumi.set(__self__, "global_", global_)
        if id and not isinstance(id, str):
            raise TypeError("Expected argument 'id' to be a str")
        pulumi.set(__self__, "id", id)
        if ip_address and not isinstance(ip_address, str):
            raise TypeError("Expected argument 'ip_address' to be a str")
        pulumi.set(__self__, "ip_address", ip_address)
        if manageable and not isinstance(manageable, bool):
            raise TypeError("Expected argument 'manageable' to be a bool")
        pulumi.set(__self__, "manageable", manageable)
        if management and not isinstance(management, bool):
            raise TypeError("Expected argument 'management' to be a bool")
        pulumi.set(__self__, "management", management)
        if metro and not isinstance(metro, str):
            raise TypeError("Expected argument 'metro' to be a str")
        pulumi.set(__self__, "metro", metro)
        if netmask and not isinstance(netmask, str):
            raise TypeError("Expected argument 'netmask' to be a str")
        pulumi.set(__self__, "netmask", netmask)
        if network and not isinstance(network, str):
            raise TypeError("Expected argument 'network' to be a str")
        pulumi.set(__self__, "network", network)
        if project_id and not isinstance(project_id, str):
            raise TypeError("Expected argument 'project_id' to be a str")
        pulumi.set(__self__, "project_id", project_id)
        if public and not isinstance(public, bool):
            raise TypeError("Expected argument 'public' to be a bool")
        pulumi.set(__self__, "public", public)
        if quantity and not isinstance(quantity, int):
            raise TypeError("Expected argument 'quantity' to be a int")
        pulumi.set(__self__, "quantity", quantity)
        if type and not isinstance(type, str):
            raise TypeError("Expected argument 'type' to be a str")
        pulumi.set(__self__, "type", type)
        if vrf_id and not isinstance(vrf_id, int):
            raise TypeError("Expected argument 'vrf_id' to be a int")
        pulumi.set(__self__, "vrf_id", vrf_id)

    @_builtins.property
    @pulumi.getter
    def address(self) -> _builtins.str:
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter(name="addressFamily")
    def address_family(self) -> _builtins.int:
        return pulumi.get(self, "address_family")

    @_builtins.property
    @pulumi.getter
    def cidr(self) -> _builtins.int:
        return pulumi.get(self, "cidr")

    @_builtins.property
    @pulumi.getter(name="cidrNotation")
    def cidr_notation(self) -> _builtins.str:
        return pulumi.get(self, "cidr_notation")

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""Use metro instead of facility.  For more information, read the migration guide: https://registry.terraform.io/providers/equinix/equinix/latest/docs/guides/migration_guide_facilities_to_metros_devices""")
    def facility(self) -> _builtins.str:
        return pulumi.get(self, "facility")

    @_builtins.property
    @pulumi.getter
    def gateway(self) -> _builtins.str:
        return pulumi.get(self, "gateway")

    @_builtins.property
    @pulumi.getter(name="global")
    def global_(self) -> _builtins.bool:
        return pulumi.get(self, "global_")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ip_address")

    @_builtins.property
    @pulumi.getter
    def manageable(self) -> _builtins.bool:
        return pulumi.get(self, "manageable")

    @_builtins.property
    @pulumi.getter
    def management(self) -> _builtins.bool:
        return pulumi.get(self, "management")

    @_builtins.property
    @pulumi.getter
    def metro(self) -> _builtins.str:
        return pulumi.get(self, "metro")

    @_builtins.property
    @pulumi.getter
    def netmask(self) -> _builtins.str:
        return pulumi.get(self, "netmask")

    @_builtins.property
    @pulumi.getter
    def network(self) -> _builtins.str:
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter
    def public(self) -> _builtins.bool:
        return pulumi.get(self, "public")

    @_builtins.property
    @pulumi.getter
    def quantity(self) -> _builtins.int:
        return pulumi.get(self, "quantity")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        One of `global_ipv4`, `public_ipv4`, `private_ipv4`, `public_ipv6`,or `vrf`
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="vrfId")
    def vrf_id(self) -> _builtins.int:
        return pulumi.get(self, "vrf_id")


class AwaitableGetReservedIpBlockResult(GetReservedIpBlockResult):
    # pylint: disable=using-constant-test
    def __await__(self):
        if False:
            yield self
        return GetReservedIpBlockResult(
            address=self.address,
            address_family=self.address_family,
            cidr=self.cidr,
            cidr_notation=self.cidr_notation,
            facility=self.facility,
            gateway=self.gateway,
            global_=self.global_,
            id=self.id,
            ip_address=self.ip_address,
            manageable=self.manageable,
            management=self.management,
            metro=self.metro,
            netmask=self.netmask,
            network=self.network,
            project_id=self.project_id,
            public=self.public,
            quantity=self.quantity,
            type=self.type,
            vrf_id=self.vrf_id)


def get_reserved_ip_block(id: Optional[_builtins.str] = None,
                          ip_address: Optional[_builtins.str] = None,
                          project_id: Optional[_builtins.str] = None,
                          opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetReservedIpBlockResult:
    """
    Use this data source to find IP address blocks in Equinix Metal. You can use IP address or a block ID for lookup.

    > For backward compatibility, this data source can be also used for precreated (management) IP blocks.

    See the [Virtual Routing and Forwarding documentation](https://deploy.equinix.com/developers/docs/metal/layer2-networking/vrf/) for product details and API reference material.


    :param _builtins.str id: UUID of the IP address block to look up.
    :param _builtins.str ip_address: Block containing this IP address will be returned.
           
           > **NOTE:** You should pass either `id`, or both `project_id` and `ip_address`.
    :param _builtins.str project_id: UUID of the project where the searched block should be.
    """
    __args__ = dict()
    __args__['id'] = id
    __args__['ipAddress'] = ip_address
    __args__['projectId'] = project_id
    opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
    __ret__ = pulumi.runtime.invoke('equinix:metal/getReservedIpBlock:getReservedIpBlock', __args__, opts=opts, typ=GetReservedIpBlockResult).value

    return AwaitableGetReservedIpBlockResult(
        address=pulumi.get(__ret__, 'address'),
        address_family=pulumi.get(__ret__, 'address_family'),
        cidr=pulumi.get(__ret__, 'cidr'),
        cidr_notation=pulumi.get(__ret__, 'cidr_notation'),
        facility=pulumi.get(__ret__, 'facility'),
        gateway=pulumi.get(__ret__, 'gateway'),
        global_=pulumi.get(__ret__, 'global_'),
        id=pulumi.get(__ret__, 'id'),
        ip_address=pulumi.get(__ret__, 'ip_address'),
        manageable=pulumi.get(__ret__, 'manageable'),
        management=pulumi.get(__ret__, 'management'),
        metro=pulumi.get(__ret__, 'metro'),
        netmask=pulumi.get(__ret__, 'netmask'),
        network=pulumi.get(__ret__, 'network'),
        project_id=pulumi.get(__ret__, 'project_id'),
        public=pulumi.get(__ret__, 'public'),
        quantity=pulumi.get(__ret__, 'quantity'),
        type=pulumi.get(__ret__, 'type'),
        vrf_id=pulumi.get(__ret__, 'vrf_id'))
def get_reserved_ip_block_output(id: Optional[pulumi.Input[Optional[_builtins.str]]] = None,
                                 ip_address: Optional[pulumi.Input[Optional[_builtins.str]]] = None,
                                 project_id: Optional[pulumi.Input[Optional[_builtins.str]]] = None,
                                 opts: Optional[Union[pulumi.InvokeOptions, pulumi.InvokeOutputOptions]] = None) -> pulumi.Output[GetReservedIpBlockResult]:
    """
    Use this data source to find IP address blocks in Equinix Metal. You can use IP address or a block ID for lookup.

    > For backward compatibility, this data source can be also used for precreated (management) IP blocks.

    See the [Virtual Routing and Forwarding documentation](https://deploy.equinix.com/developers/docs/metal/layer2-networking/vrf/) for product details and API reference material.


    :param _builtins.str id: UUID of the IP address block to look up.
    :param _builtins.str ip_address: Block containing this IP address will be returned.
           
           > **NOTE:** You should pass either `id`, or both `project_id` and `ip_address`.
    :param _builtins.str project_id: UUID of the project where the searched block should be.
    """
    __args__ = dict()
    __args__['id'] = id
    __args__['ipAddress'] = ip_address
    __args__['projectId'] = project_id
    opts = pulumi.InvokeOutputOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
    __ret__ = pulumi.runtime.invoke_output('equinix:metal/getReservedIpBlock:getReservedIpBlock', __args__, opts=opts, typ=GetReservedIpBlockResult)
    return __ret__.apply(lambda __response__: GetReservedIpBlockResult(
        address=pulumi.get(__response__, 'address'),
        address_family=pulumi.get(__response__, 'address_family'),
        cidr=pulumi.get(__response__, 'cidr'),
        cidr_notation=pulumi.get(__response__, 'cidr_notation'),
        facility=pulumi.get(__response__, 'facility'),
        gateway=pulumi.get(__response__, 'gateway'),
        global_=pulumi.get(__response__, 'global_'),
        id=pulumi.get(__response__, 'id'),
        ip_address=pulumi.get(__response__, 'ip_address'),
        manageable=pulumi.get(__response__, 'manageable'),
        management=pulumi.get(__response__, 'management'),
        metro=pulumi.get(__response__, 'metro'),
        netmask=pulumi.get(__response__, 'netmask'),
        network=pulumi.get(__response__, 'network'),
        project_id=pulumi.get(__response__, 'project_id'),
        public=pulumi.get(__response__, 'public'),
        quantity=pulumi.get(__response__, 'quantity'),
        type=pulumi.get(__response__, 'type'),
        vrf_id=pulumi.get(__response__, 'vrf_id')))
