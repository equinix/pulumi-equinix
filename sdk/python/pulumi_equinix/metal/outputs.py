# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'DeviceBehavior',
    'DeviceIpAddress',
    'DeviceNetwork',
    'DevicePort',
    'DeviceReinstall',
    'GatewayTimeouts',
    'InterconnectionPort',
    'InterconnectionServiceToken',
    'OrganizationAddress',
    'ProjectBgpConfig',
    'SpotMarketRequestInstanceParameters',
    'GetDeviceBgpNeighborsBgpNeighborResult',
    'GetDeviceBgpNeighborsBgpNeighborRoutesInResult',
    'GetDeviceBgpNeighborsBgpNeighborRoutesOutResult',
    'GetDeviceNetworkResult',
    'GetDevicePortResult',
    'GetDevicesDeviceResult',
    'GetDevicesDeviceNetworkResult',
    'GetDevicesDevicePortResult',
    'GetDevicesFilterResult',
    'GetDevicesSortResult',
    'GetFacilityCapacityResult',
    'GetInterconnectionPortResult',
    'GetInterconnectionServiceTokenResult',
    'GetMetroCapacityResult',
    'GetOrganizationAddressResult',
    'GetPlansFilterResult',
    'GetPlansPlanResult',
    'GetPlansSortResult',
    'GetProjectBgpConfigResult',
]

@pulumi.output_type
class DeviceBehavior(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowChanges":
            suggest = "allow_changes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceBehavior. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceBehavior.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceBehavior.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_changes: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] allow_changes: List of attributes that are allowed to change without recreating the instance. Supported attributes: `custom_data`, `user_data`
        """
        if allow_changes is not None:
            pulumi.set(__self__, "allow_changes", allow_changes)

    @property
    @pulumi.getter(name="allowChanges")
    def allow_changes(self) -> Optional[Sequence[str]]:
        """
        List of attributes that are allowed to change without recreating the instance. Supported attributes: `custom_data`, `user_data`
        """
        return pulumi.get(self, "allow_changes")


@pulumi.output_type
class DeviceIpAddress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "reservationIds":
            suggest = "reservation_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceIpAddress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceIpAddress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceIpAddress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 cidr: Optional[int] = None,
                 reservation_ids: Optional[Sequence[str]] = None):
        """
        :param str type: one of public*ipv4,private*ipv4,public_ipv6
        :param int cidr: CIDR suffix for IP block assigned to this device
        :param Sequence[str] reservation_ids: IDs of reservations to pick the blocks from
        """
        pulumi.set(__self__, "type", type)
        if cidr is not None:
            pulumi.set(__self__, "cidr", cidr)
        if reservation_ids is not None:
            pulumi.set(__self__, "reservation_ids", reservation_ids)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        one of public*ipv4,private*ipv4,public_ipv6
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def cidr(self) -> Optional[int]:
        """
        CIDR suffix for IP block assigned to this device
        """
        return pulumi.get(self, "cidr")

    @property
    @pulumi.getter(name="reservationIds")
    def reservation_ids(self) -> Optional[Sequence[str]]:
        """
        IDs of reservations to pick the blocks from
        """
        return pulumi.get(self, "reservation_ids")


@pulumi.output_type
class DeviceNetwork(dict):
    def __init__(__self__, *,
                 address: Optional[str] = None,
                 cidr: Optional[int] = None,
                 family: Optional[int] = None,
                 gateway: Optional[str] = None,
                 public: Optional[bool] = None):
        """
        :param str address: IPv4 or IPv6 address string
        :param int cidr: CIDR suffix for IP address block to be assigned, i.e. amount of addresses
        :param int family: IP version - "4" or "6"
        :param str gateway: Address of router
        :param bool public: Whether the address is routable from the Internet
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if cidr is not None:
            pulumi.set(__self__, "cidr", cidr)
        if family is not None:
            pulumi.set(__self__, "family", family)
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if public is not None:
            pulumi.set(__self__, "public", public)

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        """
        IPv4 or IPv6 address string
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def cidr(self) -> Optional[int]:
        """
        CIDR suffix for IP address block to be assigned, i.e. amount of addresses
        """
        return pulumi.get(self, "cidr")

    @property
    @pulumi.getter
    def family(self) -> Optional[int]:
        """
        IP version - "4" or "6"
        """
        return pulumi.get(self, "family")

    @property
    @pulumi.getter
    def gateway(self) -> Optional[str]:
        """
        Address of router
        """
        return pulumi.get(self, "gateway")

    @property
    @pulumi.getter
    def public(self) -> Optional[bool]:
        """
        Whether the address is routable from the Internet
        """
        return pulumi.get(self, "public")


@pulumi.output_type
class DevicePort(dict):
    def __init__(__self__, *,
                 bonded: Optional[bool] = None,
                 id: Optional[str] = None,
                 mac: Optional[str] = None,
                 name: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param bool bonded: Whether this port is part of a bond in bonded network setup
        :param str id: The ID of the device
        :param str mac: MAC address assigned to the port
        :param str name: Name of the port (e.g. eth0, or bond0)
        :param str type: One of [private_ipv4, public_ipv4, public_ipv6]
        """
        if bonded is not None:
            pulumi.set(__self__, "bonded", bonded)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if mac is not None:
            pulumi.set(__self__, "mac", mac)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def bonded(self) -> Optional[bool]:
        """
        Whether this port is part of a bond in bonded network setup
        """
        return pulumi.get(self, "bonded")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the device
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def mac(self) -> Optional[str]:
        """
        MAC address assigned to the port
        """
        return pulumi.get(self, "mac")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the port (e.g. eth0, or bond0)
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        One of [private_ipv4, public_ipv4, public_ipv6]
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DeviceReinstall(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deprovisionFast":
            suggest = "deprovision_fast"
        elif key == "preserveData":
            suggest = "preserve_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceReinstall. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceReinstall.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceReinstall.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 deprovision_fast: Optional[bool] = None,
                 enabled: Optional[bool] = None,
                 preserve_data: Optional[bool] = None):
        """
        :param bool deprovision_fast: Whether the OS disk should be filled with `00h` bytes before reinstall
        :param bool enabled: Whether the device should be reinstalled instead of destroyed
        :param bool preserve_data: Whether the non-OS disks should be kept or wiped during reinstall
        """
        if deprovision_fast is not None:
            pulumi.set(__self__, "deprovision_fast", deprovision_fast)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if preserve_data is not None:
            pulumi.set(__self__, "preserve_data", preserve_data)

    @property
    @pulumi.getter(name="deprovisionFast")
    def deprovision_fast(self) -> Optional[bool]:
        """
        Whether the OS disk should be filled with `00h` bytes before reinstall
        """
        return pulumi.get(self, "deprovision_fast")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Whether the device should be reinstalled instead of destroyed
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="preserveData")
    def preserve_data(self) -> Optional[bool]:
        """
        Whether the non-OS disks should be kept or wiped during reinstall
        """
        return pulumi.get(self, "preserve_data")


@pulumi.output_type
class GatewayTimeouts(dict):
    def __init__(__self__, *,
                 delete: Optional[str] = None):
        """
        :param str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        if delete is not None:
            pulumi.set(__self__, "delete", delete)

    @property
    @pulumi.getter
    def delete(self) -> Optional[str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")


@pulumi.output_type
class InterconnectionPort(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "linkStatus":
            suggest = "link_status"
        elif key == "virtualCircuitIds":
            suggest = "virtual_circuit_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InterconnectionPort. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InterconnectionPort.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InterconnectionPort.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 link_status: str,
                 name: str,
                 role: str,
                 speed: int,
                 status: str,
                 virtual_circuit_ids: Sequence[str]):
        """
        :param str name: Name of the connection resource
        :param int speed: Connection speed - Values must be in the format '<number>Mbps' or '<number>Gpbs', for example '100Mbps' or '50Gbps'. Actual supported values will depend on the connection type and whether the connection uses VLANs or VRF.
        :param str status: Status of the connection resource.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "link_status", link_status)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "speed", speed)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "virtual_circuit_ids", virtual_circuit_ids)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="linkStatus")
    def link_status(self) -> str:
        return pulumi.get(self, "link_status")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the connection resource
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def role(self) -> str:
        return pulumi.get(self, "role")

    @property
    @pulumi.getter
    def speed(self) -> int:
        """
        Connection speed - Values must be in the format '<number>Mbps' or '<number>Gpbs', for example '100Mbps' or '50Gbps'. Actual supported values will depend on the connection type and whether the connection uses VLANs or VRF.
        """
        return pulumi.get(self, "speed")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of the connection resource.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="virtualCircuitIds")
    def virtual_circuit_ids(self) -> Sequence[str]:
        return pulumi.get(self, "virtual_circuit_ids")


@pulumi.output_type
class InterconnectionServiceToken(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "expiresAt":
            suggest = "expires_at"
        elif key == "maxAllowedSpeed":
            suggest = "max_allowed_speed"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InterconnectionServiceToken. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InterconnectionServiceToken.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InterconnectionServiceToken.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expires_at: str,
                 id: str,
                 max_allowed_speed: str,
                 role: str,
                 state: str,
                 type: str):
        """
        :param str type: Connection type - dedicated or shared.
        """
        pulumi.set(__self__, "expires_at", expires_at)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "max_allowed_speed", max_allowed_speed)
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> str:
        return pulumi.get(self, "expires_at")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="maxAllowedSpeed")
    def max_allowed_speed(self) -> str:
        return pulumi.get(self, "max_allowed_speed")

    @property
    @pulumi.getter
    def role(self) -> str:
        return pulumi.get(self, "role")

    @property
    @pulumi.getter
    def state(self) -> str:
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Connection type - dedicated or shared.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class OrganizationAddress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "zipCode":
            suggest = "zip_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrganizationAddress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrganizationAddress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrganizationAddress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: str,
                 city: str,
                 country: str,
                 zip_code: str,
                 state: Optional[str] = None):
        """
        :param str address: Postal address.
        :param str city: City name.
        :param str country: Two letter country code (ISO 3166-1 alpha-2), e.g. US.
        :param str zip_code: Zip Code.
        :param str state: State name.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "city", city)
        pulumi.set(__self__, "country", country)
        pulumi.set(__self__, "zip_code", zip_code)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        Postal address.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def city(self) -> str:
        """
        City name.
        """
        return pulumi.get(self, "city")

    @property
    @pulumi.getter
    def country(self) -> str:
        """
        Two letter country code (ISO 3166-1 alpha-2), e.g. US.
        """
        return pulumi.get(self, "country")

    @property
    @pulumi.getter(name="zipCode")
    def zip_code(self) -> str:
        """
        Zip Code.
        """
        return pulumi.get(self, "zip_code")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        State name.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class ProjectBgpConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deploymentType":
            suggest = "deployment_type"
        elif key == "maxPrefix":
            suggest = "max_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectBgpConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectBgpConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectBgpConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 asn: int,
                 deployment_type: str,
                 max_prefix: Optional[int] = None,
                 md5: Optional[str] = None,
                 status: Optional[str] = None):
        """
        :param int asn: Autonomous System Number for local BGP deployment.
        :param str deployment_type: `local` or `global`, the `local` is likely to be usable immediately, the `global` will need to be reviewed by Equinix Metal engineers.
        :param int max_prefix: The maximum number of route filters allowed per server.
        :param str md5: Password for BGP session in plaintext (not a checksum).
        :param str status: status of BGP configuration in the project.
        """
        pulumi.set(__self__, "asn", asn)
        pulumi.set(__self__, "deployment_type", deployment_type)
        if max_prefix is not None:
            pulumi.set(__self__, "max_prefix", max_prefix)
        if md5 is not None:
            pulumi.set(__self__, "md5", md5)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def asn(self) -> int:
        """
        Autonomous System Number for local BGP deployment.
        """
        return pulumi.get(self, "asn")

    @property
    @pulumi.getter(name="deploymentType")
    def deployment_type(self) -> str:
        """
        `local` or `global`, the `local` is likely to be usable immediately, the `global` will need to be reviewed by Equinix Metal engineers.
        """
        return pulumi.get(self, "deployment_type")

    @property
    @pulumi.getter(name="maxPrefix")
    def max_prefix(self) -> Optional[int]:
        """
        The maximum number of route filters allowed per server.
        """
        return pulumi.get(self, "max_prefix")

    @property
    @pulumi.getter
    def md5(self) -> Optional[str]:
        """
        Password for BGP session in plaintext (not a checksum).
        """
        return pulumi.get(self, "md5")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        status of BGP configuration in the project.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class SpotMarketRequestInstanceParameters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "billingCycle":
            suggest = "billing_cycle"
        elif key == "operatingSystem":
            suggest = "operating_system"
        elif key == "alwaysPxe":
            suggest = "always_pxe"
        elif key == "ipxeScriptUrl":
            suggest = "ipxe_script_url"
        elif key == "projectSshKeys":
            suggest = "project_ssh_keys"
        elif key == "terminationTime":
            suggest = "termination_time"
        elif key == "termintationTime":
            suggest = "termintation_time"
        elif key == "userSshKeys":
            suggest = "user_ssh_keys"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotMarketRequestInstanceParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotMarketRequestInstanceParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotMarketRequestInstanceParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 billing_cycle: str,
                 hostname: str,
                 operating_system: str,
                 plan: str,
                 always_pxe: Optional[bool] = None,
                 customdata: Optional[str] = None,
                 description: Optional[str] = None,
                 features: Optional[Sequence[str]] = None,
                 ipxe_script_url: Optional[str] = None,
                 locked: Optional[bool] = None,
                 project_ssh_keys: Optional[Sequence[str]] = None,
                 tags: Optional[Sequence[str]] = None,
                 termination_time: Optional[str] = None,
                 termintation_time: Optional[str] = None,
                 user_ssh_keys: Optional[Sequence[str]] = None,
                 userdata: Optional[str] = None):
        """
        :param bool locked: Blocks deletion of the SpotMarketRequest device until the lock is disabled.
        """
        pulumi.set(__self__, "billing_cycle", billing_cycle)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "operating_system", operating_system)
        pulumi.set(__self__, "plan", plan)
        if always_pxe is not None:
            pulumi.set(__self__, "always_pxe", always_pxe)
        if customdata is not None:
            pulumi.set(__self__, "customdata", customdata)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if features is not None:
            pulumi.set(__self__, "features", features)
        if ipxe_script_url is not None:
            pulumi.set(__self__, "ipxe_script_url", ipxe_script_url)
        if locked is not None:
            pulumi.set(__self__, "locked", locked)
        if project_ssh_keys is not None:
            pulumi.set(__self__, "project_ssh_keys", project_ssh_keys)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if termination_time is not None:
            pulumi.set(__self__, "termination_time", termination_time)
        if termintation_time is not None:
            pulumi.set(__self__, "termintation_time", termintation_time)
        if user_ssh_keys is not None:
            pulumi.set(__self__, "user_ssh_keys", user_ssh_keys)
        if userdata is not None:
            pulumi.set(__self__, "userdata", userdata)

    @property
    @pulumi.getter(name="billingCycle")
    def billing_cycle(self) -> str:
        return pulumi.get(self, "billing_cycle")

    @property
    @pulumi.getter
    def hostname(self) -> str:
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter(name="operatingSystem")
    def operating_system(self) -> str:
        return pulumi.get(self, "operating_system")

    @property
    @pulumi.getter
    def plan(self) -> str:
        return pulumi.get(self, "plan")

    @property
    @pulumi.getter(name="alwaysPxe")
    def always_pxe(self) -> Optional[bool]:
        return pulumi.get(self, "always_pxe")

    @property
    @pulumi.getter
    def customdata(self) -> Optional[str]:
        return pulumi.get(self, "customdata")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def features(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "features")

    @property
    @pulumi.getter(name="ipxeScriptUrl")
    def ipxe_script_url(self) -> Optional[str]:
        return pulumi.get(self, "ipxe_script_url")

    @property
    @pulumi.getter
    def locked(self) -> Optional[bool]:
        """
        Blocks deletion of the SpotMarketRequest device until the lock is disabled.
        """
        return pulumi.get(self, "locked")

    @property
    @pulumi.getter(name="projectSshKeys")
    def project_ssh_keys(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "project_ssh_keys")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="terminationTime")
    def termination_time(self) -> Optional[str]:
        return pulumi.get(self, "termination_time")

    @property
    @pulumi.getter(name="termintationTime")
    @_utilities.deprecated("""Use instance_parameters.termination_time instead""")
    def termintation_time(self) -> Optional[str]:
        return pulumi.get(self, "termintation_time")

    @property
    @pulumi.getter(name="userSshKeys")
    def user_ssh_keys(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "user_ssh_keys")

    @property
    @pulumi.getter
    def userdata(self) -> Optional[str]:
        return pulumi.get(self, "userdata")


@pulumi.output_type
class GetDeviceBgpNeighborsBgpNeighborResult(dict):
    def __init__(__self__, *,
                 address_family: int,
                 customer_as: int,
                 customer_ip: str,
                 md5_enabled: bool,
                 md5_password: str,
                 multihop: bool,
                 peer_as: int,
                 routes_ins: Sequence['outputs.GetDeviceBgpNeighborsBgpNeighborRoutesInResult'],
                 routes_outs: Sequence['outputs.GetDeviceBgpNeighborsBgpNeighborRoutesOutResult'],
                 peer_ips: Optional[Sequence[str]] = None):
        """
        :param int address_family: IP address version, 4 or 6.
        :param int customer_as: Local autonomous system number.
        :param str customer_ip: Local used peer IP address.
        :param bool md5_enabled: Whether BGP session is password enabled.
        :param str md5_password: BGP session password in plaintext (not a checksum).
        :param bool multihop: Whether the neighbor is in EBGP multihop session.
        :param int peer_as: Peer AS number (different than customer_as for EBGP).
        :param Sequence['GetDeviceBgpNeighborsBgpNeighborRoutesInArgs'] routes_ins: Array of incoming routes.
        :param Sequence['GetDeviceBgpNeighborsBgpNeighborRoutesOutArgs'] routes_outs: Array of outgoing routes in the same format.
        :param Sequence[str] peer_ips: Array of IP addresses of this neighbor's peers.
        """
        pulumi.set(__self__, "address_family", address_family)
        pulumi.set(__self__, "customer_as", customer_as)
        pulumi.set(__self__, "customer_ip", customer_ip)
        pulumi.set(__self__, "md5_enabled", md5_enabled)
        pulumi.set(__self__, "md5_password", md5_password)
        pulumi.set(__self__, "multihop", multihop)
        pulumi.set(__self__, "peer_as", peer_as)
        pulumi.set(__self__, "routes_ins", routes_ins)
        pulumi.set(__self__, "routes_outs", routes_outs)
        if peer_ips is not None:
            pulumi.set(__self__, "peer_ips", peer_ips)

    @property
    @pulumi.getter(name="addressFamily")
    def address_family(self) -> int:
        """
        IP address version, 4 or 6.
        """
        return pulumi.get(self, "address_family")

    @property
    @pulumi.getter(name="customerAs")
    def customer_as(self) -> int:
        """
        Local autonomous system number.
        """
        return pulumi.get(self, "customer_as")

    @property
    @pulumi.getter(name="customerIp")
    def customer_ip(self) -> str:
        """
        Local used peer IP address.
        """
        return pulumi.get(self, "customer_ip")

    @property
    @pulumi.getter(name="md5Enabled")
    def md5_enabled(self) -> bool:
        """
        Whether BGP session is password enabled.
        """
        return pulumi.get(self, "md5_enabled")

    @property
    @pulumi.getter(name="md5Password")
    def md5_password(self) -> str:
        """
        BGP session password in plaintext (not a checksum).
        """
        return pulumi.get(self, "md5_password")

    @property
    @pulumi.getter
    def multihop(self) -> bool:
        """
        Whether the neighbor is in EBGP multihop session.
        """
        return pulumi.get(self, "multihop")

    @property
    @pulumi.getter(name="peerAs")
    def peer_as(self) -> int:
        """
        Peer AS number (different than customer_as for EBGP).
        """
        return pulumi.get(self, "peer_as")

    @property
    @pulumi.getter(name="routesIns")
    def routes_ins(self) -> Sequence['outputs.GetDeviceBgpNeighborsBgpNeighborRoutesInResult']:
        """
        Array of incoming routes.
        """
        return pulumi.get(self, "routes_ins")

    @property
    @pulumi.getter(name="routesOuts")
    def routes_outs(self) -> Sequence['outputs.GetDeviceBgpNeighborsBgpNeighborRoutesOutResult']:
        """
        Array of outgoing routes in the same format.
        """
        return pulumi.get(self, "routes_outs")

    @property
    @pulumi.getter(name="peerIps")
    def peer_ips(self) -> Optional[Sequence[str]]:
        """
        Array of IP addresses of this neighbor's peers.
        """
        return pulumi.get(self, "peer_ips")


@pulumi.output_type
class GetDeviceBgpNeighborsBgpNeighborRoutesInResult(dict):
    def __init__(__self__, *,
                 exact: bool,
                 route: str):
        """
        :param bool exact: (bool) Whether the route is exact.
        :param str route: CIDR expression of route (IP/mask).
        """
        pulumi.set(__self__, "exact", exact)
        pulumi.set(__self__, "route", route)

    @property
    @pulumi.getter
    def exact(self) -> bool:
        """
        (bool) Whether the route is exact.
        """
        return pulumi.get(self, "exact")

    @property
    @pulumi.getter
    def route(self) -> str:
        """
        CIDR expression of route (IP/mask).
        """
        return pulumi.get(self, "route")


@pulumi.output_type
class GetDeviceBgpNeighborsBgpNeighborRoutesOutResult(dict):
    def __init__(__self__, *,
                 exact: bool,
                 route: str):
        """
        :param bool exact: (bool) Whether the route is exact.
        :param str route: CIDR expression of route (IP/mask).
        """
        pulumi.set(__self__, "exact", exact)
        pulumi.set(__self__, "route", route)

    @property
    @pulumi.getter
    def exact(self) -> bool:
        """
        (bool) Whether the route is exact.
        """
        return pulumi.get(self, "exact")

    @property
    @pulumi.getter
    def route(self) -> str:
        """
        CIDR expression of route (IP/mask).
        """
        return pulumi.get(self, "route")


@pulumi.output_type
class GetDeviceNetworkResult(dict):
    def __init__(__self__, *,
                 address: str,
                 cidr: int,
                 family: int,
                 gateway: str,
                 public: bool):
        """
        :param str address: IPv4 or IPv6 address string
        :param int cidr: Bit length of the network mask of the address
        :param int family: IP version - "4" or "6"
        :param str gateway: Address of router
        :param bool public: Whether the address is routable from the Internet
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "cidr", cidr)
        pulumi.set(__self__, "family", family)
        pulumi.set(__self__, "gateway", gateway)
        pulumi.set(__self__, "public", public)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        IPv4 or IPv6 address string
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def cidr(self) -> int:
        """
        Bit length of the network mask of the address
        """
        return pulumi.get(self, "cidr")

    @property
    @pulumi.getter
    def family(self) -> int:
        """
        IP version - "4" or "6"
        """
        return pulumi.get(self, "family")

    @property
    @pulumi.getter
    def gateway(self) -> str:
        """
        Address of router
        """
        return pulumi.get(self, "gateway")

    @property
    @pulumi.getter
    def public(self) -> bool:
        """
        Whether the address is routable from the Internet
        """
        return pulumi.get(self, "public")


@pulumi.output_type
class GetDevicePortResult(dict):
    def __init__(__self__, *,
                 bonded: bool,
                 id: str,
                 mac: str,
                 name: str,
                 type: str):
        """
        :param bool bonded: Whether this port is part of a bond in bonded network setup
        :param str id: The ID of the device
        :param str mac: MAC address assigned to the port
        :param str name: Name of the port (e.g. eth0, or bond0)
        :param str type: Type of the port (e.g. NetworkPort or NetworkBondPort)
        """
        pulumi.set(__self__, "bonded", bonded)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "mac", mac)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def bonded(self) -> bool:
        """
        Whether this port is part of a bond in bonded network setup
        """
        return pulumi.get(self, "bonded")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the device
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def mac(self) -> str:
        """
        MAC address assigned to the port
        """
        return pulumi.get(self, "mac")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the port (e.g. eth0, or bond0)
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of the port (e.g. NetworkPort or NetworkBondPort)
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetDevicesDeviceResult(dict):
    def __init__(__self__, *,
                 access_private_ipv4: str,
                 access_public_ipv4: str,
                 access_public_ipv6: str,
                 always_pxe: bool,
                 billing_cycle: str,
                 description: str,
                 device_id: str,
                 facility: str,
                 hardware_reservation_id: str,
                 hostname: str,
                 ipxe_script_url: str,
                 metro: str,
                 network_type: str,
                 networks: Sequence['outputs.GetDevicesDeviceNetworkResult'],
                 operating_system: str,
                 plan: str,
                 ports: Sequence['outputs.GetDevicesDevicePortResult'],
                 project_id: str,
                 root_password: str,
                 sos_hostname: str,
                 ssh_key_ids: Sequence[str],
                 state: str,
                 storage: str,
                 tags: Sequence[str]):
        """
        :param str access_private_ipv4: The ipv4 private IP assigned to the device
        :param str access_public_ipv4: The ipv4 management IP assigned to the device
        :param str access_public_ipv6: The ipv6 management IP assigned to the device
        :param str billing_cycle: The billing cycle of the device (monthly or hourly)
        :param str description: Description string for the device
        :param str device_id: Device ID
        :param str facility: The facility where the device is deployed
        :param str hardware_reservation_id: The id of hardware reservation which this device occupies
        :param str hostname: The device name
        :param str metro: The metro where the device is deployed
        :param str network_type: L2 network type of the device, one oflayer3, hybrid, layer2-individual, layer2-bonded
        :param Sequence['GetDevicesDeviceNetworkArgs'] networks: The device's private and public IP (v4 and v6) network details. When a device is run without any special network configuration, it will have 3 networks: ublic IPv4 at equinix_metal_device.name.network.0, IPv6 at equinix_metal_device.name.network.1 and private IPv4 at equinix_metal_device.name.network.2. Elastic addresses then stack by type - an assigned public IPv4 will go after the management public IPv4 (to index 1), and will then shift the indices of the IPv6 and private IPv4. Assigned private IPv4 will go after the management private IPv4 (to the end of the network list).
        :param str operating_system: The operating system running on the device
        :param str plan: The hardware config of the device
        :param Sequence['GetDevicesDevicePortArgs'] ports: Ports assigned to the device
        :param str project_id: ID of project containing the devices. Exactly one of `project_id` and `organization_id` must be set.
        :param str root_password: Root password to the server (if still available)
        :param str sos_hostname: The hostname to use for [Serial over SSH](https://deploy.equinix.com/developers/docs/metal/resilience-recovery/serial-over-ssh/) access to the device
        :param Sequence[str] ssh_key_ids: List of IDs of SSH keys deployed in the device, can be both user or project SSH keys
        :param str state: The state of the device
        :param Sequence[str] tags: Tags attached to the device
        """
        pulumi.set(__self__, "access_private_ipv4", access_private_ipv4)
        pulumi.set(__self__, "access_public_ipv4", access_public_ipv4)
        pulumi.set(__self__, "access_public_ipv6", access_public_ipv6)
        pulumi.set(__self__, "always_pxe", always_pxe)
        pulumi.set(__self__, "billing_cycle", billing_cycle)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "device_id", device_id)
        pulumi.set(__self__, "facility", facility)
        pulumi.set(__self__, "hardware_reservation_id", hardware_reservation_id)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "ipxe_script_url", ipxe_script_url)
        pulumi.set(__self__, "metro", metro)
        pulumi.set(__self__, "network_type", network_type)
        pulumi.set(__self__, "networks", networks)
        pulumi.set(__self__, "operating_system", operating_system)
        pulumi.set(__self__, "plan", plan)
        pulumi.set(__self__, "ports", ports)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "root_password", root_password)
        pulumi.set(__self__, "sos_hostname", sos_hostname)
        pulumi.set(__self__, "ssh_key_ids", ssh_key_ids)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "storage", storage)
        pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="accessPrivateIpv4")
    def access_private_ipv4(self) -> str:
        """
        The ipv4 private IP assigned to the device
        """
        return pulumi.get(self, "access_private_ipv4")

    @property
    @pulumi.getter(name="accessPublicIpv4")
    def access_public_ipv4(self) -> str:
        """
        The ipv4 management IP assigned to the device
        """
        return pulumi.get(self, "access_public_ipv4")

    @property
    @pulumi.getter(name="accessPublicIpv6")
    def access_public_ipv6(self) -> str:
        """
        The ipv6 management IP assigned to the device
        """
        return pulumi.get(self, "access_public_ipv6")

    @property
    @pulumi.getter(name="alwaysPxe")
    def always_pxe(self) -> bool:
        return pulumi.get(self, "always_pxe")

    @property
    @pulumi.getter(name="billingCycle")
    def billing_cycle(self) -> str:
        """
        The billing cycle of the device (monthly or hourly)
        """
        return pulumi.get(self, "billing_cycle")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Description string for the device
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="deviceId")
    def device_id(self) -> str:
        """
        Device ID
        """
        return pulumi.get(self, "device_id")

    @property
    @pulumi.getter
    @_utilities.deprecated("""Use metro instead of facility.  For more information, read the migration guide: https://registry.terraform.io/providers/equinix/equinix/latest/docs/guides/migration_guide_facilities_to_metros_devices""")
    def facility(self) -> str:
        """
        The facility where the device is deployed
        """
        return pulumi.get(self, "facility")

    @property
    @pulumi.getter(name="hardwareReservationId")
    def hardware_reservation_id(self) -> str:
        """
        The id of hardware reservation which this device occupies
        """
        return pulumi.get(self, "hardware_reservation_id")

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The device name
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter(name="ipxeScriptUrl")
    def ipxe_script_url(self) -> str:
        return pulumi.get(self, "ipxe_script_url")

    @property
    @pulumi.getter
    def metro(self) -> str:
        """
        The metro where the device is deployed
        """
        return pulumi.get(self, "metro")

    @property
    @pulumi.getter(name="networkType")
    def network_type(self) -> str:
        """
        L2 network type of the device, one oflayer3, hybrid, layer2-individual, layer2-bonded
        """
        return pulumi.get(self, "network_type")

    @property
    @pulumi.getter
    def networks(self) -> Sequence['outputs.GetDevicesDeviceNetworkResult']:
        """
        The device's private and public IP (v4 and v6) network details. When a device is run without any special network configuration, it will have 3 networks: ublic IPv4 at equinix_metal_device.name.network.0, IPv6 at equinix_metal_device.name.network.1 and private IPv4 at equinix_metal_device.name.network.2. Elastic addresses then stack by type - an assigned public IPv4 will go after the management public IPv4 (to index 1), and will then shift the indices of the IPv6 and private IPv4. Assigned private IPv4 will go after the management private IPv4 (to the end of the network list).
        """
        return pulumi.get(self, "networks")

    @property
    @pulumi.getter(name="operatingSystem")
    def operating_system(self) -> str:
        """
        The operating system running on the device
        """
        return pulumi.get(self, "operating_system")

    @property
    @pulumi.getter
    def plan(self) -> str:
        """
        The hardware config of the device
        """
        return pulumi.get(self, "plan")

    @property
    @pulumi.getter
    def ports(self) -> Sequence['outputs.GetDevicesDevicePortResult']:
        """
        Ports assigned to the device
        """
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        ID of project containing the devices. Exactly one of `project_id` and `organization_id` must be set.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter(name="rootPassword")
    def root_password(self) -> str:
        """
        Root password to the server (if still available)
        """
        return pulumi.get(self, "root_password")

    @property
    @pulumi.getter(name="sosHostname")
    def sos_hostname(self) -> str:
        """
        The hostname to use for [Serial over SSH](https://deploy.equinix.com/developers/docs/metal/resilience-recovery/serial-over-ssh/) access to the device
        """
        return pulumi.get(self, "sos_hostname")

    @property
    @pulumi.getter(name="sshKeyIds")
    def ssh_key_ids(self) -> Sequence[str]:
        """
        List of IDs of SSH keys deployed in the device, can be both user or project SSH keys
        """
        return pulumi.get(self, "ssh_key_ids")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The state of the device
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def storage(self) -> str:
        return pulumi.get(self, "storage")

    @property
    @pulumi.getter
    def tags(self) -> Sequence[str]:
        """
        Tags attached to the device
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetDevicesDeviceNetworkResult(dict):
    def __init__(__self__, *,
                 address: str,
                 cidr: int,
                 family: int,
                 gateway: str,
                 public: bool):
        """
        :param str address: IPv4 or IPv6 address string
        :param int cidr: Bit length of the network mask of the address
        :param int family: IP version - "4" or "6"
        :param str gateway: Address of router
        :param bool public: Whether the address is routable from the Internet
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "cidr", cidr)
        pulumi.set(__self__, "family", family)
        pulumi.set(__self__, "gateway", gateway)
        pulumi.set(__self__, "public", public)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        IPv4 or IPv6 address string
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def cidr(self) -> int:
        """
        Bit length of the network mask of the address
        """
        return pulumi.get(self, "cidr")

    @property
    @pulumi.getter
    def family(self) -> int:
        """
        IP version - "4" or "6"
        """
        return pulumi.get(self, "family")

    @property
    @pulumi.getter
    def gateway(self) -> str:
        """
        Address of router
        """
        return pulumi.get(self, "gateway")

    @property
    @pulumi.getter
    def public(self) -> bool:
        """
        Whether the address is routable from the Internet
        """
        return pulumi.get(self, "public")


@pulumi.output_type
class GetDevicesDevicePortResult(dict):
    def __init__(__self__, *,
                 bonded: bool,
                 id: str,
                 mac: str,
                 name: str,
                 type: str):
        """
        :param bool bonded: Whether this port is part of a bond in bonded network setup
        :param str id: The ID of the device
        :param str mac: MAC address assigned to the port
        :param str name: Name of the port (e.g. eth0, or bond0)
        :param str type: Type of the port (e.g. NetworkPort or NetworkBondPort)
        """
        pulumi.set(__self__, "bonded", bonded)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "mac", mac)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def bonded(self) -> bool:
        """
        Whether this port is part of a bond in bonded network setup
        """
        return pulumi.get(self, "bonded")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the device
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def mac(self) -> str:
        """
        MAC address assigned to the port
        """
        return pulumi.get(self, "mac")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the port (e.g. eth0, or bond0)
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of the port (e.g. NetworkPort or NetworkBondPort)
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetDevicesFilterResult(dict):
    def __init__(__self__, *,
                 attribute: str,
                 values: Sequence[str],
                 all: Optional[bool] = None,
                 match_by: Optional[str] = None):
        """
        :param str attribute: The attribute used to filter. Filter attributes are case-sensitive
        :param Sequence[str] values: The filter values. Filter values are case-sensitive. If you specify multiple values for a filter, the values are joined with an OR by default, and the request returns all results that match any of the specified values
        :param bool all: If is set to true, the values are joined with an AND, and the requests returns only the results that match all specified values. Default is `false`.
               
               All fields in the `devices` block defined below can be used as attribute for both `sort` and `filter` blocks.
        :param str match_by: The type of comparison to apply. One of: `in` , `re`, `substring`, `less_than`, `less_than_or_equal`, `greater_than`, `greater_than_or_equal`. Default is `in`.
        """
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "values", values)
        if all is not None:
            pulumi.set(__self__, "all", all)
        if match_by is not None:
            pulumi.set(__self__, "match_by", match_by)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        """
        The attribute used to filter. Filter attributes are case-sensitive
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        The filter values. Filter values are case-sensitive. If you specify multiple values for a filter, the values are joined with an OR by default, and the request returns all results that match any of the specified values
        """
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def all(self) -> Optional[bool]:
        """
        If is set to true, the values are joined with an AND, and the requests returns only the results that match all specified values. Default is `false`.

        All fields in the `devices` block defined below can be used as attribute for both `sort` and `filter` blocks.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="matchBy")
    def match_by(self) -> Optional[str]:
        """
        The type of comparison to apply. One of: `in` , `re`, `substring`, `less_than`, `less_than_or_equal`, `greater_than`, `greater_than_or_equal`. Default is `in`.
        """
        return pulumi.get(self, "match_by")


@pulumi.output_type
class GetDevicesSortResult(dict):
    def __init__(__self__, *,
                 attribute: str,
                 direction: Optional[str] = None):
        """
        :param str attribute: The attribute used to sort the results. Sort attributes are case-sensitive
        :param str direction: Sort results in ascending or descending order. Strings are sorted in alphabetical order. One of: asc, desc
        """
        pulumi.set(__self__, "attribute", attribute)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        """
        The attribute used to sort the results. Sort attributes are case-sensitive
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        Sort results in ascending or descending order. Strings are sorted in alphabetical order. One of: asc, desc
        """
        return pulumi.get(self, "direction")


@pulumi.output_type
class GetFacilityCapacityResult(dict):
    def __init__(__self__, *,
                 plan: str,
                 quantity: Optional[int] = None):
        """
        :param str plan: Device plan that must be available in selected location.
        :param int quantity: Minimun number of devices that must be available in selected location. Default is `1`.
        """
        pulumi.set(__self__, "plan", plan)
        if quantity is not None:
            pulumi.set(__self__, "quantity", quantity)

    @property
    @pulumi.getter
    def plan(self) -> str:
        """
        Device plan that must be available in selected location.
        """
        return pulumi.get(self, "plan")

    @property
    @pulumi.getter
    def quantity(self) -> Optional[int]:
        """
        Minimun number of devices that must be available in selected location. Default is `1`.
        """
        return pulumi.get(self, "quantity")


@pulumi.output_type
class GetInterconnectionPortResult(dict):
    def __init__(__self__, *,
                 id: str,
                 link_status: str,
                 name: str,
                 role: str,
                 speed: int,
                 status: str,
                 virtual_circuit_ids: Sequence[str]):
        """
        :param str id: Port UUID.
        :param str link_status: Port link status.
        :param str name: Port name.
        :param str role: Port role - primary or secondary.
        :param int speed: Port speed in bits per second.
        :param str status: Port status.
        :param Sequence[str] virtual_circuit_ids: List of IDs of virtual cicruits attached to this port.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "link_status", link_status)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "speed", speed)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "virtual_circuit_ids", virtual_circuit_ids)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Port UUID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="linkStatus")
    def link_status(self) -> str:
        """
        Port link status.
        """
        return pulumi.get(self, "link_status")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Port name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def role(self) -> str:
        """
        Port role - primary or secondary.
        """
        return pulumi.get(self, "role")

    @property
    @pulumi.getter
    def speed(self) -> int:
        """
        Port speed in bits per second.
        """
        return pulumi.get(self, "speed")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Port status.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="virtualCircuitIds")
    def virtual_circuit_ids(self) -> Sequence[str]:
        """
        List of IDs of virtual cicruits attached to this port.
        """
        return pulumi.get(self, "virtual_circuit_ids")


@pulumi.output_type
class GetInterconnectionServiceTokenResult(dict):
    def __init__(__self__, *,
                 expires_at: str,
                 id: str,
                 max_allowed_speed: str,
                 role: str,
                 state: str,
                 type: str):
        """
        :param str expires_at: Expiration date of the service token.
        :param str id: Port UUID.
        :param str max_allowed_speed: Maximum allowed speed for the service token, string like in the `speed` attribute.
        :param str role: Port role - primary or secondary.
        :param str type: Token type, `a_side` or `z_side`.
        """
        pulumi.set(__self__, "expires_at", expires_at)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "max_allowed_speed", max_allowed_speed)
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> str:
        """
        Expiration date of the service token.
        """
        return pulumi.get(self, "expires_at")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Port UUID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="maxAllowedSpeed")
    def max_allowed_speed(self) -> str:
        """
        Maximum allowed speed for the service token, string like in the `speed` attribute.
        """
        return pulumi.get(self, "max_allowed_speed")

    @property
    @pulumi.getter
    def role(self) -> str:
        """
        Port role - primary or secondary.
        """
        return pulumi.get(self, "role")

    @property
    @pulumi.getter
    def state(self) -> str:
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Token type, `a_side` or `z_side`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetMetroCapacityResult(dict):
    def __init__(__self__, *,
                 plan: str,
                 quantity: Optional[int] = None):
        """
        :param str plan: Device plan that must be available in selected location.
        :param int quantity: Minimum number of devices that must be available in selected location. Default is `1`.
        """
        pulumi.set(__self__, "plan", plan)
        if quantity is not None:
            pulumi.set(__self__, "quantity", quantity)

    @property
    @pulumi.getter
    def plan(self) -> str:
        """
        Device plan that must be available in selected location.
        """
        return pulumi.get(self, "plan")

    @property
    @pulumi.getter
    def quantity(self) -> Optional[int]:
        """
        Minimum number of devices that must be available in selected location. Default is `1`.
        """
        return pulumi.get(self, "quantity")


@pulumi.output_type
class GetOrganizationAddressResult(dict):
    def __init__(__self__, *,
                 address: str,
                 city: str,
                 country: str,
                 state: str,
                 zip_code: str):
        """
        :param str address: Postal address.
        :param str city: City name.
        :param str country: Two letter country code (ISO 3166-1 alpha-2), e.g. US.
        :param str state: State name.
        :param str zip_code: Zip Code.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "city", city)
        pulumi.set(__self__, "country", country)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "zip_code", zip_code)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        Postal address.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def city(self) -> str:
        """
        City name.
        """
        return pulumi.get(self, "city")

    @property
    @pulumi.getter
    def country(self) -> str:
        """
        Two letter country code (ISO 3166-1 alpha-2), e.g. US.
        """
        return pulumi.get(self, "country")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        State name.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="zipCode")
    def zip_code(self) -> str:
        """
        Zip Code.
        """
        return pulumi.get(self, "zip_code")


@pulumi.output_type
class GetPlansFilterResult(dict):
    def __init__(__self__, *,
                 attribute: str,
                 values: Sequence[str],
                 all: Optional[bool] = None,
                 match_by: Optional[str] = None):
        """
        :param str attribute: The attribute used to filter. Filter attributes are case-sensitive
        :param Sequence[str] values: The filter values. Filter values are case-sensitive. If you specify multiple values for a filter, the values are joined with an OR by default, and the request returns all results that match any of the specified values
        :param bool all: If is set to true, the values are joined with an AND, and the requests returns only the results that match all specified values. Default is `false`.
               
               All fields in the `plans` block defined below can be used as attribute for both `sort` and `filter` blocks.
        :param str match_by: The type of comparison to apply. One of: `in` , `re`, `substring`, `less_than`, `less_than_or_equal`, `greater_than`, `greater_than_or_equal`. Default is `in`.
        """
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "values", values)
        if all is not None:
            pulumi.set(__self__, "all", all)
        if match_by is not None:
            pulumi.set(__self__, "match_by", match_by)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        """
        The attribute used to filter. Filter attributes are case-sensitive
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        The filter values. Filter values are case-sensitive. If you specify multiple values for a filter, the values are joined with an OR by default, and the request returns all results that match any of the specified values
        """
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def all(self) -> Optional[bool]:
        """
        If is set to true, the values are joined with an AND, and the requests returns only the results that match all specified values. Default is `false`.

        All fields in the `plans` block defined below can be used as attribute for both `sort` and `filter` blocks.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="matchBy")
    def match_by(self) -> Optional[str]:
        """
        The type of comparison to apply. One of: `in` , `re`, `substring`, `less_than`, `less_than_or_equal`, `greater_than`, `greater_than_or_equal`. Default is `in`.
        """
        return pulumi.get(self, "match_by")


@pulumi.output_type
class GetPlansPlanResult(dict):
    def __init__(__self__, *,
                 available_in_metros: Sequence[str],
                 available_ins: Sequence[str],
                 class_: str,
                 deployment_types: Sequence[str],
                 description: str,
                 id: str,
                 legacy: bool,
                 line: str,
                 name: str,
                 pricing_hour: float,
                 pricing_month: float,
                 slug: str):
        """
        :param Sequence[str] available_in_metros: list of metros where the plan is available
        :param Sequence[str] available_ins: (**Deprecated**) list of facilities where the plan is available
        :param str class_: plan class
        :param Sequence[str] deployment_types: list of deployment types, e.g. on_demand, spot_market
        :param str description: description of the plan
        :param str id: id of the plan
        :param bool legacy: flag showing if it's a legacy plan
        :param str line: plan line, e.g. baremetal
        :param str name: name of the plan
        :param float pricing_hour: plan hourly price
        :param float pricing_month: plan monthly price
        :param str slug: plan slug
        """
        pulumi.set(__self__, "available_in_metros", available_in_metros)
        pulumi.set(__self__, "available_ins", available_ins)
        pulumi.set(__self__, "class_", class_)
        pulumi.set(__self__, "deployment_types", deployment_types)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "legacy", legacy)
        pulumi.set(__self__, "line", line)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "pricing_hour", pricing_hour)
        pulumi.set(__self__, "pricing_month", pricing_month)
        pulumi.set(__self__, "slug", slug)

    @property
    @pulumi.getter(name="availableInMetros")
    def available_in_metros(self) -> Sequence[str]:
        """
        list of metros where the plan is available
        """
        return pulumi.get(self, "available_in_metros")

    @property
    @pulumi.getter(name="availableIns")
    @_utilities.deprecated("""Use available_in_metros instead.  For more information, read the migration guide: https://registry.terraform.io/providers/equinix/equinix/latest/docs/guides/migration_guide_facilities_to_metros_devices""")
    def available_ins(self) -> Sequence[str]:
        """
        (**Deprecated**) list of facilities where the plan is available
        """
        return pulumi.get(self, "available_ins")

    @property
    @pulumi.getter(name="class")
    def class_(self) -> str:
        """
        plan class
        """
        return pulumi.get(self, "class_")

    @property
    @pulumi.getter(name="deploymentTypes")
    def deployment_types(self) -> Sequence[str]:
        """
        list of deployment types, e.g. on_demand, spot_market
        """
        return pulumi.get(self, "deployment_types")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        description of the plan
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        id of the plan
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def legacy(self) -> bool:
        """
        flag showing if it's a legacy plan
        """
        return pulumi.get(self, "legacy")

    @property
    @pulumi.getter
    def line(self) -> str:
        """
        plan line, e.g. baremetal
        """
        return pulumi.get(self, "line")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        name of the plan
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="pricingHour")
    def pricing_hour(self) -> float:
        """
        plan hourly price
        """
        return pulumi.get(self, "pricing_hour")

    @property
    @pulumi.getter(name="pricingMonth")
    def pricing_month(self) -> float:
        """
        plan monthly price
        """
        return pulumi.get(self, "pricing_month")

    @property
    @pulumi.getter
    def slug(self) -> str:
        """
        plan slug
        """
        return pulumi.get(self, "slug")


@pulumi.output_type
class GetPlansSortResult(dict):
    def __init__(__self__, *,
                 attribute: str,
                 direction: Optional[str] = None):
        """
        :param str attribute: The attribute used to sort the results. Sort attributes are case-sensitive
        :param str direction: Sort results in ascending or descending order. Strings are sorted in alphabetical order. One of: asc, desc
        """
        pulumi.set(__self__, "attribute", attribute)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        """
        The attribute used to sort the results. Sort attributes are case-sensitive
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        Sort results in ascending or descending order. Strings are sorted in alphabetical order. One of: asc, desc
        """
        return pulumi.get(self, "direction")


@pulumi.output_type
class GetProjectBgpConfigResult(dict):
    def __init__(__self__, *,
                 asn: int,
                 deployment_type: str,
                 max_prefix: int,
                 md5: str,
                 status: str):
        """
        :param int asn: Autonomous System Number for local BGP deployment.
        :param str deployment_type: One of `private`, `public`.
        :param int max_prefix: The maximum number of route filters allowed per server.
        :param str md5: Password for BGP session in plaintext (not a checksum).
        :param str status: Status of BGP configuration in the project.
        """
        pulumi.set(__self__, "asn", asn)
        pulumi.set(__self__, "deployment_type", deployment_type)
        pulumi.set(__self__, "max_prefix", max_prefix)
        pulumi.set(__self__, "md5", md5)
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def asn(self) -> int:
        """
        Autonomous System Number for local BGP deployment.
        """
        return pulumi.get(self, "asn")

    @property
    @pulumi.getter(name="deploymentType")
    def deployment_type(self) -> str:
        """
        One of `private`, `public`.
        """
        return pulumi.get(self, "deployment_type")

    @property
    @pulumi.getter(name="maxPrefix")
    def max_prefix(self) -> int:
        """
        The maximum number of route filters allowed per server.
        """
        return pulumi.get(self, "max_prefix")

    @property
    @pulumi.getter
    def md5(self) -> str:
        """
        Password for BGP session in plaintext (not a checksum).
        """
        return pulumi.get(self, "md5")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of BGP configuration in the project.
        """
        return pulumi.get(self, "status")


