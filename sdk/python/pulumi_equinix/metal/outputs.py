# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'DeviceBehavior',
    'DeviceIpAddress',
    'DeviceNetwork',
    'DevicePort',
    'DeviceReinstall',
    'InterconnectionPort',
    'InterconnectionServiceToken',
    'OrganizationAddress',
    'ProjectBgpConfig',
    'SpotMarketRequestInstanceParameters',
    'GetDeviceBgpNeighborsBgpNeighborResult',
    'GetDeviceBgpNeighborsBgpNeighborRoutesInResult',
    'GetDeviceBgpNeighborsBgpNeighborRoutesOutResult',
    'GetDeviceNetworkResult',
    'GetDevicePortResult',
    'GetDevicesDeviceResult',
    'GetDevicesDeviceNetworkResult',
    'GetDevicesDevicePortResult',
    'GetDevicesFilterResult',
    'GetDevicesSortResult',
    'GetFacilityCapacityResult',
    'GetInterconnectionPortResult',
    'GetInterconnectionServiceTokenResult',
    'GetMetroCapacityResult',
    'GetOrganizationAddressResult',
    'GetPlansFilterResult',
    'GetPlansPlanResult',
    'GetPlansSortResult',
    'GetProjectBgpConfigResult',
]

@pulumi.output_type
class DeviceBehavior(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowChanges":
            suggest = "allow_changes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceBehavior. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceBehavior.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceBehavior.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_changes: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] allow_changes: List of attributes that are allowed to change without recreating the instance. Supported attributes: `custom_data`, `user_data`"
        """
        DeviceBehavior._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allow_changes=allow_changes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allow_changes: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if allow_changes is None and 'allowChanges' in kwargs:
            allow_changes = kwargs['allowChanges']

        if allow_changes is not None:
            _setter("allow_changes", allow_changes)

    @property
    @pulumi.getter(name="allowChanges")
    def allow_changes(self) -> Optional[Sequence[str]]:
        """
        List of attributes that are allowed to change without recreating the instance. Supported attributes: `custom_data`, `user_data`"
        """
        return pulumi.get(self, "allow_changes")


@pulumi.output_type
class DeviceIpAddress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "reservationIds":
            suggest = "reservation_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceIpAddress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceIpAddress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceIpAddress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 cidr: Optional[int] = None,
                 reservation_ids: Optional[Sequence[str]] = None):
        """
        :param str type: One of `private_ipv4`, `public_ipv4`, `public_ipv6`.
        :param int cidr: CIDR suffix for IP address block to be assigned, i.e. amount of addresses.
        :param Sequence[str] reservation_ids: List of UUIDs of IP block reservations
               from which the public IPv4 address should be taken.
               
               You can supply one `ip_address` block per IP address type. If you use the `ip_address` you must
               always pass a block for `private_ipv4`.
               
               To learn more about using the reserved IP addresses for new devices, see the examples in the
               metal.ReservedIpBlock documentation.
        """
        DeviceIpAddress._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            cidr=cidr,
            reservation_ids=reservation_ids,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: Optional[str] = None,
             cidr: Optional[int] = None,
             reservation_ids: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if type is None:
            raise TypeError("Missing 'type' argument")
        if reservation_ids is None and 'reservationIds' in kwargs:
            reservation_ids = kwargs['reservationIds']

        _setter("type", type)
        if cidr is not None:
            _setter("cidr", cidr)
        if reservation_ids is not None:
            _setter("reservation_ids", reservation_ids)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        One of `private_ipv4`, `public_ipv4`, `public_ipv6`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def cidr(self) -> Optional[int]:
        """
        CIDR suffix for IP address block to be assigned, i.e. amount of addresses.
        """
        return pulumi.get(self, "cidr")

    @property
    @pulumi.getter(name="reservationIds")
    def reservation_ids(self) -> Optional[Sequence[str]]:
        """
        List of UUIDs of IP block reservations
        from which the public IPv4 address should be taken.

        You can supply one `ip_address` block per IP address type. If you use the `ip_address` you must
        always pass a block for `private_ipv4`.

        To learn more about using the reserved IP addresses for new devices, see the examples in the
        metal.ReservedIpBlock documentation.
        """
        return pulumi.get(self, "reservation_ids")


@pulumi.output_type
class DeviceNetwork(dict):
    def __init__(__self__, *,
                 address: Optional[str] = None,
                 cidr: Optional[int] = None,
                 family: Optional[int] = None,
                 gateway: Optional[str] = None,
                 public: Optional[bool] = None):
        """
        :param str address: IPv4 or IPv6 address string.
        :param int cidr: CIDR suffix for IP address block to be assigned, i.e. amount of addresses.
        :param int family: IP version. One of `4`, `6`.
        :param str gateway: Address of router.
        :param bool public: Whether the address is routable from the Internet.
        """
        DeviceNetwork._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            address=address,
            cidr=cidr,
            family=family,
            gateway=gateway,
            public=public,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             address: Optional[str] = None,
             cidr: Optional[int] = None,
             family: Optional[int] = None,
             gateway: Optional[str] = None,
             public: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if address is not None:
            _setter("address", address)
        if cidr is not None:
            _setter("cidr", cidr)
        if family is not None:
            _setter("family", family)
        if gateway is not None:
            _setter("gateway", gateway)
        if public is not None:
            _setter("public", public)

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        """
        IPv4 or IPv6 address string.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def cidr(self) -> Optional[int]:
        """
        CIDR suffix for IP address block to be assigned, i.e. amount of addresses.
        """
        return pulumi.get(self, "cidr")

    @property
    @pulumi.getter
    def family(self) -> Optional[int]:
        """
        IP version. One of `4`, `6`.
        """
        return pulumi.get(self, "family")

    @property
    @pulumi.getter
    def gateway(self) -> Optional[str]:
        """
        Address of router.
        """
        return pulumi.get(self, "gateway")

    @property
    @pulumi.getter
    def public(self) -> Optional[bool]:
        """
        Whether the address is routable from the Internet.
        """
        return pulumi.get(self, "public")


@pulumi.output_type
class DevicePort(dict):
    def __init__(__self__, *,
                 bonded: Optional[bool] = None,
                 id: Optional[str] = None,
                 mac: Optional[str] = None,
                 name: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param bool bonded: Whether this port is part of a bond in bonded network setup.
        :param str id: ID of the port.
        :param str mac: MAC address assigned to the port.
        :param str name: Name of the port (e.g. `eth0`, or `bond0`).
        :param str type: One of `private_ipv4`, `public_ipv4`, `public_ipv6`.
        """
        DevicePort._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bonded=bonded,
            id=id,
            mac=mac,
            name=name,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bonded: Optional[bool] = None,
             id: Optional[str] = None,
             mac: Optional[str] = None,
             name: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if bonded is not None:
            _setter("bonded", bonded)
        if id is not None:
            _setter("id", id)
        if mac is not None:
            _setter("mac", mac)
        if name is not None:
            _setter("name", name)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def bonded(self) -> Optional[bool]:
        """
        Whether this port is part of a bond in bonded network setup.
        """
        return pulumi.get(self, "bonded")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the port.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def mac(self) -> Optional[str]:
        """
        MAC address assigned to the port.
        """
        return pulumi.get(self, "mac")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the port (e.g. `eth0`, or `bond0`).
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        One of `private_ipv4`, `public_ipv4`, `public_ipv6`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DeviceReinstall(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deprovisionFast":
            suggest = "deprovision_fast"
        elif key == "preserveData":
            suggest = "preserve_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceReinstall. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceReinstall.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceReinstall.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 deprovision_fast: Optional[bool] = None,
                 enabled: Optional[bool] = None,
                 preserve_data: Optional[bool] = None):
        """
        :param bool deprovision_fast: Whether the OS disk should be filled with `00h` bytes before reinstall.
               Defaults to `false`.
        :param bool enabled: Whether the provider should favour reinstall over destroy and create. Defaults to
               `false`.
        :param bool preserve_data: Whether the non-OS disks should be kept or wiped during reinstall.
               Defaults to `false`.
        """
        DeviceReinstall._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            deprovision_fast=deprovision_fast,
            enabled=enabled,
            preserve_data=preserve_data,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             deprovision_fast: Optional[bool] = None,
             enabled: Optional[bool] = None,
             preserve_data: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if deprovision_fast is None and 'deprovisionFast' in kwargs:
            deprovision_fast = kwargs['deprovisionFast']
        if preserve_data is None and 'preserveData' in kwargs:
            preserve_data = kwargs['preserveData']

        if deprovision_fast is not None:
            _setter("deprovision_fast", deprovision_fast)
        if enabled is not None:
            _setter("enabled", enabled)
        if preserve_data is not None:
            _setter("preserve_data", preserve_data)

    @property
    @pulumi.getter(name="deprovisionFast")
    def deprovision_fast(self) -> Optional[bool]:
        """
        Whether the OS disk should be filled with `00h` bytes before reinstall.
        Defaults to `false`.
        """
        return pulumi.get(self, "deprovision_fast")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Whether the provider should favour reinstall over destroy and create. Defaults to
        `false`.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="preserveData")
    def preserve_data(self) -> Optional[bool]:
        """
        Whether the non-OS disks should be kept or wiped during reinstall.
        Defaults to `false`.
        """
        return pulumi.get(self, "preserve_data")


@pulumi.output_type
class InterconnectionPort(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "linkStatus":
            suggest = "link_status"
        elif key == "virtualCircuitIds":
            suggest = "virtual_circuit_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InterconnectionPort. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InterconnectionPort.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InterconnectionPort.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: Optional[str] = None,
                 link_status: Optional[str] = None,
                 name: Optional[str] = None,
                 role: Optional[str] = None,
                 speed: Optional[int] = None,
                 status: Optional[str] = None,
                 virtual_circuit_ids: Optional[Sequence[Any]] = None):
        """
        :param str name: Name of the connection resource
        :param int speed: Connection speed - one of 50Mbps, 200Mbps, 500Mbps, 1Gbps, 2Gbps, 5Gbps, 10Gbps.
        :param str status: Status of the connection resource.
        """
        InterconnectionPort._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            link_status=link_status,
            name=name,
            role=role,
            speed=speed,
            status=status,
            virtual_circuit_ids=virtual_circuit_ids,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             link_status: Optional[str] = None,
             name: Optional[str] = None,
             role: Optional[str] = None,
             speed: Optional[int] = None,
             status: Optional[str] = None,
             virtual_circuit_ids: Optional[Sequence[Any]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if link_status is None and 'linkStatus' in kwargs:
            link_status = kwargs['linkStatus']
        if virtual_circuit_ids is None and 'virtualCircuitIds' in kwargs:
            virtual_circuit_ids = kwargs['virtualCircuitIds']

        if id is not None:
            _setter("id", id)
        if link_status is not None:
            _setter("link_status", link_status)
        if name is not None:
            _setter("name", name)
        if role is not None:
            _setter("role", role)
        if speed is not None:
            _setter("speed", speed)
        if status is not None:
            _setter("status", status)
        if virtual_circuit_ids is not None:
            _setter("virtual_circuit_ids", virtual_circuit_ids)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="linkStatus")
    def link_status(self) -> Optional[str]:
        return pulumi.get(self, "link_status")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the connection resource
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        return pulumi.get(self, "role")

    @property
    @pulumi.getter
    def speed(self) -> Optional[int]:
        """
        Connection speed - one of 50Mbps, 200Mbps, 500Mbps, 1Gbps, 2Gbps, 5Gbps, 10Gbps.
        """
        return pulumi.get(self, "speed")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Status of the connection resource.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="virtualCircuitIds")
    def virtual_circuit_ids(self) -> Optional[Sequence[Any]]:
        return pulumi.get(self, "virtual_circuit_ids")


@pulumi.output_type
class InterconnectionServiceToken(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "expiresAt":
            suggest = "expires_at"
        elif key == "maxAllowedSpeed":
            suggest = "max_allowed_speed"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InterconnectionServiceToken. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InterconnectionServiceToken.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InterconnectionServiceToken.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expires_at: Optional[str] = None,
                 id: Optional[str] = None,
                 max_allowed_speed: Optional[str] = None,
                 role: Optional[str] = None,
                 state: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str type: Connection type - dedicated or shared.
        """
        InterconnectionServiceToken._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            expires_at=expires_at,
            id=id,
            max_allowed_speed=max_allowed_speed,
            role=role,
            state=state,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             expires_at: Optional[str] = None,
             id: Optional[str] = None,
             max_allowed_speed: Optional[str] = None,
             role: Optional[str] = None,
             state: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if expires_at is None and 'expiresAt' in kwargs:
            expires_at = kwargs['expiresAt']
        if max_allowed_speed is None and 'maxAllowedSpeed' in kwargs:
            max_allowed_speed = kwargs['maxAllowedSpeed']

        if expires_at is not None:
            _setter("expires_at", expires_at)
        if id is not None:
            _setter("id", id)
        if max_allowed_speed is not None:
            _setter("max_allowed_speed", max_allowed_speed)
        if role is not None:
            _setter("role", role)
        if state is not None:
            _setter("state", state)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> Optional[str]:
        return pulumi.get(self, "expires_at")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="maxAllowedSpeed")
    def max_allowed_speed(self) -> Optional[str]:
        return pulumi.get(self, "max_allowed_speed")

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        return pulumi.get(self, "role")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Connection type - dedicated or shared.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class OrganizationAddress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "zipCode":
            suggest = "zip_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrganizationAddress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrganizationAddress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrganizationAddress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: str,
                 city: str,
                 country: str,
                 zip_code: str,
                 state: Optional[str] = None):
        """
        :param str address: Postal address.
        :param str city: City name.
        :param str country: Two letter country code (ISO 3166-1 alpha-2), e.g. US.
        :param str zip_code: Zip Code.
        :param str state: State name.
        """
        OrganizationAddress._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            address=address,
            city=city,
            country=country,
            zip_code=zip_code,
            state=state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             address: Optional[str] = None,
             city: Optional[str] = None,
             country: Optional[str] = None,
             zip_code: Optional[str] = None,
             state: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if address is None:
            raise TypeError("Missing 'address' argument")
        if city is None:
            raise TypeError("Missing 'city' argument")
        if country is None:
            raise TypeError("Missing 'country' argument")
        if zip_code is None and 'zipCode' in kwargs:
            zip_code = kwargs['zipCode']
        if zip_code is None:
            raise TypeError("Missing 'zip_code' argument")

        _setter("address", address)
        _setter("city", city)
        _setter("country", country)
        _setter("zip_code", zip_code)
        if state is not None:
            _setter("state", state)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        Postal address.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def city(self) -> str:
        """
        City name.
        """
        return pulumi.get(self, "city")

    @property
    @pulumi.getter
    def country(self) -> str:
        """
        Two letter country code (ISO 3166-1 alpha-2), e.g. US.
        """
        return pulumi.get(self, "country")

    @property
    @pulumi.getter(name="zipCode")
    def zip_code(self) -> str:
        """
        Zip Code.
        """
        return pulumi.get(self, "zip_code")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        State name.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class ProjectBgpConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deploymentType":
            suggest = "deployment_type"
        elif key == "maxPrefix":
            suggest = "max_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectBgpConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectBgpConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectBgpConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 asn: int,
                 deployment_type: str,
                 max_prefix: Optional[int] = None,
                 md5: Optional[str] = None,
                 status: Optional[str] = None):
        """
        :param int asn: Autonomous System Number for local BGP deployment.
        :param str deployment_type: `local` or `global`, the `local` is likely to be usable immediately, the
               `global` will need to be reviewed by Equinix Metal engineers.
        :param int max_prefix: The maximum number of route filters allowed per server.
        :param str md5: Password for BGP session in plaintext (not a checksum).
        :param str status: status of BGP configuration in the project.
        """
        ProjectBgpConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            asn=asn,
            deployment_type=deployment_type,
            max_prefix=max_prefix,
            md5=md5,
            status=status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             asn: Optional[int] = None,
             deployment_type: Optional[str] = None,
             max_prefix: Optional[int] = None,
             md5: Optional[str] = None,
             status: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if asn is None:
            raise TypeError("Missing 'asn' argument")
        if deployment_type is None and 'deploymentType' in kwargs:
            deployment_type = kwargs['deploymentType']
        if deployment_type is None:
            raise TypeError("Missing 'deployment_type' argument")
        if max_prefix is None and 'maxPrefix' in kwargs:
            max_prefix = kwargs['maxPrefix']

        _setter("asn", asn)
        _setter("deployment_type", deployment_type)
        if max_prefix is not None:
            _setter("max_prefix", max_prefix)
        if md5 is not None:
            _setter("md5", md5)
        if status is not None:
            _setter("status", status)

    @property
    @pulumi.getter
    def asn(self) -> int:
        """
        Autonomous System Number for local BGP deployment.
        """
        return pulumi.get(self, "asn")

    @property
    @pulumi.getter(name="deploymentType")
    def deployment_type(self) -> str:
        """
        `local` or `global`, the `local` is likely to be usable immediately, the
        `global` will need to be reviewed by Equinix Metal engineers.
        """
        return pulumi.get(self, "deployment_type")

    @property
    @pulumi.getter(name="maxPrefix")
    def max_prefix(self) -> Optional[int]:
        """
        The maximum number of route filters allowed per server.
        """
        return pulumi.get(self, "max_prefix")

    @property
    @pulumi.getter
    def md5(self) -> Optional[str]:
        """
        Password for BGP session in plaintext (not a checksum).
        """
        return pulumi.get(self, "md5")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        status of BGP configuration in the project.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class SpotMarketRequestInstanceParameters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "billingCycle":
            suggest = "billing_cycle"
        elif key == "operatingSystem":
            suggest = "operating_system"
        elif key == "alwaysPxe":
            suggest = "always_pxe"
        elif key == "ipxeScriptUrl":
            suggest = "ipxe_script_url"
        elif key == "projectSshKeys":
            suggest = "project_ssh_keys"
        elif key == "terminationTime":
            suggest = "termination_time"
        elif key == "termintationTime":
            suggest = "termintation_time"
        elif key == "userSshKeys":
            suggest = "user_ssh_keys"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotMarketRequestInstanceParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotMarketRequestInstanceParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotMarketRequestInstanceParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 billing_cycle: str,
                 hostname: str,
                 operating_system: str,
                 plan: str,
                 always_pxe: Optional[bool] = None,
                 customdata: Optional[str] = None,
                 description: Optional[str] = None,
                 features: Optional[Sequence[str]] = None,
                 ipxe_script_url: Optional[str] = None,
                 locked: Optional[bool] = None,
                 project_ssh_keys: Optional[Sequence[str]] = None,
                 tags: Optional[Sequence[str]] = None,
                 termination_time: Optional[str] = None,
                 termintation_time: Optional[str] = None,
                 user_ssh_keys: Optional[Sequence[str]] = None,
                 userdata: Optional[str] = None):
        """
        :param bool locked: Blocks deletion of the SpotMarketRequest device until the lock is disabled.
        """
        SpotMarketRequestInstanceParameters._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            billing_cycle=billing_cycle,
            hostname=hostname,
            operating_system=operating_system,
            plan=plan,
            always_pxe=always_pxe,
            customdata=customdata,
            description=description,
            features=features,
            ipxe_script_url=ipxe_script_url,
            locked=locked,
            project_ssh_keys=project_ssh_keys,
            tags=tags,
            termination_time=termination_time,
            termintation_time=termintation_time,
            user_ssh_keys=user_ssh_keys,
            userdata=userdata,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             billing_cycle: Optional[str] = None,
             hostname: Optional[str] = None,
             operating_system: Optional[str] = None,
             plan: Optional[str] = None,
             always_pxe: Optional[bool] = None,
             customdata: Optional[str] = None,
             description: Optional[str] = None,
             features: Optional[Sequence[str]] = None,
             ipxe_script_url: Optional[str] = None,
             locked: Optional[bool] = None,
             project_ssh_keys: Optional[Sequence[str]] = None,
             tags: Optional[Sequence[str]] = None,
             termination_time: Optional[str] = None,
             termintation_time: Optional[str] = None,
             user_ssh_keys: Optional[Sequence[str]] = None,
             userdata: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if billing_cycle is None and 'billingCycle' in kwargs:
            billing_cycle = kwargs['billingCycle']
        if billing_cycle is None:
            raise TypeError("Missing 'billing_cycle' argument")
        if hostname is None:
            raise TypeError("Missing 'hostname' argument")
        if operating_system is None and 'operatingSystem' in kwargs:
            operating_system = kwargs['operatingSystem']
        if operating_system is None:
            raise TypeError("Missing 'operating_system' argument")
        if plan is None:
            raise TypeError("Missing 'plan' argument")
        if always_pxe is None and 'alwaysPxe' in kwargs:
            always_pxe = kwargs['alwaysPxe']
        if ipxe_script_url is None and 'ipxeScriptUrl' in kwargs:
            ipxe_script_url = kwargs['ipxeScriptUrl']
        if project_ssh_keys is None and 'projectSshKeys' in kwargs:
            project_ssh_keys = kwargs['projectSshKeys']
        if termination_time is None and 'terminationTime' in kwargs:
            termination_time = kwargs['terminationTime']
        if termintation_time is None and 'termintationTime' in kwargs:
            termintation_time = kwargs['termintationTime']
        if user_ssh_keys is None and 'userSshKeys' in kwargs:
            user_ssh_keys = kwargs['userSshKeys']

        _setter("billing_cycle", billing_cycle)
        _setter("hostname", hostname)
        _setter("operating_system", operating_system)
        _setter("plan", plan)
        if always_pxe is not None:
            _setter("always_pxe", always_pxe)
        if customdata is not None:
            _setter("customdata", customdata)
        if description is not None:
            _setter("description", description)
        if features is not None:
            _setter("features", features)
        if ipxe_script_url is not None:
            _setter("ipxe_script_url", ipxe_script_url)
        if locked is not None:
            _setter("locked", locked)
        if project_ssh_keys is not None:
            _setter("project_ssh_keys", project_ssh_keys)
        if tags is not None:
            _setter("tags", tags)
        if termination_time is not None:
            _setter("termination_time", termination_time)
        if termintation_time is not None:
            _setter("termintation_time", termintation_time)
        if user_ssh_keys is not None:
            _setter("user_ssh_keys", user_ssh_keys)
        if userdata is not None:
            _setter("userdata", userdata)

    @property
    @pulumi.getter(name="billingCycle")
    def billing_cycle(self) -> str:
        return pulumi.get(self, "billing_cycle")

    @property
    @pulumi.getter
    def hostname(self) -> str:
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter(name="operatingSystem")
    def operating_system(self) -> str:
        return pulumi.get(self, "operating_system")

    @property
    @pulumi.getter
    def plan(self) -> str:
        return pulumi.get(self, "plan")

    @property
    @pulumi.getter(name="alwaysPxe")
    def always_pxe(self) -> Optional[bool]:
        return pulumi.get(self, "always_pxe")

    @property
    @pulumi.getter
    def customdata(self) -> Optional[str]:
        return pulumi.get(self, "customdata")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def features(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "features")

    @property
    @pulumi.getter(name="ipxeScriptUrl")
    def ipxe_script_url(self) -> Optional[str]:
        return pulumi.get(self, "ipxe_script_url")

    @property
    @pulumi.getter
    def locked(self) -> Optional[bool]:
        """
        Blocks deletion of the SpotMarketRequest device until the lock is disabled.
        """
        return pulumi.get(self, "locked")

    @property
    @pulumi.getter(name="projectSshKeys")
    def project_ssh_keys(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "project_ssh_keys")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="terminationTime")
    def termination_time(self) -> Optional[str]:
        return pulumi.get(self, "termination_time")

    @property
    @pulumi.getter(name="termintationTime")
    def termintation_time(self) -> Optional[str]:
        warnings.warn("""Use instance_parameters.termination_time instead""", DeprecationWarning)
        pulumi.log.warn("""termintation_time is deprecated: Use instance_parameters.termination_time instead""")

        return pulumi.get(self, "termintation_time")

    @property
    @pulumi.getter(name="userSshKeys")
    def user_ssh_keys(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "user_ssh_keys")

    @property
    @pulumi.getter
    def userdata(self) -> Optional[str]:
        return pulumi.get(self, "userdata")


@pulumi.output_type
class GetDeviceBgpNeighborsBgpNeighborResult(dict):
    def __init__(__self__, *,
                 address_family: int,
                 customer_as: int,
                 customer_ip: str,
                 md5_enabled: bool,
                 md5_password: str,
                 multihop: bool,
                 peer_as: int,
                 routes_ins: Sequence['outputs.GetDeviceBgpNeighborsBgpNeighborRoutesInResult'],
                 routes_outs: Sequence['outputs.GetDeviceBgpNeighborsBgpNeighborRoutesOutResult'],
                 peer_ips: Optional[Sequence[str]] = None):
        """
        :param int address_family: IP address version, 4 or 6.
        :param int customer_as: Local autonomous system number.
        :param str customer_ip: Local used peer IP address.
        :param bool md5_enabled: Whether BGP session is password enabled.
        :param str md5_password: BGP session password in plaintext (not a checksum).
        :param bool multihop: Whether the neighbor is in EBGP multihop session.
        :param int peer_as: Peer AS number (different than customer_as for EBGP).
        :param Sequence['GetDeviceBgpNeighborsBgpNeighborRoutesInArgs'] routes_ins: Array of incoming routes.
        :param Sequence['GetDeviceBgpNeighborsBgpNeighborRoutesOutArgs'] routes_outs: Array of outgoing routes in the same format.
        :param Sequence[str] peer_ips: Array of IP addresses of this neighbor's peers.
        """
        GetDeviceBgpNeighborsBgpNeighborResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            address_family=address_family,
            customer_as=customer_as,
            customer_ip=customer_ip,
            md5_enabled=md5_enabled,
            md5_password=md5_password,
            multihop=multihop,
            peer_as=peer_as,
            routes_ins=routes_ins,
            routes_outs=routes_outs,
            peer_ips=peer_ips,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             address_family: Optional[int] = None,
             customer_as: Optional[int] = None,
             customer_ip: Optional[str] = None,
             md5_enabled: Optional[bool] = None,
             md5_password: Optional[str] = None,
             multihop: Optional[bool] = None,
             peer_as: Optional[int] = None,
             routes_ins: Optional[Sequence['outputs.GetDeviceBgpNeighborsBgpNeighborRoutesInResult']] = None,
             routes_outs: Optional[Sequence['outputs.GetDeviceBgpNeighborsBgpNeighborRoutesOutResult']] = None,
             peer_ips: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if address_family is None and 'addressFamily' in kwargs:
            address_family = kwargs['addressFamily']
        if address_family is None:
            raise TypeError("Missing 'address_family' argument")
        if customer_as is None and 'customerAs' in kwargs:
            customer_as = kwargs['customerAs']
        if customer_as is None:
            raise TypeError("Missing 'customer_as' argument")
        if customer_ip is None and 'customerIp' in kwargs:
            customer_ip = kwargs['customerIp']
        if customer_ip is None:
            raise TypeError("Missing 'customer_ip' argument")
        if md5_enabled is None and 'md5Enabled' in kwargs:
            md5_enabled = kwargs['md5Enabled']
        if md5_enabled is None:
            raise TypeError("Missing 'md5_enabled' argument")
        if md5_password is None and 'md5Password' in kwargs:
            md5_password = kwargs['md5Password']
        if md5_password is None:
            raise TypeError("Missing 'md5_password' argument")
        if multihop is None:
            raise TypeError("Missing 'multihop' argument")
        if peer_as is None and 'peerAs' in kwargs:
            peer_as = kwargs['peerAs']
        if peer_as is None:
            raise TypeError("Missing 'peer_as' argument")
        if routes_ins is None and 'routesIns' in kwargs:
            routes_ins = kwargs['routesIns']
        if routes_ins is None:
            raise TypeError("Missing 'routes_ins' argument")
        if routes_outs is None and 'routesOuts' in kwargs:
            routes_outs = kwargs['routesOuts']
        if routes_outs is None:
            raise TypeError("Missing 'routes_outs' argument")
        if peer_ips is None and 'peerIps' in kwargs:
            peer_ips = kwargs['peerIps']

        _setter("address_family", address_family)
        _setter("customer_as", customer_as)
        _setter("customer_ip", customer_ip)
        _setter("md5_enabled", md5_enabled)
        _setter("md5_password", md5_password)
        _setter("multihop", multihop)
        _setter("peer_as", peer_as)
        _setter("routes_ins", routes_ins)
        _setter("routes_outs", routes_outs)
        if peer_ips is not None:
            _setter("peer_ips", peer_ips)

    @property
    @pulumi.getter(name="addressFamily")
    def address_family(self) -> int:
        """
        IP address version, 4 or 6.
        """
        return pulumi.get(self, "address_family")

    @property
    @pulumi.getter(name="customerAs")
    def customer_as(self) -> int:
        """
        Local autonomous system number.
        """
        return pulumi.get(self, "customer_as")

    @property
    @pulumi.getter(name="customerIp")
    def customer_ip(self) -> str:
        """
        Local used peer IP address.
        """
        return pulumi.get(self, "customer_ip")

    @property
    @pulumi.getter(name="md5Enabled")
    def md5_enabled(self) -> bool:
        """
        Whether BGP session is password enabled.
        """
        return pulumi.get(self, "md5_enabled")

    @property
    @pulumi.getter(name="md5Password")
    def md5_password(self) -> str:
        """
        BGP session password in plaintext (not a checksum).
        """
        return pulumi.get(self, "md5_password")

    @property
    @pulumi.getter
    def multihop(self) -> bool:
        """
        Whether the neighbor is in EBGP multihop session.
        """
        return pulumi.get(self, "multihop")

    @property
    @pulumi.getter(name="peerAs")
    def peer_as(self) -> int:
        """
        Peer AS number (different than customer_as for EBGP).
        """
        return pulumi.get(self, "peer_as")

    @property
    @pulumi.getter(name="routesIns")
    def routes_ins(self) -> Sequence['outputs.GetDeviceBgpNeighborsBgpNeighborRoutesInResult']:
        """
        Array of incoming routes.
        """
        return pulumi.get(self, "routes_ins")

    @property
    @pulumi.getter(name="routesOuts")
    def routes_outs(self) -> Sequence['outputs.GetDeviceBgpNeighborsBgpNeighborRoutesOutResult']:
        """
        Array of outgoing routes in the same format.
        """
        return pulumi.get(self, "routes_outs")

    @property
    @pulumi.getter(name="peerIps")
    def peer_ips(self) -> Optional[Sequence[str]]:
        """
        Array of IP addresses of this neighbor's peers.
        """
        return pulumi.get(self, "peer_ips")


@pulumi.output_type
class GetDeviceBgpNeighborsBgpNeighborRoutesInResult(dict):
    def __init__(__self__, *,
                 exact: bool,
                 route: str):
        """
        :param bool exact: (bool) Whether the route is exact.
        :param str route: CIDR expression of route (IP/mask).
        """
        GetDeviceBgpNeighborsBgpNeighborRoutesInResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exact=exact,
            route=route,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exact: Optional[bool] = None,
             route: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if exact is None:
            raise TypeError("Missing 'exact' argument")
        if route is None:
            raise TypeError("Missing 'route' argument")

        _setter("exact", exact)
        _setter("route", route)

    @property
    @pulumi.getter
    def exact(self) -> bool:
        """
        (bool) Whether the route is exact.
        """
        return pulumi.get(self, "exact")

    @property
    @pulumi.getter
    def route(self) -> str:
        """
        CIDR expression of route (IP/mask).
        """
        return pulumi.get(self, "route")


@pulumi.output_type
class GetDeviceBgpNeighborsBgpNeighborRoutesOutResult(dict):
    def __init__(__self__, *,
                 exact: bool,
                 route: str):
        """
        :param bool exact: (bool) Whether the route is exact.
        :param str route: CIDR expression of route (IP/mask).
        """
        GetDeviceBgpNeighborsBgpNeighborRoutesOutResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exact=exact,
            route=route,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exact: Optional[bool] = None,
             route: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if exact is None:
            raise TypeError("Missing 'exact' argument")
        if route is None:
            raise TypeError("Missing 'route' argument")

        _setter("exact", exact)
        _setter("route", route)

    @property
    @pulumi.getter
    def exact(self) -> bool:
        """
        (bool) Whether the route is exact.
        """
        return pulumi.get(self, "exact")

    @property
    @pulumi.getter
    def route(self) -> str:
        """
        CIDR expression of route (IP/mask).
        """
        return pulumi.get(self, "route")


@pulumi.output_type
class GetDeviceNetworkResult(dict):
    def __init__(__self__, *,
                 address: str,
                 cidr: int,
                 family: int,
                 gateway: str,
                 public: bool):
        """
        :param str address: IPv4 or IPv6 address string.
        :param int cidr: Bit length of the network mask of the address.
        :param int family: IP version. One of `4`, `6`.
        :param str gateway: Address of router.
        :param bool public: Whether the address is routable from the Internet.
        """
        GetDeviceNetworkResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            address=address,
            cidr=cidr,
            family=family,
            gateway=gateway,
            public=public,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             address: Optional[str] = None,
             cidr: Optional[int] = None,
             family: Optional[int] = None,
             gateway: Optional[str] = None,
             public: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if address is None:
            raise TypeError("Missing 'address' argument")
        if cidr is None:
            raise TypeError("Missing 'cidr' argument")
        if family is None:
            raise TypeError("Missing 'family' argument")
        if gateway is None:
            raise TypeError("Missing 'gateway' argument")
        if public is None:
            raise TypeError("Missing 'public' argument")

        _setter("address", address)
        _setter("cidr", cidr)
        _setter("family", family)
        _setter("gateway", gateway)
        _setter("public", public)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        IPv4 or IPv6 address string.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def cidr(self) -> int:
        """
        Bit length of the network mask of the address.
        """
        return pulumi.get(self, "cidr")

    @property
    @pulumi.getter
    def family(self) -> int:
        """
        IP version. One of `4`, `6`.
        """
        return pulumi.get(self, "family")

    @property
    @pulumi.getter
    def gateway(self) -> str:
        """
        Address of router.
        """
        return pulumi.get(self, "gateway")

    @property
    @pulumi.getter
    def public(self) -> bool:
        """
        Whether the address is routable from the Internet.
        """
        return pulumi.get(self, "public")


@pulumi.output_type
class GetDevicePortResult(dict):
    def __init__(__self__, *,
                 bonded: bool,
                 id: str,
                 mac: str,
                 name: str,
                 type: str):
        """
        :param bool bonded: Whether this port is part of a bond in bonded network setup.
        :param str id: ID of the port.
        :param str mac: MAC address assigned to the port.
        :param str name: Name of the port (e.g. `eth0`, or `bond0`).
        :param str type: Type of the port (e.g. `NetworkPort` or `NetworkBondPort`).
        """
        GetDevicePortResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bonded=bonded,
            id=id,
            mac=mac,
            name=name,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bonded: Optional[bool] = None,
             id: Optional[str] = None,
             mac: Optional[str] = None,
             name: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if bonded is None:
            raise TypeError("Missing 'bonded' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if mac is None:
            raise TypeError("Missing 'mac' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("bonded", bonded)
        _setter("id", id)
        _setter("mac", mac)
        _setter("name", name)
        _setter("type", type)

    @property
    @pulumi.getter
    def bonded(self) -> bool:
        """
        Whether this port is part of a bond in bonded network setup.
        """
        return pulumi.get(self, "bonded")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of the port.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def mac(self) -> str:
        """
        MAC address assigned to the port.
        """
        return pulumi.get(self, "mac")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the port (e.g. `eth0`, or `bond0`).
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of the port (e.g. `NetworkPort` or `NetworkBondPort`).
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetDevicesDeviceResult(dict):
    def __init__(__self__, *,
                 access_private_ipv4: str,
                 access_public_ipv4: str,
                 access_public_ipv6: str,
                 always_pxe: bool,
                 billing_cycle: str,
                 description: str,
                 device_id: str,
                 facility: str,
                 hardware_reservation_id: str,
                 hostname: str,
                 ipxe_script_url: str,
                 metro: str,
                 network_type: str,
                 networks: Sequence['outputs.GetDevicesDeviceNetworkResult'],
                 operating_system: str,
                 plan: str,
                 ports: Sequence['outputs.GetDevicesDevicePortResult'],
                 project_id: str,
                 root_password: str,
                 ssh_key_ids: Sequence[str],
                 state: str,
                 storage: str,
                 tags: Sequence[str]):
        """
        :param str project_id: ID of project containing the devices. Exactly one of `project_id` and `organization_id` must be set.
        """
        GetDevicesDeviceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            access_private_ipv4=access_private_ipv4,
            access_public_ipv4=access_public_ipv4,
            access_public_ipv6=access_public_ipv6,
            always_pxe=always_pxe,
            billing_cycle=billing_cycle,
            description=description,
            device_id=device_id,
            facility=facility,
            hardware_reservation_id=hardware_reservation_id,
            hostname=hostname,
            ipxe_script_url=ipxe_script_url,
            metro=metro,
            network_type=network_type,
            networks=networks,
            operating_system=operating_system,
            plan=plan,
            ports=ports,
            project_id=project_id,
            root_password=root_password,
            ssh_key_ids=ssh_key_ids,
            state=state,
            storage=storage,
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             access_private_ipv4: Optional[str] = None,
             access_public_ipv4: Optional[str] = None,
             access_public_ipv6: Optional[str] = None,
             always_pxe: Optional[bool] = None,
             billing_cycle: Optional[str] = None,
             description: Optional[str] = None,
             device_id: Optional[str] = None,
             facility: Optional[str] = None,
             hardware_reservation_id: Optional[str] = None,
             hostname: Optional[str] = None,
             ipxe_script_url: Optional[str] = None,
             metro: Optional[str] = None,
             network_type: Optional[str] = None,
             networks: Optional[Sequence['outputs.GetDevicesDeviceNetworkResult']] = None,
             operating_system: Optional[str] = None,
             plan: Optional[str] = None,
             ports: Optional[Sequence['outputs.GetDevicesDevicePortResult']] = None,
             project_id: Optional[str] = None,
             root_password: Optional[str] = None,
             ssh_key_ids: Optional[Sequence[str]] = None,
             state: Optional[str] = None,
             storage: Optional[str] = None,
             tags: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if access_private_ipv4 is None and 'accessPrivateIpv4' in kwargs:
            access_private_ipv4 = kwargs['accessPrivateIpv4']
        if access_private_ipv4 is None:
            raise TypeError("Missing 'access_private_ipv4' argument")
        if access_public_ipv4 is None and 'accessPublicIpv4' in kwargs:
            access_public_ipv4 = kwargs['accessPublicIpv4']
        if access_public_ipv4 is None:
            raise TypeError("Missing 'access_public_ipv4' argument")
        if access_public_ipv6 is None and 'accessPublicIpv6' in kwargs:
            access_public_ipv6 = kwargs['accessPublicIpv6']
        if access_public_ipv6 is None:
            raise TypeError("Missing 'access_public_ipv6' argument")
        if always_pxe is None and 'alwaysPxe' in kwargs:
            always_pxe = kwargs['alwaysPxe']
        if always_pxe is None:
            raise TypeError("Missing 'always_pxe' argument")
        if billing_cycle is None and 'billingCycle' in kwargs:
            billing_cycle = kwargs['billingCycle']
        if billing_cycle is None:
            raise TypeError("Missing 'billing_cycle' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if device_id is None and 'deviceId' in kwargs:
            device_id = kwargs['deviceId']
        if device_id is None:
            raise TypeError("Missing 'device_id' argument")
        if facility is None:
            raise TypeError("Missing 'facility' argument")
        if hardware_reservation_id is None and 'hardwareReservationId' in kwargs:
            hardware_reservation_id = kwargs['hardwareReservationId']
        if hardware_reservation_id is None:
            raise TypeError("Missing 'hardware_reservation_id' argument")
        if hostname is None:
            raise TypeError("Missing 'hostname' argument")
        if ipxe_script_url is None and 'ipxeScriptUrl' in kwargs:
            ipxe_script_url = kwargs['ipxeScriptUrl']
        if ipxe_script_url is None:
            raise TypeError("Missing 'ipxe_script_url' argument")
        if metro is None:
            raise TypeError("Missing 'metro' argument")
        if network_type is None and 'networkType' in kwargs:
            network_type = kwargs['networkType']
        if network_type is None:
            raise TypeError("Missing 'network_type' argument")
        if networks is None:
            raise TypeError("Missing 'networks' argument")
        if operating_system is None and 'operatingSystem' in kwargs:
            operating_system = kwargs['operatingSystem']
        if operating_system is None:
            raise TypeError("Missing 'operating_system' argument")
        if plan is None:
            raise TypeError("Missing 'plan' argument")
        if ports is None:
            raise TypeError("Missing 'ports' argument")
        if project_id is None and 'projectId' in kwargs:
            project_id = kwargs['projectId']
        if project_id is None:
            raise TypeError("Missing 'project_id' argument")
        if root_password is None and 'rootPassword' in kwargs:
            root_password = kwargs['rootPassword']
        if root_password is None:
            raise TypeError("Missing 'root_password' argument")
        if ssh_key_ids is None and 'sshKeyIds' in kwargs:
            ssh_key_ids = kwargs['sshKeyIds']
        if ssh_key_ids is None:
            raise TypeError("Missing 'ssh_key_ids' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if storage is None:
            raise TypeError("Missing 'storage' argument")
        if tags is None:
            raise TypeError("Missing 'tags' argument")

        _setter("access_private_ipv4", access_private_ipv4)
        _setter("access_public_ipv4", access_public_ipv4)
        _setter("access_public_ipv6", access_public_ipv6)
        _setter("always_pxe", always_pxe)
        _setter("billing_cycle", billing_cycle)
        _setter("description", description)
        _setter("device_id", device_id)
        _setter("facility", facility)
        _setter("hardware_reservation_id", hardware_reservation_id)
        _setter("hostname", hostname)
        _setter("ipxe_script_url", ipxe_script_url)
        _setter("metro", metro)
        _setter("network_type", network_type)
        _setter("networks", networks)
        _setter("operating_system", operating_system)
        _setter("plan", plan)
        _setter("ports", ports)
        _setter("project_id", project_id)
        _setter("root_password", root_password)
        _setter("ssh_key_ids", ssh_key_ids)
        _setter("state", state)
        _setter("storage", storage)
        _setter("tags", tags)

    @property
    @pulumi.getter(name="accessPrivateIpv4")
    def access_private_ipv4(self) -> str:
        return pulumi.get(self, "access_private_ipv4")

    @property
    @pulumi.getter(name="accessPublicIpv4")
    def access_public_ipv4(self) -> str:
        return pulumi.get(self, "access_public_ipv4")

    @property
    @pulumi.getter(name="accessPublicIpv6")
    def access_public_ipv6(self) -> str:
        return pulumi.get(self, "access_public_ipv6")

    @property
    @pulumi.getter(name="alwaysPxe")
    def always_pxe(self) -> bool:
        return pulumi.get(self, "always_pxe")

    @property
    @pulumi.getter(name="billingCycle")
    def billing_cycle(self) -> str:
        return pulumi.get(self, "billing_cycle")

    @property
    @pulumi.getter
    def description(self) -> str:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="deviceId")
    def device_id(self) -> str:
        return pulumi.get(self, "device_id")

    @property
    @pulumi.getter
    def facility(self) -> str:
        warnings.warn("""Use metro instead of facility.  For more information, read the migration guide: https://registry.terraform.io/providers/equinix/equinix/latest/docs/guides/migration_guide_facilities_to_metros_devices""", DeprecationWarning)
        pulumi.log.warn("""facility is deprecated: Use metro instead of facility.  For more information, read the migration guide: https://registry.terraform.io/providers/equinix/equinix/latest/docs/guides/migration_guide_facilities_to_metros_devices""")

        return pulumi.get(self, "facility")

    @property
    @pulumi.getter(name="hardwareReservationId")
    def hardware_reservation_id(self) -> str:
        return pulumi.get(self, "hardware_reservation_id")

    @property
    @pulumi.getter
    def hostname(self) -> str:
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter(name="ipxeScriptUrl")
    def ipxe_script_url(self) -> str:
        return pulumi.get(self, "ipxe_script_url")

    @property
    @pulumi.getter
    def metro(self) -> str:
        return pulumi.get(self, "metro")

    @property
    @pulumi.getter(name="networkType")
    def network_type(self) -> str:
        return pulumi.get(self, "network_type")

    @property
    @pulumi.getter
    def networks(self) -> Sequence['outputs.GetDevicesDeviceNetworkResult']:
        return pulumi.get(self, "networks")

    @property
    @pulumi.getter(name="operatingSystem")
    def operating_system(self) -> str:
        return pulumi.get(self, "operating_system")

    @property
    @pulumi.getter
    def plan(self) -> str:
        return pulumi.get(self, "plan")

    @property
    @pulumi.getter
    def ports(self) -> Sequence['outputs.GetDevicesDevicePortResult']:
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        ID of project containing the devices. Exactly one of `project_id` and `organization_id` must be set.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter(name="rootPassword")
    def root_password(self) -> str:
        return pulumi.get(self, "root_password")

    @property
    @pulumi.getter(name="sshKeyIds")
    def ssh_key_ids(self) -> Sequence[str]:
        return pulumi.get(self, "ssh_key_ids")

    @property
    @pulumi.getter
    def state(self) -> str:
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def storage(self) -> str:
        return pulumi.get(self, "storage")

    @property
    @pulumi.getter
    def tags(self) -> Sequence[str]:
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetDevicesDeviceNetworkResult(dict):
    def __init__(__self__, *,
                 address: str,
                 cidr: int,
                 family: int,
                 gateway: str,
                 public: bool):
        GetDevicesDeviceNetworkResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            address=address,
            cidr=cidr,
            family=family,
            gateway=gateway,
            public=public,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             address: Optional[str] = None,
             cidr: Optional[int] = None,
             family: Optional[int] = None,
             gateway: Optional[str] = None,
             public: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if address is None:
            raise TypeError("Missing 'address' argument")
        if cidr is None:
            raise TypeError("Missing 'cidr' argument")
        if family is None:
            raise TypeError("Missing 'family' argument")
        if gateway is None:
            raise TypeError("Missing 'gateway' argument")
        if public is None:
            raise TypeError("Missing 'public' argument")

        _setter("address", address)
        _setter("cidr", cidr)
        _setter("family", family)
        _setter("gateway", gateway)
        _setter("public", public)

    @property
    @pulumi.getter
    def address(self) -> str:
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def cidr(self) -> int:
        return pulumi.get(self, "cidr")

    @property
    @pulumi.getter
    def family(self) -> int:
        return pulumi.get(self, "family")

    @property
    @pulumi.getter
    def gateway(self) -> str:
        return pulumi.get(self, "gateway")

    @property
    @pulumi.getter
    def public(self) -> bool:
        return pulumi.get(self, "public")


@pulumi.output_type
class GetDevicesDevicePortResult(dict):
    def __init__(__self__, *,
                 bonded: bool,
                 id: str,
                 mac: str,
                 name: str,
                 type: str):
        GetDevicesDevicePortResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bonded=bonded,
            id=id,
            mac=mac,
            name=name,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bonded: Optional[bool] = None,
             id: Optional[str] = None,
             mac: Optional[str] = None,
             name: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if bonded is None:
            raise TypeError("Missing 'bonded' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if mac is None:
            raise TypeError("Missing 'mac' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("bonded", bonded)
        _setter("id", id)
        _setter("mac", mac)
        _setter("name", name)
        _setter("type", type)

    @property
    @pulumi.getter
    def bonded(self) -> bool:
        return pulumi.get(self, "bonded")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def mac(self) -> str:
        return pulumi.get(self, "mac")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetDevicesFilterResult(dict):
    def __init__(__self__, *,
                 attribute: str,
                 values: Sequence[str],
                 all: Optional[bool] = None,
                 match_by: Optional[str] = None):
        """
        :param str attribute: The attribute used to filter. Filter attributes are case-sensitive
        :param Sequence[str] values: The filter values. Filter values are case-sensitive. If you specify multiple values for a filter, the values are joined with an OR by default, and the request returns all results that match any of the specified values
        :param bool all: If is set to true, the values are joined with an AND, and the requests returns only the results that match all specified values. Default is `false`.
               
               All fields in the `devices` block defined below can be used as attribute for both `sort` and `filter` blocks.
        :param str match_by: The type of comparison to apply. One of: `in` , `re`, `substring`, `less_than`, `less_than_or_equal`, `greater_than`, `greater_than_or_equal`. Default is `in`.
        """
        GetDevicesFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            attribute=attribute,
            values=values,
            all=all,
            match_by=match_by,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             attribute: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             all: Optional[bool] = None,
             match_by: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if attribute is None:
            raise TypeError("Missing 'attribute' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")
        if match_by is None and 'matchBy' in kwargs:
            match_by = kwargs['matchBy']

        _setter("attribute", attribute)
        _setter("values", values)
        if all is not None:
            _setter("all", all)
        if match_by is not None:
            _setter("match_by", match_by)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        """
        The attribute used to filter. Filter attributes are case-sensitive
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        The filter values. Filter values are case-sensitive. If you specify multiple values for a filter, the values are joined with an OR by default, and the request returns all results that match any of the specified values
        """
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def all(self) -> Optional[bool]:
        """
        If is set to true, the values are joined with an AND, and the requests returns only the results that match all specified values. Default is `false`.

        All fields in the `devices` block defined below can be used as attribute for both `sort` and `filter` blocks.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="matchBy")
    def match_by(self) -> Optional[str]:
        """
        The type of comparison to apply. One of: `in` , `re`, `substring`, `less_than`, `less_than_or_equal`, `greater_than`, `greater_than_or_equal`. Default is `in`.
        """
        return pulumi.get(self, "match_by")


@pulumi.output_type
class GetDevicesSortResult(dict):
    def __init__(__self__, *,
                 attribute: str,
                 direction: Optional[str] = None):
        """
        :param str attribute: The attribute used to filter. Filter attributes are case-sensitive
        """
        GetDevicesSortResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            attribute=attribute,
            direction=direction,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             attribute: Optional[str] = None,
             direction: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if attribute is None:
            raise TypeError("Missing 'attribute' argument")

        _setter("attribute", attribute)
        if direction is not None:
            _setter("direction", direction)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        """
        The attribute used to filter. Filter attributes are case-sensitive
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        return pulumi.get(self, "direction")


@pulumi.output_type
class GetFacilityCapacityResult(dict):
    def __init__(__self__, *,
                 plan: str,
                 quantity: Optional[int] = None):
        """
        :param str plan: Device plan that must be available in selected location.
        :param int quantity: Minimun number of devices that must be available in selected location.
               Default is `1`.
        """
        GetFacilityCapacityResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            plan=plan,
            quantity=quantity,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             plan: Optional[str] = None,
             quantity: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if plan is None:
            raise TypeError("Missing 'plan' argument")

        _setter("plan", plan)
        if quantity is not None:
            _setter("quantity", quantity)

    @property
    @pulumi.getter
    def plan(self) -> str:
        """
        Device plan that must be available in selected location.
        """
        return pulumi.get(self, "plan")

    @property
    @pulumi.getter
    def quantity(self) -> Optional[int]:
        """
        Minimun number of devices that must be available in selected location.
        Default is `1`.
        """
        return pulumi.get(self, "quantity")


@pulumi.output_type
class GetInterconnectionPortResult(dict):
    def __init__(__self__, *,
                 id: str,
                 link_status: str,
                 name: str,
                 role: str,
                 speed: int,
                 status: str,
                 virtual_circuit_ids: Sequence[Any]):
        """
        :param str id: Port UUID.
        :param str link_status: Port link status.
        :param str name: Port name.
        :param str role: Port role - primary or secondary.
        :param int speed: Port speed in bits per second.
        :param str status: Port status.
        :param Sequence[Any] virtual_circuit_ids: List of IDs of virtual cicruits attached to this port.
        """
        GetInterconnectionPortResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            link_status=link_status,
            name=name,
            role=role,
            speed=speed,
            status=status,
            virtual_circuit_ids=virtual_circuit_ids,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             link_status: Optional[str] = None,
             name: Optional[str] = None,
             role: Optional[str] = None,
             speed: Optional[int] = None,
             status: Optional[str] = None,
             virtual_circuit_ids: Optional[Sequence[Any]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")
        if link_status is None and 'linkStatus' in kwargs:
            link_status = kwargs['linkStatus']
        if link_status is None:
            raise TypeError("Missing 'link_status' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if role is None:
            raise TypeError("Missing 'role' argument")
        if speed is None:
            raise TypeError("Missing 'speed' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if virtual_circuit_ids is None and 'virtualCircuitIds' in kwargs:
            virtual_circuit_ids = kwargs['virtualCircuitIds']
        if virtual_circuit_ids is None:
            raise TypeError("Missing 'virtual_circuit_ids' argument")

        _setter("id", id)
        _setter("link_status", link_status)
        _setter("name", name)
        _setter("role", role)
        _setter("speed", speed)
        _setter("status", status)
        _setter("virtual_circuit_ids", virtual_circuit_ids)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Port UUID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="linkStatus")
    def link_status(self) -> str:
        """
        Port link status.
        """
        return pulumi.get(self, "link_status")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Port name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def role(self) -> str:
        """
        Port role - primary or secondary.
        """
        return pulumi.get(self, "role")

    @property
    @pulumi.getter
    def speed(self) -> int:
        """
        Port speed in bits per second.
        """
        return pulumi.get(self, "speed")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Port status.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="virtualCircuitIds")
    def virtual_circuit_ids(self) -> Sequence[Any]:
        """
        List of IDs of virtual cicruits attached to this port.
        """
        return pulumi.get(self, "virtual_circuit_ids")


@pulumi.output_type
class GetInterconnectionServiceTokenResult(dict):
    def __init__(__self__, *,
                 expires_at: str,
                 id: str,
                 max_allowed_speed: str,
                 role: str,
                 state: str,
                 type: str):
        """
        :param str expires_at: Expiration date of the service token.
        :param str id: Port UUID.
        :param str max_allowed_speed: Maximum allowed speed for the service token, string like in the `speed` attribute.
        :param str role: Port role - primary or secondary.
        :param str type: Token type, `a_side` or `z_side`.
        """
        GetInterconnectionServiceTokenResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            expires_at=expires_at,
            id=id,
            max_allowed_speed=max_allowed_speed,
            role=role,
            state=state,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             expires_at: Optional[str] = None,
             id: Optional[str] = None,
             max_allowed_speed: Optional[str] = None,
             role: Optional[str] = None,
             state: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if expires_at is None and 'expiresAt' in kwargs:
            expires_at = kwargs['expiresAt']
        if expires_at is None:
            raise TypeError("Missing 'expires_at' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if max_allowed_speed is None and 'maxAllowedSpeed' in kwargs:
            max_allowed_speed = kwargs['maxAllowedSpeed']
        if max_allowed_speed is None:
            raise TypeError("Missing 'max_allowed_speed' argument")
        if role is None:
            raise TypeError("Missing 'role' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("expires_at", expires_at)
        _setter("id", id)
        _setter("max_allowed_speed", max_allowed_speed)
        _setter("role", role)
        _setter("state", state)
        _setter("type", type)

    @property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> str:
        """
        Expiration date of the service token.
        """
        return pulumi.get(self, "expires_at")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Port UUID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="maxAllowedSpeed")
    def max_allowed_speed(self) -> str:
        """
        Maximum allowed speed for the service token, string like in the `speed` attribute.
        """
        return pulumi.get(self, "max_allowed_speed")

    @property
    @pulumi.getter
    def role(self) -> str:
        """
        Port role - primary or secondary.
        """
        return pulumi.get(self, "role")

    @property
    @pulumi.getter
    def state(self) -> str:
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Token type, `a_side` or `z_side`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetMetroCapacityResult(dict):
    def __init__(__self__, *,
                 plan: str,
                 quantity: Optional[int] = None):
        """
        :param str plan: Device plan that must be available in selected location.
        :param int quantity: Minimum number of devices that must be available in selected location.
               Default is `1`.
        """
        GetMetroCapacityResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            plan=plan,
            quantity=quantity,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             plan: Optional[str] = None,
             quantity: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if plan is None:
            raise TypeError("Missing 'plan' argument")

        _setter("plan", plan)
        if quantity is not None:
            _setter("quantity", quantity)

    @property
    @pulumi.getter
    def plan(self) -> str:
        """
        Device plan that must be available in selected location.
        """
        return pulumi.get(self, "plan")

    @property
    @pulumi.getter
    def quantity(self) -> Optional[int]:
        """
        Minimum number of devices that must be available in selected location.
        Default is `1`.
        """
        return pulumi.get(self, "quantity")


@pulumi.output_type
class GetOrganizationAddressResult(dict):
    def __init__(__self__, *,
                 address: str,
                 city: str,
                 country: str,
                 state: str,
                 zip_code: str):
        """
        :param str address: Postal address.
        :param str city: City name.
        :param str country: Two letter country code (ISO 3166-1 alpha-2), e.g. US.
        :param str state: State name.
        :param str zip_code: Zip Code.
        """
        GetOrganizationAddressResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            address=address,
            city=city,
            country=country,
            state=state,
            zip_code=zip_code,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             address: Optional[str] = None,
             city: Optional[str] = None,
             country: Optional[str] = None,
             state: Optional[str] = None,
             zip_code: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if address is None:
            raise TypeError("Missing 'address' argument")
        if city is None:
            raise TypeError("Missing 'city' argument")
        if country is None:
            raise TypeError("Missing 'country' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if zip_code is None and 'zipCode' in kwargs:
            zip_code = kwargs['zipCode']
        if zip_code is None:
            raise TypeError("Missing 'zip_code' argument")

        _setter("address", address)
        _setter("city", city)
        _setter("country", country)
        _setter("state", state)
        _setter("zip_code", zip_code)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        Postal address.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def city(self) -> str:
        """
        City name.
        """
        return pulumi.get(self, "city")

    @property
    @pulumi.getter
    def country(self) -> str:
        """
        Two letter country code (ISO 3166-1 alpha-2), e.g. US.
        """
        return pulumi.get(self, "country")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        State name.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="zipCode")
    def zip_code(self) -> str:
        """
        Zip Code.
        """
        return pulumi.get(self, "zip_code")


@pulumi.output_type
class GetPlansFilterResult(dict):
    def __init__(__self__, *,
                 attribute: str,
                 values: Sequence[str],
                 all: Optional[bool] = None,
                 match_by: Optional[str] = None):
        """
        :param str attribute: The attribute used to filter. Filter attributes are case-sensitive
        :param Sequence[str] values: The filter values. Filter values are case-sensitive. If you specify multiple values for a filter, the values are joined with an OR by default, and the request returns all results that match any of the specified values
        :param bool all: If is set to true, the values are joined with an AND, and the requests returns only the results that match all specified values. Default is `false`.
               
               All fields in the `plans` block defined below can be used as attribute for both `sort` and `filter` blocks.
        :param str match_by: The type of comparison to apply. One of: `in` , `re`, `substring`, `less_than`, `less_than_or_equal`, `greater_than`, `greater_than_or_equal`. Default is `in`.
        """
        GetPlansFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            attribute=attribute,
            values=values,
            all=all,
            match_by=match_by,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             attribute: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             all: Optional[bool] = None,
             match_by: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if attribute is None:
            raise TypeError("Missing 'attribute' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")
        if match_by is None and 'matchBy' in kwargs:
            match_by = kwargs['matchBy']

        _setter("attribute", attribute)
        _setter("values", values)
        if all is not None:
            _setter("all", all)
        if match_by is not None:
            _setter("match_by", match_by)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        """
        The attribute used to filter. Filter attributes are case-sensitive
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        The filter values. Filter values are case-sensitive. If you specify multiple values for a filter, the values are joined with an OR by default, and the request returns all results that match any of the specified values
        """
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def all(self) -> Optional[bool]:
        """
        If is set to true, the values are joined with an AND, and the requests returns only the results that match all specified values. Default is `false`.

        All fields in the `plans` block defined below can be used as attribute for both `sort` and `filter` blocks.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="matchBy")
    def match_by(self) -> Optional[str]:
        """
        The type of comparison to apply. One of: `in` , `re`, `substring`, `less_than`, `less_than_or_equal`, `greater_than`, `greater_than_or_equal`. Default is `in`.
        """
        return pulumi.get(self, "match_by")


@pulumi.output_type
class GetPlansPlanResult(dict):
    def __init__(__self__, *,
                 available_in_metros: Sequence[str],
                 available_ins: Sequence[str],
                 class_: str,
                 deployment_types: Sequence[str],
                 description: str,
                 id: str,
                 legacy: bool,
                 line: str,
                 name: str,
                 pricing_hour: float,
                 pricing_month: float,
                 slug: str):
        """
        :param Sequence[str] available_in_metros: list of metros where the plan is available
        :param Sequence[str] available_ins: (**Deprecated**) list of facilities where the plan is available
        :param str class_: plan class
        :param Sequence[str] deployment_types: list of deployment types, e.g. on_demand, spot_market
        :param str description: description of the plan
        :param str id: id of the plan
        :param bool legacy: flag showing if it's a legacy plan
        :param str line: plan line, e.g. baremetal
        :param str name: name of the plan
        :param float pricing_hour: plan hourly price
        :param float pricing_month: plan monthly price
        :param str slug: plan slug
        """
        GetPlansPlanResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            available_in_metros=available_in_metros,
            available_ins=available_ins,
            class_=class_,
            deployment_types=deployment_types,
            description=description,
            id=id,
            legacy=legacy,
            line=line,
            name=name,
            pricing_hour=pricing_hour,
            pricing_month=pricing_month,
            slug=slug,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             available_in_metros: Optional[Sequence[str]] = None,
             available_ins: Optional[Sequence[str]] = None,
             class_: Optional[str] = None,
             deployment_types: Optional[Sequence[str]] = None,
             description: Optional[str] = None,
             id: Optional[str] = None,
             legacy: Optional[bool] = None,
             line: Optional[str] = None,
             name: Optional[str] = None,
             pricing_hour: Optional[float] = None,
             pricing_month: Optional[float] = None,
             slug: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if available_in_metros is None and 'availableInMetros' in kwargs:
            available_in_metros = kwargs['availableInMetros']
        if available_in_metros is None:
            raise TypeError("Missing 'available_in_metros' argument")
        if available_ins is None and 'availableIns' in kwargs:
            available_ins = kwargs['availableIns']
        if available_ins is None:
            raise TypeError("Missing 'available_ins' argument")
        if class_ is None and 'class' in kwargs:
            class_ = kwargs['class']
        if class_ is None:
            raise TypeError("Missing 'class_' argument")
        if deployment_types is None and 'deploymentTypes' in kwargs:
            deployment_types = kwargs['deploymentTypes']
        if deployment_types is None:
            raise TypeError("Missing 'deployment_types' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if legacy is None:
            raise TypeError("Missing 'legacy' argument")
        if line is None:
            raise TypeError("Missing 'line' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if pricing_hour is None and 'pricingHour' in kwargs:
            pricing_hour = kwargs['pricingHour']
        if pricing_hour is None:
            raise TypeError("Missing 'pricing_hour' argument")
        if pricing_month is None and 'pricingMonth' in kwargs:
            pricing_month = kwargs['pricingMonth']
        if pricing_month is None:
            raise TypeError("Missing 'pricing_month' argument")
        if slug is None:
            raise TypeError("Missing 'slug' argument")

        _setter("available_in_metros", available_in_metros)
        _setter("available_ins", available_ins)
        _setter("class_", class_)
        _setter("deployment_types", deployment_types)
        _setter("description", description)
        _setter("id", id)
        _setter("legacy", legacy)
        _setter("line", line)
        _setter("name", name)
        _setter("pricing_hour", pricing_hour)
        _setter("pricing_month", pricing_month)
        _setter("slug", slug)

    @property
    @pulumi.getter(name="availableInMetros")
    def available_in_metros(self) -> Sequence[str]:
        """
        list of metros where the plan is available
        """
        return pulumi.get(self, "available_in_metros")

    @property
    @pulumi.getter(name="availableIns")
    def available_ins(self) -> Sequence[str]:
        """
        (**Deprecated**) list of facilities where the plan is available
        """
        warnings.warn("""Use available_in_metros instead.  For more information, read the migration guide: https://registry.terraform.io/providers/equinix/equinix/latest/docs/guides/migration_guide_facilities_to_metros_devices""", DeprecationWarning)
        pulumi.log.warn("""available_ins is deprecated: Use available_in_metros instead.  For more information, read the migration guide: https://registry.terraform.io/providers/equinix/equinix/latest/docs/guides/migration_guide_facilities_to_metros_devices""")

        return pulumi.get(self, "available_ins")

    @property
    @pulumi.getter(name="class")
    def class_(self) -> str:
        """
        plan class
        """
        return pulumi.get(self, "class_")

    @property
    @pulumi.getter(name="deploymentTypes")
    def deployment_types(self) -> Sequence[str]:
        """
        list of deployment types, e.g. on_demand, spot_market
        """
        return pulumi.get(self, "deployment_types")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        description of the plan
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        id of the plan
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def legacy(self) -> bool:
        """
        flag showing if it's a legacy plan
        """
        return pulumi.get(self, "legacy")

    @property
    @pulumi.getter
    def line(self) -> str:
        """
        plan line, e.g. baremetal
        """
        return pulumi.get(self, "line")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        name of the plan
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="pricingHour")
    def pricing_hour(self) -> float:
        """
        plan hourly price
        """
        return pulumi.get(self, "pricing_hour")

    @property
    @pulumi.getter(name="pricingMonth")
    def pricing_month(self) -> float:
        """
        plan monthly price
        """
        return pulumi.get(self, "pricing_month")

    @property
    @pulumi.getter
    def slug(self) -> str:
        """
        plan slug
        """
        return pulumi.get(self, "slug")


@pulumi.output_type
class GetPlansSortResult(dict):
    def __init__(__self__, *,
                 attribute: str,
                 direction: Optional[str] = None):
        """
        :param str attribute: The attribute used to filter. Filter attributes are case-sensitive
        :param str direction: Sort results in ascending or descending order. Strings are sorted in alphabetical order. One of: asc, desc
        """
        GetPlansSortResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            attribute=attribute,
            direction=direction,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             attribute: Optional[str] = None,
             direction: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if attribute is None:
            raise TypeError("Missing 'attribute' argument")

        _setter("attribute", attribute)
        if direction is not None:
            _setter("direction", direction)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        """
        The attribute used to filter. Filter attributes are case-sensitive
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        Sort results in ascending or descending order. Strings are sorted in alphabetical order. One of: asc, desc
        """
        return pulumi.get(self, "direction")


@pulumi.output_type
class GetProjectBgpConfigResult(dict):
    def __init__(__self__, *,
                 asn: int,
                 deployment_type: str,
                 max_prefix: int,
                 status: str,
                 md5: Optional[str] = None):
        """
        :param int asn: Autonomous System Number for local BGP deployment.
        :param str deployment_type: One of `private`, `public`.
        :param int max_prefix: The maximum number of route filters allowed per server.
        :param str status: Status of BGP configuration in the project.
        :param str md5: Password for BGP session in plaintext (not a checksum).
        """
        GetProjectBgpConfigResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            asn=asn,
            deployment_type=deployment_type,
            max_prefix=max_prefix,
            status=status,
            md5=md5,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             asn: Optional[int] = None,
             deployment_type: Optional[str] = None,
             max_prefix: Optional[int] = None,
             status: Optional[str] = None,
             md5: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if asn is None:
            raise TypeError("Missing 'asn' argument")
        if deployment_type is None and 'deploymentType' in kwargs:
            deployment_type = kwargs['deploymentType']
        if deployment_type is None:
            raise TypeError("Missing 'deployment_type' argument")
        if max_prefix is None and 'maxPrefix' in kwargs:
            max_prefix = kwargs['maxPrefix']
        if max_prefix is None:
            raise TypeError("Missing 'max_prefix' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")

        _setter("asn", asn)
        _setter("deployment_type", deployment_type)
        _setter("max_prefix", max_prefix)
        _setter("status", status)
        if md5 is not None:
            _setter("md5", md5)

    @property
    @pulumi.getter
    def asn(self) -> int:
        """
        Autonomous System Number for local BGP deployment.
        """
        return pulumi.get(self, "asn")

    @property
    @pulumi.getter(name="deploymentType")
    def deployment_type(self) -> str:
        """
        One of `private`, `public`.
        """
        return pulumi.get(self, "deployment_type")

    @property
    @pulumi.getter(name="maxPrefix")
    def max_prefix(self) -> int:
        """
        The maximum number of route filters allowed per server.
        """
        return pulumi.get(self, "max_prefix")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of BGP configuration in the project.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def md5(self) -> Optional[str]:
        """
        Password for BGP session in plaintext (not a checksum).
        """
        return pulumi.get(self, "md5")


