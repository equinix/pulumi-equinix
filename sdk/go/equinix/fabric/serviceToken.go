// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package fabric

import (
	"context"
	"reflect"

	"errors"

	"github.com/equinix/pulumi-equinix/sdk/go/equinix/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Fabric V4 API compatible resource allows creation and management of [Equinix Fabric Service Token](https://docs.equinix.com/en-us/Content/Interconnection/Fabric/service%20tokens/Fabric-Service-Tokens.htm).
//
// Additional documentation:
// * Getting Started: https://docs.equinix.com/en-us/Content/Interconnection/Fabric/service%20tokens/Fabric-Service-Tokens.htm
// * API: https://docs.equinix.com/en-us/Content/KnowledgeCenter/Fabric/GettingStarted/Integrating-with-Fabric-V4-APIs/ConnectUsingServiceToken.htm
//
// ## Example Usage
//
// Aside Port Service Token
// ```go
// package main
//
// import (
//
//	"github.com/equinix/pulumi-equinix/sdk/go/equinix/fabric"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := fabric.NewServiceToken(ctx, "test", &fabric.ServiceTokenArgs{
//				Description:        pulumi.String("Aside COLO Service Token"),
//				ExpirationDateTime: pulumi.String("2025-01-18T06:43:49.981Z"),
//				Notifications: fabric.ServiceTokenNotificationArray{
//					&fabric.ServiceTokenNotificationArgs{
//						Emails: pulumi.StringArray{
//							pulumi.String("example@equinix.com"),
//							pulumi.String("test1@equinix.com"),
//						},
//						Type: pulumi.String("ALL"),
//					},
//				},
//				ServiceTokenConnections: fabric.ServiceTokenServiceTokenConnectionArray{
//					&fabric.ServiceTokenServiceTokenConnectionArgs{
//						ASides: fabric.ServiceTokenServiceTokenConnectionASideArray{
//							&fabric.ServiceTokenServiceTokenConnectionASideArgs{
//								AccessPointSelectors: fabric.ServiceTokenServiceTokenConnectionASideAccessPointSelectorArray{
//									&fabric.ServiceTokenServiceTokenConnectionASideAccessPointSelectorArgs{
//										LinkProtocol: &fabric.ServiceTokenServiceTokenConnectionASideAccessPointSelectorLinkProtocolArgs{
//											Type:    pulumi.String("DOT1Q"),
//											VlanTag: pulumi.Int(2987),
//										},
//										Port: &fabric.ServiceTokenServiceTokenConnectionASideAccessPointSelectorPortArgs{
//											Uuid: pulumi.String("<port_uuid>"),
//										},
//										Type: pulumi.String("COLO"),
//									},
//								},
//							},
//						},
//						BandwidthLimit: pulumi.Int(1000),
//						Type:           pulumi.String("EVPL_VC"),
//					},
//				},
//				Type: pulumi.String("VC_TOKEN"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// Zside Port Service Token
// ```go
// package main
//
// import (
//
//	"github.com/equinix/pulumi-equinix/sdk/go/equinix/fabric"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := fabric.NewServiceToken(ctx, "test", &fabric.ServiceTokenArgs{
//				Description:        pulumi.String("Zside COLO Service Token"),
//				ExpirationDateTime: pulumi.String("2025-01-18T06:43:49.981Z"),
//				Notifications: fabric.ServiceTokenNotificationArray{
//					&fabric.ServiceTokenNotificationArgs{
//						Emails: pulumi.StringArray{
//							pulumi.String("example@equinix.com"),
//							pulumi.String("test1@equinix.com"),
//						},
//						Type: pulumi.String("ALL"),
//					},
//				},
//				ServiceTokenConnections: fabric.ServiceTokenServiceTokenConnectionArray{
//					&fabric.ServiceTokenServiceTokenConnectionArgs{
//						SupportedBandwidths: pulumi.IntArray{
//							pulumi.Int(50),
//							pulumi.Int(200),
//							pulumi.Int(10000),
//						},
//						Type: pulumi.String("EVPL_VC"),
//						ZSides: fabric.ServiceTokenServiceTokenConnectionZSideArray{
//							&fabric.ServiceTokenServiceTokenConnectionZSideArgs{
//								AccessPointSelectors: fabric.ServiceTokenServiceTokenConnectionZSideAccessPointSelectorArray{
//									&fabric.ServiceTokenServiceTokenConnectionZSideAccessPointSelectorArgs{
//										LinkProtocol: &fabric.ServiceTokenServiceTokenConnectionZSideAccessPointSelectorLinkProtocolArgs{
//											Type:    pulumi.String("DOT1Q"),
//											VlanTag: pulumi.Int(2087),
//										},
//										Port: &fabric.ServiceTokenServiceTokenConnectionZSideAccessPointSelectorPortArgs{
//											Uuid: pulumi.String("<port_uuid>"),
//										},
//										Type: pulumi.String("COLO"),
//									},
//								},
//							},
//						},
//					},
//				},
//				Type: pulumi.String("VC_TOKEN"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// Zside Virtual Device Service Token
// ```go
// package main
//
// import (
//
//	"github.com/equinix/pulumi-equinix/sdk/go/equinix/fabric"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := fabric.NewServiceToken(ctx, "test", &fabric.ServiceTokenArgs{
//				Description:        pulumi.String("Zside VD Service Token"),
//				ExpirationDateTime: pulumi.String("2025-01-18T06:43:49.986Z"),
//				Notifications: fabric.ServiceTokenNotificationArray{
//					&fabric.ServiceTokenNotificationArgs{
//						Emails: pulumi.StringArray{
//							pulumi.String("example@equinix.com"),
//						},
//						Type: pulumi.String("ALL"),
//					},
//				},
//				ServiceTokenConnections: fabric.ServiceTokenServiceTokenConnectionArray{
//					&fabric.ServiceTokenServiceTokenConnectionArgs{
//						SupportedBandwidths: pulumi.IntArray{
//							pulumi.Int(50),
//							pulumi.Int(200),
//							pulumi.Int(10000),
//						},
//						Type: pulumi.String("EVPL_VC"),
//						ZSides: fabric.ServiceTokenServiceTokenConnectionZSideArray{
//							&fabric.ServiceTokenServiceTokenConnectionZSideArgs{
//								AccessPointSelectors: fabric.ServiceTokenServiceTokenConnectionZSideAccessPointSelectorArray{
//									&fabric.ServiceTokenServiceTokenConnectionZSideAccessPointSelectorArgs{
//										Interface: &fabric.ServiceTokenServiceTokenConnectionZSideAccessPointSelectorInterfaceArgs{
//											Type: pulumi.String("NETWORK"),
//										},
//										Type: pulumi.String("VD"),
//										VirtualDevice: &fabric.ServiceTokenServiceTokenConnectionZSideAccessPointSelectorVirtualDeviceArgs{
//											Type: pulumi.String("EDGE"),
//											Uuid: pulumi.String("<device_uuid>"),
//										},
//									},
//								},
//							},
//						},
//					},
//				},
//				Type: pulumi.String("VC_TOKEN"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
type ServiceToken struct {
	pulumi.CustomResourceState

	// Customer account information that is associated with this service token
	Accounts ServiceTokenAccountArrayOutput `pulumi:"accounts"`
	// Captures connection lifecycle change information
	ChangeLogs ServiceTokenChangeLogArrayOutput `pulumi:"changeLogs"`
	// Optional Description to the Service Token you will be creating
	Description pulumi.StringOutput `pulumi:"description"`
	// Expiration date and time of the service token; 2020-11-06T07:00:00Z
	ExpirationDateTime pulumi.StringOutput `pulumi:"expirationDateTime"`
	// An absolute URL that is the subject of the link's context.
	Href pulumi.StringOutput `pulumi:"href"`
	// Information about token side; ASIDE, ZSIDE
	IssuerSide pulumi.StringOutput `pulumi:"issuerSide"`
	// Name of the Service Token
	Name pulumi.StringOutput `pulumi:"name"`
	// Preferences for notifications on Service Token configuration or status changes
	Notifications ServiceTokenNotificationArrayOutput `pulumi:"notifications"`
	// Project information
	Project ServiceTokenProjectOutput `pulumi:"project"`
	// Service Token Connection Type Information
	ServiceTokenConnections ServiceTokenServiceTokenConnectionArrayOutput `pulumi:"serviceTokenConnections"`
	// Service token state; ACTIVE, INACTIVE, EXPIRED, DELETED
	State pulumi.StringOutput `pulumi:"state"`
	// Service Token Type; VC*TOKEN,EPL*TOKEN
	Type pulumi.StringOutput `pulumi:"type"`
	// Equinix-assigned service token identifier
	Uuid pulumi.StringOutput `pulumi:"uuid"`
}

// NewServiceToken registers a new resource with the given unique name, arguments, and options.
func NewServiceToken(ctx *pulumi.Context,
	name string, args *ServiceTokenArgs, opts ...pulumi.ResourceOption) (*ServiceToken, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ExpirationDateTime == nil {
		return nil, errors.New("invalid value for required argument 'ExpirationDateTime'")
	}
	if args.Notifications == nil {
		return nil, errors.New("invalid value for required argument 'Notifications'")
	}
	if args.ServiceTokenConnections == nil {
		return nil, errors.New("invalid value for required argument 'ServiceTokenConnections'")
	}
	if args.Type == nil {
		return nil, errors.New("invalid value for required argument 'Type'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource ServiceToken
	err := ctx.RegisterResource("equinix:fabric/serviceToken:ServiceToken", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetServiceToken gets an existing ServiceToken resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetServiceToken(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ServiceTokenState, opts ...pulumi.ResourceOption) (*ServiceToken, error) {
	var resource ServiceToken
	err := ctx.ReadResource("equinix:fabric/serviceToken:ServiceToken", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ServiceToken resources.
type serviceTokenState struct {
	// Customer account information that is associated with this service token
	Accounts []ServiceTokenAccount `pulumi:"accounts"`
	// Captures connection lifecycle change information
	ChangeLogs []ServiceTokenChangeLog `pulumi:"changeLogs"`
	// Optional Description to the Service Token you will be creating
	Description *string `pulumi:"description"`
	// Expiration date and time of the service token; 2020-11-06T07:00:00Z
	ExpirationDateTime *string `pulumi:"expirationDateTime"`
	// An absolute URL that is the subject of the link's context.
	Href *string `pulumi:"href"`
	// Information about token side; ASIDE, ZSIDE
	IssuerSide *string `pulumi:"issuerSide"`
	// Name of the Service Token
	Name *string `pulumi:"name"`
	// Preferences for notifications on Service Token configuration or status changes
	Notifications []ServiceTokenNotification `pulumi:"notifications"`
	// Project information
	Project *ServiceTokenProject `pulumi:"project"`
	// Service Token Connection Type Information
	ServiceTokenConnections []ServiceTokenServiceTokenConnection `pulumi:"serviceTokenConnections"`
	// Service token state; ACTIVE, INACTIVE, EXPIRED, DELETED
	State *string `pulumi:"state"`
	// Service Token Type; VC*TOKEN,EPL*TOKEN
	Type *string `pulumi:"type"`
	// Equinix-assigned service token identifier
	Uuid *string `pulumi:"uuid"`
}

type ServiceTokenState struct {
	// Customer account information that is associated with this service token
	Accounts ServiceTokenAccountArrayInput
	// Captures connection lifecycle change information
	ChangeLogs ServiceTokenChangeLogArrayInput
	// Optional Description to the Service Token you will be creating
	Description pulumi.StringPtrInput
	// Expiration date and time of the service token; 2020-11-06T07:00:00Z
	ExpirationDateTime pulumi.StringPtrInput
	// An absolute URL that is the subject of the link's context.
	Href pulumi.StringPtrInput
	// Information about token side; ASIDE, ZSIDE
	IssuerSide pulumi.StringPtrInput
	// Name of the Service Token
	Name pulumi.StringPtrInput
	// Preferences for notifications on Service Token configuration or status changes
	Notifications ServiceTokenNotificationArrayInput
	// Project information
	Project ServiceTokenProjectPtrInput
	// Service Token Connection Type Information
	ServiceTokenConnections ServiceTokenServiceTokenConnectionArrayInput
	// Service token state; ACTIVE, INACTIVE, EXPIRED, DELETED
	State pulumi.StringPtrInput
	// Service Token Type; VC*TOKEN,EPL*TOKEN
	Type pulumi.StringPtrInput
	// Equinix-assigned service token identifier
	Uuid pulumi.StringPtrInput
}

func (ServiceTokenState) ElementType() reflect.Type {
	return reflect.TypeOf((*serviceTokenState)(nil)).Elem()
}

type serviceTokenArgs struct {
	// Optional Description to the Service Token you will be creating
	Description *string `pulumi:"description"`
	// Expiration date and time of the service token; 2020-11-06T07:00:00Z
	ExpirationDateTime string `pulumi:"expirationDateTime"`
	// Name of the Service Token
	Name *string `pulumi:"name"`
	// Preferences for notifications on Service Token configuration or status changes
	Notifications []ServiceTokenNotification `pulumi:"notifications"`
	// Project information
	Project *ServiceTokenProject `pulumi:"project"`
	// Service Token Connection Type Information
	ServiceTokenConnections []ServiceTokenServiceTokenConnection `pulumi:"serviceTokenConnections"`
	// Service Token Type; VC*TOKEN,EPL*TOKEN
	Type string `pulumi:"type"`
}

// The set of arguments for constructing a ServiceToken resource.
type ServiceTokenArgs struct {
	// Optional Description to the Service Token you will be creating
	Description pulumi.StringPtrInput
	// Expiration date and time of the service token; 2020-11-06T07:00:00Z
	ExpirationDateTime pulumi.StringInput
	// Name of the Service Token
	Name pulumi.StringPtrInput
	// Preferences for notifications on Service Token configuration or status changes
	Notifications ServiceTokenNotificationArrayInput
	// Project information
	Project ServiceTokenProjectPtrInput
	// Service Token Connection Type Information
	ServiceTokenConnections ServiceTokenServiceTokenConnectionArrayInput
	// Service Token Type; VC*TOKEN,EPL*TOKEN
	Type pulumi.StringInput
}

func (ServiceTokenArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*serviceTokenArgs)(nil)).Elem()
}

type ServiceTokenInput interface {
	pulumi.Input

	ToServiceTokenOutput() ServiceTokenOutput
	ToServiceTokenOutputWithContext(ctx context.Context) ServiceTokenOutput
}

func (*ServiceToken) ElementType() reflect.Type {
	return reflect.TypeOf((**ServiceToken)(nil)).Elem()
}

func (i *ServiceToken) ToServiceTokenOutput() ServiceTokenOutput {
	return i.ToServiceTokenOutputWithContext(context.Background())
}

func (i *ServiceToken) ToServiceTokenOutputWithContext(ctx context.Context) ServiceTokenOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceTokenOutput)
}

// ServiceTokenArrayInput is an input type that accepts ServiceTokenArray and ServiceTokenArrayOutput values.
// You can construct a concrete instance of `ServiceTokenArrayInput` via:
//
//	ServiceTokenArray{ ServiceTokenArgs{...} }
type ServiceTokenArrayInput interface {
	pulumi.Input

	ToServiceTokenArrayOutput() ServiceTokenArrayOutput
	ToServiceTokenArrayOutputWithContext(context.Context) ServiceTokenArrayOutput
}

type ServiceTokenArray []ServiceTokenInput

func (ServiceTokenArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ServiceToken)(nil)).Elem()
}

func (i ServiceTokenArray) ToServiceTokenArrayOutput() ServiceTokenArrayOutput {
	return i.ToServiceTokenArrayOutputWithContext(context.Background())
}

func (i ServiceTokenArray) ToServiceTokenArrayOutputWithContext(ctx context.Context) ServiceTokenArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceTokenArrayOutput)
}

// ServiceTokenMapInput is an input type that accepts ServiceTokenMap and ServiceTokenMapOutput values.
// You can construct a concrete instance of `ServiceTokenMapInput` via:
//
//	ServiceTokenMap{ "key": ServiceTokenArgs{...} }
type ServiceTokenMapInput interface {
	pulumi.Input

	ToServiceTokenMapOutput() ServiceTokenMapOutput
	ToServiceTokenMapOutputWithContext(context.Context) ServiceTokenMapOutput
}

type ServiceTokenMap map[string]ServiceTokenInput

func (ServiceTokenMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ServiceToken)(nil)).Elem()
}

func (i ServiceTokenMap) ToServiceTokenMapOutput() ServiceTokenMapOutput {
	return i.ToServiceTokenMapOutputWithContext(context.Background())
}

func (i ServiceTokenMap) ToServiceTokenMapOutputWithContext(ctx context.Context) ServiceTokenMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceTokenMapOutput)
}

type ServiceTokenOutput struct{ *pulumi.OutputState }

func (ServiceTokenOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ServiceToken)(nil)).Elem()
}

func (o ServiceTokenOutput) ToServiceTokenOutput() ServiceTokenOutput {
	return o
}

func (o ServiceTokenOutput) ToServiceTokenOutputWithContext(ctx context.Context) ServiceTokenOutput {
	return o
}

// Customer account information that is associated with this service token
func (o ServiceTokenOutput) Accounts() ServiceTokenAccountArrayOutput {
	return o.ApplyT(func(v *ServiceToken) ServiceTokenAccountArrayOutput { return v.Accounts }).(ServiceTokenAccountArrayOutput)
}

// Captures connection lifecycle change information
func (o ServiceTokenOutput) ChangeLogs() ServiceTokenChangeLogArrayOutput {
	return o.ApplyT(func(v *ServiceToken) ServiceTokenChangeLogArrayOutput { return v.ChangeLogs }).(ServiceTokenChangeLogArrayOutput)
}

// Optional Description to the Service Token you will be creating
func (o ServiceTokenOutput) Description() pulumi.StringOutput {
	return o.ApplyT(func(v *ServiceToken) pulumi.StringOutput { return v.Description }).(pulumi.StringOutput)
}

// Expiration date and time of the service token; 2020-11-06T07:00:00Z
func (o ServiceTokenOutput) ExpirationDateTime() pulumi.StringOutput {
	return o.ApplyT(func(v *ServiceToken) pulumi.StringOutput { return v.ExpirationDateTime }).(pulumi.StringOutput)
}

// An absolute URL that is the subject of the link's context.
func (o ServiceTokenOutput) Href() pulumi.StringOutput {
	return o.ApplyT(func(v *ServiceToken) pulumi.StringOutput { return v.Href }).(pulumi.StringOutput)
}

// Information about token side; ASIDE, ZSIDE
func (o ServiceTokenOutput) IssuerSide() pulumi.StringOutput {
	return o.ApplyT(func(v *ServiceToken) pulumi.StringOutput { return v.IssuerSide }).(pulumi.StringOutput)
}

// Name of the Service Token
func (o ServiceTokenOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *ServiceToken) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Preferences for notifications on Service Token configuration or status changes
func (o ServiceTokenOutput) Notifications() ServiceTokenNotificationArrayOutput {
	return o.ApplyT(func(v *ServiceToken) ServiceTokenNotificationArrayOutput { return v.Notifications }).(ServiceTokenNotificationArrayOutput)
}

// Project information
func (o ServiceTokenOutput) Project() ServiceTokenProjectOutput {
	return o.ApplyT(func(v *ServiceToken) ServiceTokenProjectOutput { return v.Project }).(ServiceTokenProjectOutput)
}

// Service Token Connection Type Information
func (o ServiceTokenOutput) ServiceTokenConnections() ServiceTokenServiceTokenConnectionArrayOutput {
	return o.ApplyT(func(v *ServiceToken) ServiceTokenServiceTokenConnectionArrayOutput { return v.ServiceTokenConnections }).(ServiceTokenServiceTokenConnectionArrayOutput)
}

// Service token state; ACTIVE, INACTIVE, EXPIRED, DELETED
func (o ServiceTokenOutput) State() pulumi.StringOutput {
	return o.ApplyT(func(v *ServiceToken) pulumi.StringOutput { return v.State }).(pulumi.StringOutput)
}

// Service Token Type; VC*TOKEN,EPL*TOKEN
func (o ServiceTokenOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v *ServiceToken) pulumi.StringOutput { return v.Type }).(pulumi.StringOutput)
}

// Equinix-assigned service token identifier
func (o ServiceTokenOutput) Uuid() pulumi.StringOutput {
	return o.ApplyT(func(v *ServiceToken) pulumi.StringOutput { return v.Uuid }).(pulumi.StringOutput)
}

type ServiceTokenArrayOutput struct{ *pulumi.OutputState }

func (ServiceTokenArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ServiceToken)(nil)).Elem()
}

func (o ServiceTokenArrayOutput) ToServiceTokenArrayOutput() ServiceTokenArrayOutput {
	return o
}

func (o ServiceTokenArrayOutput) ToServiceTokenArrayOutputWithContext(ctx context.Context) ServiceTokenArrayOutput {
	return o
}

func (o ServiceTokenArrayOutput) Index(i pulumi.IntInput) ServiceTokenOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ServiceToken {
		return vs[0].([]*ServiceToken)[vs[1].(int)]
	}).(ServiceTokenOutput)
}

type ServiceTokenMapOutput struct{ *pulumi.OutputState }

func (ServiceTokenMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ServiceToken)(nil)).Elem()
}

func (o ServiceTokenMapOutput) ToServiceTokenMapOutput() ServiceTokenMapOutput {
	return o
}

func (o ServiceTokenMapOutput) ToServiceTokenMapOutputWithContext(ctx context.Context) ServiceTokenMapOutput {
	return o
}

func (o ServiceTokenMapOutput) MapIndex(k pulumi.StringInput) ServiceTokenOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ServiceToken {
		return vs[0].(map[string]*ServiceToken)[vs[1].(string)]
	}).(ServiceTokenOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ServiceTokenInput)(nil)).Elem(), &ServiceToken{})
	pulumi.RegisterInputType(reflect.TypeOf((*ServiceTokenArrayInput)(nil)).Elem(), ServiceTokenArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ServiceTokenMapInput)(nil)).Elem(), ServiceTokenMap{})
	pulumi.RegisterOutputType(ServiceTokenOutput{})
	pulumi.RegisterOutputType(ServiceTokenArrayOutput{})
	pulumi.RegisterOutputType(ServiceTokenMapOutput{})
}
