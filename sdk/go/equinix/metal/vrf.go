// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package metal

import (
	"context"
	"reflect"

	"errors"

	"github.com/equinix/pulumi-equinix/sdk/go/equinix/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Use this resource to manage a VRF.
//
// See the [Virtual Routing and Forwarding documentation](https://deploy.equinix.com/developers/docs/metal/layer2-networking/vrf/) for product details and API reference material.
//
// ## Example Usage
// ### example 1
// ```go
// package main
//
// import (
//
//	"github.com/equinix/pulumi-equinix/sdk/go/equinix/metal"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			example, err := metal.NewProject(ctx, "example", &metal.ProjectArgs{
//				Name: pulumi.String("example"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = metal.NewVrf(ctx, "exampleVrf", &metal.VrfArgs{
//				Description: pulumi.String("VRF with ASN 65000 and a pool of address space that includes 192.168.100.0/25"),
//				Name:        pulumi.String("example-vrf"),
//				Metro:       pulumi.String("da"),
//				LocalAsn:    pulumi.Int(65000),
//				IpRanges: pulumi.StringArray{
//					pulumi.String("192.168.100.0/25"),
//					pulumi.String("192.168.200.0/25"),
//				},
//				ProjectId: example.ID(),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### example 2
// ```go
// package main
//
// import (
//
//	"github.com/equinix/pulumi-equinix/sdk/go/equinix/metal"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			example, err := metal.NewReservedIpBlock(ctx, "example", &metal.ReservedIpBlockArgs{
//				Description: pulumi.String("Reserved IP block (192.168.100.0/29) taken from on of the ranges in the VRF's pool of address space."),
//				ProjectId:   pulumi.Any(exampleEquinixMetalProject.Id),
//				Metro:       pulumi.Any(exampleEquinixMetalVrf.Metro),
//				Type:        pulumi.String("vrf"),
//				VrfId:       pulumi.Any(exampleEquinixMetalVrf.Id),
//				Cidr:        pulumi.Int(29),
//				Network:     pulumi.String("192.168.100.0"),
//			})
//			if err != nil {
//				return err
//			}
//			exampleVlan, err := metal.NewVlan(ctx, "exampleVlan", &metal.VlanArgs{
//				Description: pulumi.String("A VLAN for Layer2 and Hybrid Metal devices"),
//				Metro:       pulumi.Any(exampleEquinixMetalVrf.Metro),
//				ProjectId:   pulumi.Any(exampleEquinixMetalProject.Id),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = metal.NewGateway(ctx, "exampleGateway", &metal.GatewayArgs{
//				ProjectId:       pulumi.Any(exampleEquinixMetalProject.Id),
//				VlanId:          exampleVlan.ID(),
//				IpReservationId: example.ID(),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### example 3
// ```go
// package main
//
// import (
//
//	"github.com/equinix/pulumi-equinix/sdk/go/equinix/metal"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := metal.NewVirtualCircuit(ctx, "exampleVirtualCircuit", &metal.VirtualCircuitArgs{
//				Name:         pulumi.String("example-vc"),
//				Description:  pulumi.String("Virtual Circuit"),
//				ConnectionId: pulumi.Any(example.Id),
//				ProjectId:    pulumi.Any(exampleEquinixMetalProject.Id),
//				PortId:       pulumi.Any(example.Ports[0].Id),
//				NniVlan:      pulumi.Int(1024),
//				VrfId:        pulumi.Any(exampleEquinixMetalVrf.Id),
//				PeerAsn:      pulumi.Int(65530),
//				Subnet:       pulumi.String("192.168.100.16/31"),
//				MetalIp:      pulumi.String("192.168.100.16"),
//				CustomerIp:   pulumi.String("192.168.100.17"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// This resource can be imported using an existing VRF ID:
//
// ```sh
// $ pulumi import equinix:metal/vrf:Vrf equinix_metal_vrf {existing_id}
// ```
type Vrf struct {
	pulumi.CustomResourceState

	// Description of the VRF
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// All IPv4 and IPv6 Ranges that will be available to BGP Peers. IPv4 addresses must be /8 or smaller with a minimum size of /29. IPv6 must be /56 or smaller with a minimum size of /64. Ranges must not overlap other ranges within the VRF.
	IpRanges pulumi.StringArrayOutput `pulumi:"ipRanges"`
	// The 4-byte ASN set on the VRF.
	LocalAsn pulumi.IntOutput `pulumi:"localAsn"`
	// Metro ID or Code where the VRF will be deployed
	Metro pulumi.StringOutput `pulumi:"metro"`
	// User-supplied name of the VRF, unique to the project
	Name pulumi.StringOutput `pulumi:"name"`
	// Project ID where the VRF will be deployed
	ProjectId pulumi.StringOutput `pulumi:"projectId"`
}

// NewVrf registers a new resource with the given unique name, arguments, and options.
func NewVrf(ctx *pulumi.Context,
	name string, args *VrfArgs, opts ...pulumi.ResourceOption) (*Vrf, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Metro == nil {
		return nil, errors.New("invalid value for required argument 'Metro'")
	}
	if args.ProjectId == nil {
		return nil, errors.New("invalid value for required argument 'ProjectId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Vrf
	err := ctx.RegisterResource("equinix:metal/vrf:Vrf", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetVrf gets an existing Vrf resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetVrf(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *VrfState, opts ...pulumi.ResourceOption) (*Vrf, error) {
	var resource Vrf
	err := ctx.ReadResource("equinix:metal/vrf:Vrf", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Vrf resources.
type vrfState struct {
	// Description of the VRF
	Description *string `pulumi:"description"`
	// All IPv4 and IPv6 Ranges that will be available to BGP Peers. IPv4 addresses must be /8 or smaller with a minimum size of /29. IPv6 must be /56 or smaller with a minimum size of /64. Ranges must not overlap other ranges within the VRF.
	IpRanges []string `pulumi:"ipRanges"`
	// The 4-byte ASN set on the VRF.
	LocalAsn *int `pulumi:"localAsn"`
	// Metro ID or Code where the VRF will be deployed
	Metro *string `pulumi:"metro"`
	// User-supplied name of the VRF, unique to the project
	Name *string `pulumi:"name"`
	// Project ID where the VRF will be deployed
	ProjectId *string `pulumi:"projectId"`
}

type VrfState struct {
	// Description of the VRF
	Description pulumi.StringPtrInput
	// All IPv4 and IPv6 Ranges that will be available to BGP Peers. IPv4 addresses must be /8 or smaller with a minimum size of /29. IPv6 must be /56 or smaller with a minimum size of /64. Ranges must not overlap other ranges within the VRF.
	IpRanges pulumi.StringArrayInput
	// The 4-byte ASN set on the VRF.
	LocalAsn pulumi.IntPtrInput
	// Metro ID or Code where the VRF will be deployed
	Metro pulumi.StringPtrInput
	// User-supplied name of the VRF, unique to the project
	Name pulumi.StringPtrInput
	// Project ID where the VRF will be deployed
	ProjectId pulumi.StringPtrInput
}

func (VrfState) ElementType() reflect.Type {
	return reflect.TypeOf((*vrfState)(nil)).Elem()
}

type vrfArgs struct {
	// Description of the VRF
	Description *string `pulumi:"description"`
	// All IPv4 and IPv6 Ranges that will be available to BGP Peers. IPv4 addresses must be /8 or smaller with a minimum size of /29. IPv6 must be /56 or smaller with a minimum size of /64. Ranges must not overlap other ranges within the VRF.
	IpRanges []string `pulumi:"ipRanges"`
	// The 4-byte ASN set on the VRF.
	LocalAsn *int `pulumi:"localAsn"`
	// Metro ID or Code where the VRF will be deployed
	Metro string `pulumi:"metro"`
	// User-supplied name of the VRF, unique to the project
	Name *string `pulumi:"name"`
	// Project ID where the VRF will be deployed
	ProjectId string `pulumi:"projectId"`
}

// The set of arguments for constructing a Vrf resource.
type VrfArgs struct {
	// Description of the VRF
	Description pulumi.StringPtrInput
	// All IPv4 and IPv6 Ranges that will be available to BGP Peers. IPv4 addresses must be /8 or smaller with a minimum size of /29. IPv6 must be /56 or smaller with a minimum size of /64. Ranges must not overlap other ranges within the VRF.
	IpRanges pulumi.StringArrayInput
	// The 4-byte ASN set on the VRF.
	LocalAsn pulumi.IntPtrInput
	// Metro ID or Code where the VRF will be deployed
	Metro pulumi.StringInput
	// User-supplied name of the VRF, unique to the project
	Name pulumi.StringPtrInput
	// Project ID where the VRF will be deployed
	ProjectId pulumi.StringInput
}

func (VrfArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*vrfArgs)(nil)).Elem()
}

type VrfInput interface {
	pulumi.Input

	ToVrfOutput() VrfOutput
	ToVrfOutputWithContext(ctx context.Context) VrfOutput
}

func (*Vrf) ElementType() reflect.Type {
	return reflect.TypeOf((**Vrf)(nil)).Elem()
}

func (i *Vrf) ToVrfOutput() VrfOutput {
	return i.ToVrfOutputWithContext(context.Background())
}

func (i *Vrf) ToVrfOutputWithContext(ctx context.Context) VrfOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VrfOutput)
}

// VrfArrayInput is an input type that accepts VrfArray and VrfArrayOutput values.
// You can construct a concrete instance of `VrfArrayInput` via:
//
//	VrfArray{ VrfArgs{...} }
type VrfArrayInput interface {
	pulumi.Input

	ToVrfArrayOutput() VrfArrayOutput
	ToVrfArrayOutputWithContext(context.Context) VrfArrayOutput
}

type VrfArray []VrfInput

func (VrfArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Vrf)(nil)).Elem()
}

func (i VrfArray) ToVrfArrayOutput() VrfArrayOutput {
	return i.ToVrfArrayOutputWithContext(context.Background())
}

func (i VrfArray) ToVrfArrayOutputWithContext(ctx context.Context) VrfArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VrfArrayOutput)
}

// VrfMapInput is an input type that accepts VrfMap and VrfMapOutput values.
// You can construct a concrete instance of `VrfMapInput` via:
//
//	VrfMap{ "key": VrfArgs{...} }
type VrfMapInput interface {
	pulumi.Input

	ToVrfMapOutput() VrfMapOutput
	ToVrfMapOutputWithContext(context.Context) VrfMapOutput
}

type VrfMap map[string]VrfInput

func (VrfMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Vrf)(nil)).Elem()
}

func (i VrfMap) ToVrfMapOutput() VrfMapOutput {
	return i.ToVrfMapOutputWithContext(context.Background())
}

func (i VrfMap) ToVrfMapOutputWithContext(ctx context.Context) VrfMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VrfMapOutput)
}

type VrfOutput struct{ *pulumi.OutputState }

func (VrfOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Vrf)(nil)).Elem()
}

func (o VrfOutput) ToVrfOutput() VrfOutput {
	return o
}

func (o VrfOutput) ToVrfOutputWithContext(ctx context.Context) VrfOutput {
	return o
}

// Description of the VRF
func (o VrfOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Vrf) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// All IPv4 and IPv6 Ranges that will be available to BGP Peers. IPv4 addresses must be /8 or smaller with a minimum size of /29. IPv6 must be /56 or smaller with a minimum size of /64. Ranges must not overlap other ranges within the VRF.
func (o VrfOutput) IpRanges() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Vrf) pulumi.StringArrayOutput { return v.IpRanges }).(pulumi.StringArrayOutput)
}

// The 4-byte ASN set on the VRF.
func (o VrfOutput) LocalAsn() pulumi.IntOutput {
	return o.ApplyT(func(v *Vrf) pulumi.IntOutput { return v.LocalAsn }).(pulumi.IntOutput)
}

// Metro ID or Code where the VRF will be deployed
func (o VrfOutput) Metro() pulumi.StringOutput {
	return o.ApplyT(func(v *Vrf) pulumi.StringOutput { return v.Metro }).(pulumi.StringOutput)
}

// User-supplied name of the VRF, unique to the project
func (o VrfOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Vrf) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Project ID where the VRF will be deployed
func (o VrfOutput) ProjectId() pulumi.StringOutput {
	return o.ApplyT(func(v *Vrf) pulumi.StringOutput { return v.ProjectId }).(pulumi.StringOutput)
}

type VrfArrayOutput struct{ *pulumi.OutputState }

func (VrfArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Vrf)(nil)).Elem()
}

func (o VrfArrayOutput) ToVrfArrayOutput() VrfArrayOutput {
	return o
}

func (o VrfArrayOutput) ToVrfArrayOutputWithContext(ctx context.Context) VrfArrayOutput {
	return o
}

func (o VrfArrayOutput) Index(i pulumi.IntInput) VrfOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Vrf {
		return vs[0].([]*Vrf)[vs[1].(int)]
	}).(VrfOutput)
}

type VrfMapOutput struct{ *pulumi.OutputState }

func (VrfMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Vrf)(nil)).Elem()
}

func (o VrfMapOutput) ToVrfMapOutput() VrfMapOutput {
	return o
}

func (o VrfMapOutput) ToVrfMapOutputWithContext(ctx context.Context) VrfMapOutput {
	return o
}

func (o VrfMapOutput) MapIndex(k pulumi.StringInput) VrfOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Vrf {
		return vs[0].(map[string]*Vrf)[vs[1].(string)]
	}).(VrfOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*VrfInput)(nil)).Elem(), &Vrf{})
	pulumi.RegisterInputType(reflect.TypeOf((*VrfArrayInput)(nil)).Elem(), VrfArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*VrfMapInput)(nil)).Elem(), VrfMap{})
	pulumi.RegisterOutputType(VrfOutput{})
	pulumi.RegisterOutputType(VrfArrayOutput{})
	pulumi.RegisterOutputType(VrfMapOutput{})
}
