// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package metal

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Use this resource to associate VLAN with a Dedicated Port from
// [Equinix Fabric - software-defined interconnections](https://metal.equinix.com/developers/docs/networking/fabric/#associating-a-vlan-with-a-dedicated-port).
//
// > VRF features are not generally available. The interfaces related to VRF resources may change ahead of general availability.
//
// ## Example Usage
//
// Pick an existing Project and dedicated Connection, create a VLAN and use `metal.VirtualCircuit`
// to associate it with a Primary Port of the Connection.
//
// ```go
// package main
//
// import (
//
//	"github.com/equinix/pulumi-equinix/sdk/go/equinix/metal"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			projectId := "52000fb2-ee46-4673-93a8-de2c2bdba33c"
//			connId := "73f12f29-3e19-43a0-8e90-ae81580db1e0"
//			testInterconnection, err := metal.LookupInterconnection(ctx, &metal.LookupInterconnectionArgs{
//				ConnectionId: connId,
//			}, nil)
//			if err != nil {
//				return err
//			}
//			testVlan, err := metal.NewVlan(ctx, "testVlan", &metal.VlanArgs{
//				ProjectId: pulumi.String(projectId),
//				Metro:     *pulumi.String(testInterconnection.Metro),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = metal.NewVirtualCircuit(ctx, "testVirtualCircuit", &metal.VirtualCircuitArgs{
//				ConnectionId: pulumi.String(connId),
//				ProjectId:    pulumi.String(projectId),
//				PortId:       *pulumi.String(testInterconnection.Ports[0].Id),
//				VlanId:       testVlan.ID(),
//				NniVlan:      pulumi.Int(1056),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// # This resource can be imported using an existing Virtual Circuit ID
//
// ```sh
//
//	$ pulumi import equinix:metal/virtualCircuit:VirtualCircuit equinix_metal_virtual_circuit {existing_id}
//
// ```
type VirtualCircuit struct {
	pulumi.CustomResourceState

	// UUID of Connection where the VC is scoped to.
	ConnectionId pulumi.StringOutput `pulumi:"connectionId"`
	// The Customer IP address which the CSR switch will peer with. Will default to the other usable IP in the subnet.
	CustomerIp pulumi.StringPtrOutput `pulumi:"customerIp"`
	// Description for the Virtual Circuit resource.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// The password that can be set for the VRF BGP peer
	Md5 pulumi.StringPtrOutput `pulumi:"md5"`
	// The Metal IP address for the SVI (Switch Virtual Interface) of the VirtualCircuit. Will default to the first usable IP in the subnet.
	MetalIp pulumi.StringPtrOutput `pulumi:"metalIp"`
	// Name of the Virtual Circuit resource.
	Name pulumi.StringOutput `pulumi:"name"`
	// Equinix Metal network-to-network VLAN ID.
	NniVlan pulumi.IntPtrOutput `pulumi:"nniVlan"`
	// NNI VLAN parameters, see the [documentation for Equinix Fabric](https://metal.equinix.com/developers/docs/networking/fabric/).
	NniVnid pulumi.IntOutput `pulumi:"nniVnid"`
	// The BGP ASN of the peer. The same ASN may be the used across several VCs, but it cannot be the same as the localAsn of the VRF.
	PeerAsn pulumi.IntPtrOutput `pulumi:"peerAsn"`
	// UUID of the Connection Port where the VC is scoped to.
	PortId pulumi.StringOutput `pulumi:"portId"`
	// UUID of the Project where the VC is scoped to.
	ProjectId pulumi.StringOutput `pulumi:"projectId"`
	// Speed of the Virtual Circuit resource.
	Speed pulumi.StringOutput `pulumi:"speed"`
	// Status of the virtal circuit.
	Status pulumi.StringOutput `pulumi:"status"`
	// A subnet from one of the IP
	// blocks associated with the VRF that we will help create an IP reservation for. Can only be either a /30 or /31.
	// * For a /31 block, it will only have two IP addresses, which will be used for
	//   the metalIp and customer_ip.
	// * For a /30 block, it will have four IP addresses, but the first and last IP addresses are not usable. We will default to the first usable IP address for the metal_ip.
	Subnet pulumi.StringPtrOutput `pulumi:"subnet"`
	// Tags for the Virtual Circuit resource.
	Tags pulumi.StringArrayOutput `pulumi:"tags"`
	// UUID of the VLAN to associate.
	VlanId pulumi.StringPtrOutput `pulumi:"vlanId"`
	// VNID VLAN parameter, see the [documentation for Equinix Fabric](https://metal.equinix.com/developers/docs/networking/fabric/).
	Vnid pulumi.IntOutput `pulumi:"vnid"`
	// UUID of the VRF to associate.
	VrfId pulumi.StringPtrOutput `pulumi:"vrfId"`
}

// NewVirtualCircuit registers a new resource with the given unique name, arguments, and options.
func NewVirtualCircuit(ctx *pulumi.Context,
	name string, args *VirtualCircuitArgs, opts ...pulumi.ResourceOption) (*VirtualCircuit, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ConnectionId == nil {
		return nil, errors.New("invalid value for required argument 'ConnectionId'")
	}
	if args.PortId == nil {
		return nil, errors.New("invalid value for required argument 'PortId'")
	}
	if args.ProjectId == nil {
		return nil, errors.New("invalid value for required argument 'ProjectId'")
	}
	if args.Md5 != nil {
		args.Md5 = pulumi.ToSecret(args.Md5).(pulumi.StringPtrInput)
	}
	secrets := pulumi.AdditionalSecretOutputs([]string{
		"md5",
	})
	opts = append(opts, secrets)
	opts = pkgResourceDefaultOpts(opts)
	var resource VirtualCircuit
	err := ctx.RegisterResource("equinix:metal/virtualCircuit:VirtualCircuit", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetVirtualCircuit gets an existing VirtualCircuit resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetVirtualCircuit(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *VirtualCircuitState, opts ...pulumi.ResourceOption) (*VirtualCircuit, error) {
	var resource VirtualCircuit
	err := ctx.ReadResource("equinix:metal/virtualCircuit:VirtualCircuit", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering VirtualCircuit resources.
type virtualCircuitState struct {
	// UUID of Connection where the VC is scoped to.
	ConnectionId *string `pulumi:"connectionId"`
	// The Customer IP address which the CSR switch will peer with. Will default to the other usable IP in the subnet.
	CustomerIp *string `pulumi:"customerIp"`
	// Description for the Virtual Circuit resource.
	Description *string `pulumi:"description"`
	// The password that can be set for the VRF BGP peer
	Md5 *string `pulumi:"md5"`
	// The Metal IP address for the SVI (Switch Virtual Interface) of the VirtualCircuit. Will default to the first usable IP in the subnet.
	MetalIp *string `pulumi:"metalIp"`
	// Name of the Virtual Circuit resource.
	Name *string `pulumi:"name"`
	// Equinix Metal network-to-network VLAN ID.
	NniVlan *int `pulumi:"nniVlan"`
	// NNI VLAN parameters, see the [documentation for Equinix Fabric](https://metal.equinix.com/developers/docs/networking/fabric/).
	NniVnid *int `pulumi:"nniVnid"`
	// The BGP ASN of the peer. The same ASN may be the used across several VCs, but it cannot be the same as the localAsn of the VRF.
	PeerAsn *int `pulumi:"peerAsn"`
	// UUID of the Connection Port where the VC is scoped to.
	PortId *string `pulumi:"portId"`
	// UUID of the Project where the VC is scoped to.
	ProjectId *string `pulumi:"projectId"`
	// Speed of the Virtual Circuit resource.
	Speed *string `pulumi:"speed"`
	// Status of the virtal circuit.
	Status *string `pulumi:"status"`
	// A subnet from one of the IP
	// blocks associated with the VRF that we will help create an IP reservation for. Can only be either a /30 or /31.
	// * For a /31 block, it will only have two IP addresses, which will be used for
	//   the metalIp and customer_ip.
	// * For a /30 block, it will have four IP addresses, but the first and last IP addresses are not usable. We will default to the first usable IP address for the metal_ip.
	Subnet *string `pulumi:"subnet"`
	// Tags for the Virtual Circuit resource.
	Tags []string `pulumi:"tags"`
	// UUID of the VLAN to associate.
	VlanId *string `pulumi:"vlanId"`
	// VNID VLAN parameter, see the [documentation for Equinix Fabric](https://metal.equinix.com/developers/docs/networking/fabric/).
	Vnid *int `pulumi:"vnid"`
	// UUID of the VRF to associate.
	VrfId *string `pulumi:"vrfId"`
}

type VirtualCircuitState struct {
	// UUID of Connection where the VC is scoped to.
	ConnectionId pulumi.StringPtrInput
	// The Customer IP address which the CSR switch will peer with. Will default to the other usable IP in the subnet.
	CustomerIp pulumi.StringPtrInput
	// Description for the Virtual Circuit resource.
	Description pulumi.StringPtrInput
	// The password that can be set for the VRF BGP peer
	Md5 pulumi.StringPtrInput
	// The Metal IP address for the SVI (Switch Virtual Interface) of the VirtualCircuit. Will default to the first usable IP in the subnet.
	MetalIp pulumi.StringPtrInput
	// Name of the Virtual Circuit resource.
	Name pulumi.StringPtrInput
	// Equinix Metal network-to-network VLAN ID.
	NniVlan pulumi.IntPtrInput
	// NNI VLAN parameters, see the [documentation for Equinix Fabric](https://metal.equinix.com/developers/docs/networking/fabric/).
	NniVnid pulumi.IntPtrInput
	// The BGP ASN of the peer. The same ASN may be the used across several VCs, but it cannot be the same as the localAsn of the VRF.
	PeerAsn pulumi.IntPtrInput
	// UUID of the Connection Port where the VC is scoped to.
	PortId pulumi.StringPtrInput
	// UUID of the Project where the VC is scoped to.
	ProjectId pulumi.StringPtrInput
	// Speed of the Virtual Circuit resource.
	Speed pulumi.StringPtrInput
	// Status of the virtal circuit.
	Status pulumi.StringPtrInput
	// A subnet from one of the IP
	// blocks associated with the VRF that we will help create an IP reservation for. Can only be either a /30 or /31.
	// * For a /31 block, it will only have two IP addresses, which will be used for
	//   the metalIp and customer_ip.
	// * For a /30 block, it will have four IP addresses, but the first and last IP addresses are not usable. We will default to the first usable IP address for the metal_ip.
	Subnet pulumi.StringPtrInput
	// Tags for the Virtual Circuit resource.
	Tags pulumi.StringArrayInput
	// UUID of the VLAN to associate.
	VlanId pulumi.StringPtrInput
	// VNID VLAN parameter, see the [documentation for Equinix Fabric](https://metal.equinix.com/developers/docs/networking/fabric/).
	Vnid pulumi.IntPtrInput
	// UUID of the VRF to associate.
	VrfId pulumi.StringPtrInput
}

func (VirtualCircuitState) ElementType() reflect.Type {
	return reflect.TypeOf((*virtualCircuitState)(nil)).Elem()
}

type virtualCircuitArgs struct {
	// UUID of Connection where the VC is scoped to.
	ConnectionId string `pulumi:"connectionId"`
	// The Customer IP address which the CSR switch will peer with. Will default to the other usable IP in the subnet.
	CustomerIp *string `pulumi:"customerIp"`
	// Description for the Virtual Circuit resource.
	Description *string `pulumi:"description"`
	// The password that can be set for the VRF BGP peer
	Md5 *string `pulumi:"md5"`
	// The Metal IP address for the SVI (Switch Virtual Interface) of the VirtualCircuit. Will default to the first usable IP in the subnet.
	MetalIp *string `pulumi:"metalIp"`
	// Name of the Virtual Circuit resource.
	Name *string `pulumi:"name"`
	// Equinix Metal network-to-network VLAN ID.
	NniVlan *int `pulumi:"nniVlan"`
	// The BGP ASN of the peer. The same ASN may be the used across several VCs, but it cannot be the same as the localAsn of the VRF.
	PeerAsn *int `pulumi:"peerAsn"`
	// UUID of the Connection Port where the VC is scoped to.
	PortId string `pulumi:"portId"`
	// UUID of the Project where the VC is scoped to.
	ProjectId string `pulumi:"projectId"`
	// Speed of the Virtual Circuit resource.
	Speed *string `pulumi:"speed"`
	// A subnet from one of the IP
	// blocks associated with the VRF that we will help create an IP reservation for. Can only be either a /30 or /31.
	// * For a /31 block, it will only have two IP addresses, which will be used for
	//   the metalIp and customer_ip.
	// * For a /30 block, it will have four IP addresses, but the first and last IP addresses are not usable. We will default to the first usable IP address for the metal_ip.
	Subnet *string `pulumi:"subnet"`
	// Tags for the Virtual Circuit resource.
	Tags []string `pulumi:"tags"`
	// UUID of the VLAN to associate.
	VlanId *string `pulumi:"vlanId"`
	// UUID of the VRF to associate.
	VrfId *string `pulumi:"vrfId"`
}

// The set of arguments for constructing a VirtualCircuit resource.
type VirtualCircuitArgs struct {
	// UUID of Connection where the VC is scoped to.
	ConnectionId pulumi.StringInput
	// The Customer IP address which the CSR switch will peer with. Will default to the other usable IP in the subnet.
	CustomerIp pulumi.StringPtrInput
	// Description for the Virtual Circuit resource.
	Description pulumi.StringPtrInput
	// The password that can be set for the VRF BGP peer
	Md5 pulumi.StringPtrInput
	// The Metal IP address for the SVI (Switch Virtual Interface) of the VirtualCircuit. Will default to the first usable IP in the subnet.
	MetalIp pulumi.StringPtrInput
	// Name of the Virtual Circuit resource.
	Name pulumi.StringPtrInput
	// Equinix Metal network-to-network VLAN ID.
	NniVlan pulumi.IntPtrInput
	// The BGP ASN of the peer. The same ASN may be the used across several VCs, but it cannot be the same as the localAsn of the VRF.
	PeerAsn pulumi.IntPtrInput
	// UUID of the Connection Port where the VC is scoped to.
	PortId pulumi.StringInput
	// UUID of the Project where the VC is scoped to.
	ProjectId pulumi.StringInput
	// Speed of the Virtual Circuit resource.
	Speed pulumi.StringPtrInput
	// A subnet from one of the IP
	// blocks associated with the VRF that we will help create an IP reservation for. Can only be either a /30 or /31.
	// * For a /31 block, it will only have two IP addresses, which will be used for
	//   the metalIp and customer_ip.
	// * For a /30 block, it will have four IP addresses, but the first and last IP addresses are not usable. We will default to the first usable IP address for the metal_ip.
	Subnet pulumi.StringPtrInput
	// Tags for the Virtual Circuit resource.
	Tags pulumi.StringArrayInput
	// UUID of the VLAN to associate.
	VlanId pulumi.StringPtrInput
	// UUID of the VRF to associate.
	VrfId pulumi.StringPtrInput
}

func (VirtualCircuitArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*virtualCircuitArgs)(nil)).Elem()
}

type VirtualCircuitInput interface {
	pulumi.Input

	ToVirtualCircuitOutput() VirtualCircuitOutput
	ToVirtualCircuitOutputWithContext(ctx context.Context) VirtualCircuitOutput
}

func (*VirtualCircuit) ElementType() reflect.Type {
	return reflect.TypeOf((**VirtualCircuit)(nil)).Elem()
}

func (i *VirtualCircuit) ToVirtualCircuitOutput() VirtualCircuitOutput {
	return i.ToVirtualCircuitOutputWithContext(context.Background())
}

func (i *VirtualCircuit) ToVirtualCircuitOutputWithContext(ctx context.Context) VirtualCircuitOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VirtualCircuitOutput)
}

// VirtualCircuitArrayInput is an input type that accepts VirtualCircuitArray and VirtualCircuitArrayOutput values.
// You can construct a concrete instance of `VirtualCircuitArrayInput` via:
//
//	VirtualCircuitArray{ VirtualCircuitArgs{...} }
type VirtualCircuitArrayInput interface {
	pulumi.Input

	ToVirtualCircuitArrayOutput() VirtualCircuitArrayOutput
	ToVirtualCircuitArrayOutputWithContext(context.Context) VirtualCircuitArrayOutput
}

type VirtualCircuitArray []VirtualCircuitInput

func (VirtualCircuitArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*VirtualCircuit)(nil)).Elem()
}

func (i VirtualCircuitArray) ToVirtualCircuitArrayOutput() VirtualCircuitArrayOutput {
	return i.ToVirtualCircuitArrayOutputWithContext(context.Background())
}

func (i VirtualCircuitArray) ToVirtualCircuitArrayOutputWithContext(ctx context.Context) VirtualCircuitArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VirtualCircuitArrayOutput)
}

// VirtualCircuitMapInput is an input type that accepts VirtualCircuitMap and VirtualCircuitMapOutput values.
// You can construct a concrete instance of `VirtualCircuitMapInput` via:
//
//	VirtualCircuitMap{ "key": VirtualCircuitArgs{...} }
type VirtualCircuitMapInput interface {
	pulumi.Input

	ToVirtualCircuitMapOutput() VirtualCircuitMapOutput
	ToVirtualCircuitMapOutputWithContext(context.Context) VirtualCircuitMapOutput
}

type VirtualCircuitMap map[string]VirtualCircuitInput

func (VirtualCircuitMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*VirtualCircuit)(nil)).Elem()
}

func (i VirtualCircuitMap) ToVirtualCircuitMapOutput() VirtualCircuitMapOutput {
	return i.ToVirtualCircuitMapOutputWithContext(context.Background())
}

func (i VirtualCircuitMap) ToVirtualCircuitMapOutputWithContext(ctx context.Context) VirtualCircuitMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VirtualCircuitMapOutput)
}

type VirtualCircuitOutput struct{ *pulumi.OutputState }

func (VirtualCircuitOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**VirtualCircuit)(nil)).Elem()
}

func (o VirtualCircuitOutput) ToVirtualCircuitOutput() VirtualCircuitOutput {
	return o
}

func (o VirtualCircuitOutput) ToVirtualCircuitOutputWithContext(ctx context.Context) VirtualCircuitOutput {
	return o
}

// UUID of Connection where the VC is scoped to.
func (o VirtualCircuitOutput) ConnectionId() pulumi.StringOutput {
	return o.ApplyT(func(v *VirtualCircuit) pulumi.StringOutput { return v.ConnectionId }).(pulumi.StringOutput)
}

// The Customer IP address which the CSR switch will peer with. Will default to the other usable IP in the subnet.
func (o VirtualCircuitOutput) CustomerIp() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VirtualCircuit) pulumi.StringPtrOutput { return v.CustomerIp }).(pulumi.StringPtrOutput)
}

// Description for the Virtual Circuit resource.
func (o VirtualCircuitOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VirtualCircuit) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// The password that can be set for the VRF BGP peer
func (o VirtualCircuitOutput) Md5() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VirtualCircuit) pulumi.StringPtrOutput { return v.Md5 }).(pulumi.StringPtrOutput)
}

// The Metal IP address for the SVI (Switch Virtual Interface) of the VirtualCircuit. Will default to the first usable IP in the subnet.
func (o VirtualCircuitOutput) MetalIp() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VirtualCircuit) pulumi.StringPtrOutput { return v.MetalIp }).(pulumi.StringPtrOutput)
}

// Name of the Virtual Circuit resource.
func (o VirtualCircuitOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *VirtualCircuit) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Equinix Metal network-to-network VLAN ID.
func (o VirtualCircuitOutput) NniVlan() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *VirtualCircuit) pulumi.IntPtrOutput { return v.NniVlan }).(pulumi.IntPtrOutput)
}

// NNI VLAN parameters, see the [documentation for Equinix Fabric](https://metal.equinix.com/developers/docs/networking/fabric/).
func (o VirtualCircuitOutput) NniVnid() pulumi.IntOutput {
	return o.ApplyT(func(v *VirtualCircuit) pulumi.IntOutput { return v.NniVnid }).(pulumi.IntOutput)
}

// The BGP ASN of the peer. The same ASN may be the used across several VCs, but it cannot be the same as the localAsn of the VRF.
func (o VirtualCircuitOutput) PeerAsn() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *VirtualCircuit) pulumi.IntPtrOutput { return v.PeerAsn }).(pulumi.IntPtrOutput)
}

// UUID of the Connection Port where the VC is scoped to.
func (o VirtualCircuitOutput) PortId() pulumi.StringOutput {
	return o.ApplyT(func(v *VirtualCircuit) pulumi.StringOutput { return v.PortId }).(pulumi.StringOutput)
}

// UUID of the Project where the VC is scoped to.
func (o VirtualCircuitOutput) ProjectId() pulumi.StringOutput {
	return o.ApplyT(func(v *VirtualCircuit) pulumi.StringOutput { return v.ProjectId }).(pulumi.StringOutput)
}

// Speed of the Virtual Circuit resource.
func (o VirtualCircuitOutput) Speed() pulumi.StringOutput {
	return o.ApplyT(func(v *VirtualCircuit) pulumi.StringOutput { return v.Speed }).(pulumi.StringOutput)
}

// Status of the virtal circuit.
func (o VirtualCircuitOutput) Status() pulumi.StringOutput {
	return o.ApplyT(func(v *VirtualCircuit) pulumi.StringOutput { return v.Status }).(pulumi.StringOutput)
}

// A subnet from one of the IP
// blocks associated with the VRF that we will help create an IP reservation for. Can only be either a /30 or /31.
//   - For a /31 block, it will only have two IP addresses, which will be used for
//     the metalIp and customer_ip.
//   - For a /30 block, it will have four IP addresses, but the first and last IP addresses are not usable. We will default to the first usable IP address for the metal_ip.
func (o VirtualCircuitOutput) Subnet() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VirtualCircuit) pulumi.StringPtrOutput { return v.Subnet }).(pulumi.StringPtrOutput)
}

// Tags for the Virtual Circuit resource.
func (o VirtualCircuitOutput) Tags() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *VirtualCircuit) pulumi.StringArrayOutput { return v.Tags }).(pulumi.StringArrayOutput)
}

// UUID of the VLAN to associate.
func (o VirtualCircuitOutput) VlanId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VirtualCircuit) pulumi.StringPtrOutput { return v.VlanId }).(pulumi.StringPtrOutput)
}

// VNID VLAN parameter, see the [documentation for Equinix Fabric](https://metal.equinix.com/developers/docs/networking/fabric/).
func (o VirtualCircuitOutput) Vnid() pulumi.IntOutput {
	return o.ApplyT(func(v *VirtualCircuit) pulumi.IntOutput { return v.Vnid }).(pulumi.IntOutput)
}

// UUID of the VRF to associate.
func (o VirtualCircuitOutput) VrfId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VirtualCircuit) pulumi.StringPtrOutput { return v.VrfId }).(pulumi.StringPtrOutput)
}

type VirtualCircuitArrayOutput struct{ *pulumi.OutputState }

func (VirtualCircuitArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*VirtualCircuit)(nil)).Elem()
}

func (o VirtualCircuitArrayOutput) ToVirtualCircuitArrayOutput() VirtualCircuitArrayOutput {
	return o
}

func (o VirtualCircuitArrayOutput) ToVirtualCircuitArrayOutputWithContext(ctx context.Context) VirtualCircuitArrayOutput {
	return o
}

func (o VirtualCircuitArrayOutput) Index(i pulumi.IntInput) VirtualCircuitOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *VirtualCircuit {
		return vs[0].([]*VirtualCircuit)[vs[1].(int)]
	}).(VirtualCircuitOutput)
}

type VirtualCircuitMapOutput struct{ *pulumi.OutputState }

func (VirtualCircuitMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*VirtualCircuit)(nil)).Elem()
}

func (o VirtualCircuitMapOutput) ToVirtualCircuitMapOutput() VirtualCircuitMapOutput {
	return o
}

func (o VirtualCircuitMapOutput) ToVirtualCircuitMapOutputWithContext(ctx context.Context) VirtualCircuitMapOutput {
	return o
}

func (o VirtualCircuitMapOutput) MapIndex(k pulumi.StringInput) VirtualCircuitOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *VirtualCircuit {
		return vs[0].(map[string]*VirtualCircuit)[vs[1].(string)]
	}).(VirtualCircuitOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*VirtualCircuitInput)(nil)).Elem(), &VirtualCircuit{})
	pulumi.RegisterInputType(reflect.TypeOf((*VirtualCircuitArrayInput)(nil)).Elem(), VirtualCircuitArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*VirtualCircuitMapInput)(nil)).Elem(), VirtualCircuitMap{})
	pulumi.RegisterOutputType(VirtualCircuitOutput{})
	pulumi.RegisterOutputType(VirtualCircuitArrayOutput{})
	pulumi.RegisterOutputType(VirtualCircuitMapOutput{})
}
