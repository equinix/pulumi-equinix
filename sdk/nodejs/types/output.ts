// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";
import * as enums from "../types/enums";

export namespace fabric {
    export interface CloudRouterAccount {
        /**
         * Account Number
         */
        accountNumber: number;
    }

    export interface CloudRouterChangeLog {
        createdBy: string;
        createdByEmail: string;
        createdByFullName: string;
        createdDateTime: string;
        deletedBy: string;
        deletedByEmail: string;
        deletedByFullName: string;
        deletedDateTime: string;
        updatedBy: string;
        updatedByEmail: string;
        updatedByFullName: string;
        updatedDateTime: string;
    }

    export interface CloudRouterLocation {
        /**
         * IBX Code
         */
        ibx: string;
        /**
         * Access point metro code
         */
        metroCode: string;
        /**
         * Access point metro name
         */
        metroName: string;
        /**
         * Access point region
         */
        region: string;
    }

    export interface CloudRouterNotification {
        /**
         * Array of contact emails
         */
        emails: string[];
        /**
         * Send interval
         */
        sendInterval?: string;
        /**
         * Notification Type - ALL,CONNECTION*APPROVAL,SALES*REP_NOTIFICATIONS, NOTIFICATIONS
         */
        type: string;
    }

    export interface CloudRouterOrder {
        /**
         * Billing tier for connection bandwidth
         */
        billingTier?: string;
        /**
         * Order Identification
         */
        orderId: string;
        /**
         * Order Reference Number
         */
        orderNumber: string;
        /**
         * Purchase order number
         */
        purchaseOrderNumber?: string;
    }

    export interface CloudRouterPackage {
        /**
         * Fabric Cloud Router package code
         */
        code: string;
    }

    export interface CloudRouterProject {
        /**
         * Unique Resource URL
         */
        href: string;
        /**
         * Project Id
         */
        projectId: string;
    }

    export interface ConnectionASide {
        /**
         * Point of access details
         */
        accessPoint?: outputs.fabric.ConnectionASideAccessPoint;
        /**
         * Connection side additional information
         */
        additionalInfo?: outputs.fabric.ConnectionASideAdditionalInfo[];
        /**
         * For service token based connections, Service tokens authorize users to access protected resources and services. Resource owners can distribute the tokens to trusted partners and vendors, allowing selected third parties to work directly with Equinix network assets
         */
        serviceToken?: outputs.fabric.ConnectionASideServiceToken;
    }

    export interface ConnectionASideAccessPoint {
        /**
         * Account
         */
        account: outputs.fabric.ConnectionASideAccessPointAccount;
        /**
         * Authentication key for provider based connections
         */
        authenticationKey?: string;
        /**
         * @deprecated use router attribute instead; gateway is no longer a part of the supported backend
         */
        gateway?: outputs.fabric.ConnectionASideAccessPointGateway;
        /**
         * Virtual device interface
         */
        interface?: outputs.fabric.ConnectionASideAccessPointInterface;
        /**
         * Connection link protocol
         */
        linkProtocol?: outputs.fabric.ConnectionASideAccessPointLinkProtocol;
        /**
         * Access point location
         */
        location: outputs.fabric.ConnectionASideAccessPointLocation;
        network?: outputs.fabric.ConnectionASideAccessPointNetwork;
        /**
         * Peering Type- PRIVATE,MICROSOFT,PUBLIC, MANUAL
         */
        peeringType?: string;
        /**
         * Port access point information
         */
        port?: outputs.fabric.ConnectionASideAccessPointPort;
        /**
         * Service Profile
         */
        profile?: outputs.fabric.ConnectionASideAccessPointProfile;
        /**
         * Provider assigned Connection Id
         */
        providerConnectionId?: string;
        /**
         * Cloud Router access point information that replaces `gateway` (refers to below for nested schema)
         */
        router?: outputs.fabric.ConnectionASideAccessPointRouter;
        /**
         * Access point routing protocols configuration
         */
        routingProtocols?: outputs.fabric.ConnectionASideAccessPointRoutingProtocol[];
        /**
         * Access point seller region
         */
        sellerRegion?: string;
        /**
         * Interface type
         */
        type?: string;
        /**
         * Virtual device
         */
        virtualDevice?: outputs.fabric.ConnectionASideAccessPointVirtualDevice;
    }

    export interface ConnectionASideAccessPointAccount {
        accountName: string;
        accountNumber: number;
        globalCustId: string;
        globalOrgId: string;
        globalOrganizationName: string;
        orgId: number;
        organizationName: string;
    }

    export interface ConnectionASideAccessPointGateway {
        /**
         * Unique Resource Identifier
         */
        href: string;
        /**
         * Equinix-assigned interface identifier
         */
        uuid?: string;
    }

    export interface ConnectionASideAccessPointInterface {
        /**
         * id
         */
        id: string;
        /**
         * Interface type
         */
        type?: string;
        /**
         * Equinix-assigned interface identifier
         */
        uuid?: string;
    }

    export interface ConnectionASideAccessPointLinkProtocol {
        /**
         * Interface type
         */
        type?: string;
        /**
         * Vlan Customer Tag information, vlanCTag value specified for QINQ connections
         */
        vlanCTag: number;
        /**
         * Vlan Provider Tag information, vlanSTag value specified for QINQ connections
         */
        vlanSTag: number;
        /**
         * Vlan Tag information, vlanTag value specified for DOT1Q connections
         */
        vlanTag: number;
    }

    export interface ConnectionASideAccessPointLocation {
        /**
         * IBX Code
         */
        ibx: string;
        /**
         * Access point metro code
         */
        metroCode: string;
        /**
         * Access point metro name
         */
        metroName: string;
        /**
         * Access point region
         */
        region: string;
    }

    export interface ConnectionASideAccessPointNetwork {
        /**
         * Unique Resource Identifier
         */
        href: string;
        /**
         * Equinix-assigned interface identifier
         */
        uuid?: string;
    }

    export interface ConnectionASideAccessPointPort {
        /**
         * Unique Resource Identifier
         */
        href: string;
        /**
         * Port name
         */
        name: string;
        /**
         * Redundancy Information
         */
        redundancies: outputs.fabric.ConnectionASideAccessPointPortRedundancy[];
        /**
         * Equinix-assigned interface identifier
         */
        uuid: string;
    }

    export interface ConnectionASideAccessPointPortRedundancy {
        /**
         * Priority type- PRIMARY, SECONDARY
         */
        priority: string;
    }

    export interface ConnectionASideAccessPointProfile {
        /**
         * Access point config information
         */
        accessPointTypeConfigs: outputs.fabric.ConnectionASideAccessPointProfileAccessPointTypeConfig[];
        /**
         * User-provided service description
         */
        description: string;
        /**
         * Unique Resource Identifier
         */
        href: string;
        /**
         * Port name
         */
        name: string;
        /**
         * Interface type
         */
        type: string;
        /**
         * Equinix-assigned interface identifier
         */
        uuid: string;
    }

    export interface ConnectionASideAccessPointProfileAccessPointTypeConfig {
        /**
         * Interface type
         */
        type: string;
        /**
         * Equinix-assigned interface identifier
         */
        uuid: string;
    }

    export interface ConnectionASideAccessPointRouter {
        /**
         * Unique Resource Identifier
         */
        href: string;
        /**
         * Equinix-assigned interface identifier
         */
        uuid?: string;
    }

    export interface ConnectionASideAccessPointRoutingProtocol {
        /**
         * Routing protocol instance state
         */
        state?: string;
        /**
         * Interface type
         */
        type?: string;
        /**
         * Equinix-assigned interface identifier
         */
        uuid?: string;
    }

    export interface ConnectionASideAccessPointVirtualDevice {
        /**
         * Unique Resource Identifier
         */
        href: string;
        /**
         * Interface type
         */
        type?: string;
        /**
         * Equinix-assigned interface identifier
         */
        uuid?: string;
    }

    export interface ConnectionASideAdditionalInfo {
        /**
         * Additional information key
         */
        key?: string;
        /**
         * Additional information value
         */
        value?: string;
    }

    export interface ConnectionASideServiceToken {
        /**
         * User-provided service description
         */
        description: string;
        /**
         * Unique Resource Identifier
         */
        href: string;
        /**
         * Interface type
         */
        type?: string;
        /**
         * Equinix-assigned interface identifier
         */
        uuid?: string;
    }

    export interface ConnectionAccount {
        accountName: string;
        accountNumber: number;
        globalCustId: string;
        globalOrgId: string;
        globalOrganizationName: string;
        orgId: number;
        organizationName: string;
    }

    export interface ConnectionChangeLog {
        createdBy: string;
        createdByEmail: string;
        createdByFullName: string;
        createdDateTime: string;
        deletedBy: string;
        deletedByEmail: string;
        deletedByFullName: string;
        deletedDateTime: string;
        updatedBy: string;
        updatedByEmail: string;
        updatedByFullName: string;
        updatedDateTime: string;
    }

    export interface ConnectionNotification {
        /**
         * Array of contact emails
         */
        emails: string[];
        /**
         * Send interval
         */
        sendInterval?: string;
        /**
         * Notification Type - ALL,CONNECTION*APPROVAL,SALES*REP_NOTIFICATIONS, NOTIFICATIONS
         */
        type: string;
    }

    export interface ConnectionOperation {
        equinixStatus: string;
        errors: outputs.fabric.ConnectionOperationError[];
        providerStatus: string;
    }

    export interface ConnectionOperationError {
        /**
         * Connection side additional information
         */
        additionalInfo: outputs.fabric.ConnectionOperationErrorAdditionalInfo[];
        correlationId: string;
        details: string;
        errorCode: string;
        errorMessage: string;
        help: string;
    }

    export interface ConnectionOperationErrorAdditionalInfo {
        property: string;
        reason: string;
    }

    export interface ConnectionOrder {
        /**
         * Billing tier for connection bandwidth
         */
        billingTier?: string;
        /**
         * Order Identification
         */
        orderId: string;
        /**
         * Order Reference Number
         */
        orderNumber: string;
        /**
         * Purchase order number
         */
        purchaseOrderNumber?: string;
    }

    export interface ConnectionProject {
        /**
         * Unique Resource URL
         */
        href: string;
        /**
         * Project Id
         */
        projectId: string;
    }

    export interface ConnectionRedundancy {
        /**
         * Redundancy group identifier
         */
        group: string;
        /**
         * Priority type- PRIMARY, SECONDARY
         */
        priority?: string;
    }

    export interface ConnectionZSide {
        /**
         * Point of access details
         */
        accessPoint?: outputs.fabric.ConnectionZSideAccessPoint;
        /**
         * Connection side additional information
         */
        additionalInfo?: outputs.fabric.ConnectionZSideAdditionalInfo[];
        /**
         * For service token based connections, Service tokens authorize users to access protected resources and services. Resource owners can distribute the tokens to trusted partners and vendors, allowing selected third parties to work directly with Equinix network assets
         */
        serviceToken?: outputs.fabric.ConnectionZSideServiceToken;
    }

    export interface ConnectionZSideAccessPoint {
        /**
         * Account
         */
        account: outputs.fabric.ConnectionZSideAccessPointAccount;
        /**
         * Authentication key for provider based connections
         */
        authenticationKey?: string;
        /**
         * @deprecated use router attribute instead; gateway is no longer a part of the supported backend
         */
        gateway?: outputs.fabric.ConnectionZSideAccessPointGateway;
        /**
         * Virtual device interface
         */
        interface?: outputs.fabric.ConnectionZSideAccessPointInterface;
        /**
         * Connection link protocol
         */
        linkProtocol?: outputs.fabric.ConnectionZSideAccessPointLinkProtocol;
        /**
         * Access point location
         */
        location: outputs.fabric.ConnectionZSideAccessPointLocation;
        network?: outputs.fabric.ConnectionZSideAccessPointNetwork;
        /**
         * Peering Type- PRIVATE,MICROSOFT,PUBLIC, MANUAL
         */
        peeringType?: string;
        /**
         * Port access point information
         */
        port?: outputs.fabric.ConnectionZSideAccessPointPort;
        /**
         * Service Profile
         */
        profile?: outputs.fabric.ConnectionZSideAccessPointProfile;
        /**
         * Provider assigned Connection Id
         */
        providerConnectionId?: string;
        /**
         * Cloud Router access point information that replaces `gateway` (refers to below for nested schema)
         */
        router?: outputs.fabric.ConnectionZSideAccessPointRouter;
        /**
         * Access point routing protocols configuration
         */
        routingProtocols?: outputs.fabric.ConnectionZSideAccessPointRoutingProtocol[];
        /**
         * Access point seller region
         */
        sellerRegion?: string;
        /**
         * Interface type
         */
        type?: string;
        /**
         * Virtual device
         */
        virtualDevice?: outputs.fabric.ConnectionZSideAccessPointVirtualDevice;
    }

    export interface ConnectionZSideAccessPointAccount {
        accountName: string;
        accountNumber: number;
        globalCustId: string;
        globalOrgId: string;
        globalOrganizationName: string;
        orgId: number;
        organizationName: string;
    }

    export interface ConnectionZSideAccessPointGateway {
        /**
         * Unique Resource Identifier
         */
        href: string;
        /**
         * Equinix-assigned interface identifier
         */
        uuid?: string;
    }

    export interface ConnectionZSideAccessPointInterface {
        /**
         * id
         */
        id: string;
        /**
         * Interface type
         */
        type?: string;
        /**
         * Equinix-assigned interface identifier
         */
        uuid?: string;
    }

    export interface ConnectionZSideAccessPointLinkProtocol {
        /**
         * Interface type
         */
        type?: string;
        /**
         * Vlan Customer Tag information, vlanCTag value specified for QINQ connections
         */
        vlanCTag: number;
        /**
         * Vlan Provider Tag information, vlanSTag value specified for QINQ connections
         */
        vlanSTag: number;
        /**
         * Vlan Tag information, vlanTag value specified for DOT1Q connections
         */
        vlanTag: number;
    }

    export interface ConnectionZSideAccessPointLocation {
        /**
         * IBX Code
         */
        ibx: string;
        /**
         * Access point metro code
         */
        metroCode: string;
        /**
         * Access point metro name
         */
        metroName: string;
        /**
         * Access point region
         */
        region: string;
    }

    export interface ConnectionZSideAccessPointNetwork {
        /**
         * Unique Resource Identifier
         */
        href: string;
        /**
         * Equinix-assigned interface identifier
         */
        uuid?: string;
    }

    export interface ConnectionZSideAccessPointPort {
        /**
         * Unique Resource Identifier
         */
        href: string;
        /**
         * Port name
         */
        name: string;
        /**
         * Redundancy Information
         */
        redundancies: outputs.fabric.ConnectionZSideAccessPointPortRedundancy[];
        /**
         * Equinix-assigned interface identifier
         */
        uuid: string;
    }

    export interface ConnectionZSideAccessPointPortRedundancy {
        /**
         * Priority type- PRIMARY, SECONDARY
         */
        priority: string;
    }

    export interface ConnectionZSideAccessPointProfile {
        /**
         * Access point config information
         */
        accessPointTypeConfigs: outputs.fabric.ConnectionZSideAccessPointProfileAccessPointTypeConfig[];
        /**
         * User-provided service description
         */
        description: string;
        /**
         * Unique Resource Identifier
         */
        href: string;
        /**
         * Port name
         */
        name: string;
        /**
         * Interface type
         */
        type: string;
        /**
         * Equinix-assigned interface identifier
         */
        uuid: string;
    }

    export interface ConnectionZSideAccessPointProfileAccessPointTypeConfig {
        /**
         * Interface type
         */
        type: string;
        /**
         * Equinix-assigned interface identifier
         */
        uuid: string;
    }

    export interface ConnectionZSideAccessPointRouter {
        /**
         * Unique Resource Identifier
         */
        href: string;
        /**
         * Equinix-assigned interface identifier
         */
        uuid?: string;
    }

    export interface ConnectionZSideAccessPointRoutingProtocol {
        /**
         * Routing protocol instance state
         */
        state?: string;
        /**
         * Interface type
         */
        type?: string;
        /**
         * Equinix-assigned interface identifier
         */
        uuid?: string;
    }

    export interface ConnectionZSideAccessPointVirtualDevice {
        /**
         * Unique Resource Identifier
         */
        href: string;
        /**
         * Interface type
         */
        type?: string;
        /**
         * Equinix-assigned interface identifier
         */
        uuid?: string;
    }

    export interface ConnectionZSideAdditionalInfo {
        /**
         * Additional information key
         */
        key?: string;
        /**
         * Additional information value
         */
        value?: string;
    }

    export interface ConnectionZSideServiceToken {
        /**
         * User-provided service description
         */
        description: string;
        /**
         * Unique Resource Identifier
         */
        href: string;
        /**
         * Interface type
         */
        type?: string;
        /**
         * Equinix-assigned interface identifier
         */
        uuid?: string;
    }

    export interface GetCloudRouterAccount {
        accountName: string;
        accountNumber: number;
        globalCustId: string;
        globalOrgId: string;
        globalOrganizationName: string;
        orgId: number;
        organizationName: string;
    }

    export interface GetCloudRouterChangeLog {
        createdBy: string;
        createdByEmail: string;
        createdByFullName: string;
        createdDateTime: string;
        deletedBy: string;
        deletedByEmail: string;
        deletedByFullName: string;
        deletedDateTime: string;
        updatedBy: string;
        updatedByEmail: string;
        updatedByFullName: string;
        updatedDateTime: string;
    }

    export interface GetCloudRouterLocation {
        href: string;
        ibx: string;
        metroCode: string;
        metroName: string;
        region: string;
    }

    export interface GetCloudRouterNotification {
        emails: string[];
        sendInterval: string;
        type: string;
    }

    export interface GetCloudRouterOrder {
        billingTier: string;
        orderId: string;
        orderNumber: string;
        purchaseOrderNumber: string;
    }

    export interface GetCloudRouterPackage {
        code: string;
    }

    export interface GetCloudRouterProject {
        /**
         * Unique Resource URL
         */
        href: string;
        /**
         * Project Id
         */
        projectId: string;
    }

    export interface GetConnectionASide {
        accessPoint: outputs.fabric.GetConnectionASideAccessPoint;
        serviceToken: outputs.fabric.GetConnectionASideServiceToken;
    }

    export interface GetConnectionASideAccessPoint {
        accounts: outputs.fabric.GetConnectionASideAccessPointAccount[];
        authenticationKey: string;
        /**
         * @deprecated router attribute will be returned instead
         */
        gateways: outputs.fabric.GetConnectionASideAccessPointGateway[];
        interfaces: outputs.fabric.GetConnectionASideAccessPointInterface[];
        linkProtocols: outputs.fabric.GetConnectionASideAccessPointLinkProtocol[];
        locations: outputs.fabric.GetConnectionASideAccessPointLocation[];
        peeringType: string;
        ports: outputs.fabric.GetConnectionASideAccessPointPort[];
        profiles: outputs.fabric.GetConnectionASideAccessPointProfile[];
        providerConnectionId: string;
        /**
         * CloudRouter; Replaces `gateway` attribute (Set of Object)
         */
        routers: outputs.fabric.GetConnectionASideAccessPointRouter[];
        sellerRegion: string;
        type: string;
        virtualDevices: outputs.fabric.GetConnectionASideAccessPointVirtualDevice[];
    }

    export interface GetConnectionASideAccessPointAccount {
        accountName: string;
        accountNumber: number;
        globalCustId: string;
        globalOrgId: string;
        globalOrganizationName: string;
        orgId: number;
        organizationName: string;
    }

    export interface GetConnectionASideAccessPointGateway {
        href: string;
        state: string;
        uuid: string;
    }

    export interface GetConnectionASideAccessPointInterface {
        id: string;
        type: string;
        uuid: string;
    }

    export interface GetConnectionASideAccessPointLinkProtocol {
        type: string;
        vlanCTag: number;
        vlanSTag: number;
        vlanTag: number;
    }

    export interface GetConnectionASideAccessPointLocation {
        href: string;
        ibx: string;
        metroCode: string;
        metroName: string;
        region: string;
    }

    export interface GetConnectionASideAccessPointPort {
        href: string;
        name: string;
        redundancies: outputs.fabric.GetConnectionASideAccessPointPortRedundancy[];
        uuid: string;
    }

    export interface GetConnectionASideAccessPointPortRedundancy {
        priority: string;
    }

    export interface GetConnectionASideAccessPointProfile {
        accessPointTypeConfigs: outputs.fabric.GetConnectionASideAccessPointProfileAccessPointTypeConfig[];
        description: string;
        href: string;
        name: string;
        type: string;
        uuid: string;
    }

    export interface GetConnectionASideAccessPointProfileAccessPointTypeConfig {
        allowBandwidthAutoApproval: boolean;
        allowBandwidthUpgrade: boolean;
        allowCustomBandwidth: boolean;
        allowRemoteConnections: boolean;
        apiConfigs: outputs.fabric.GetConnectionASideAccessPointProfileAccessPointTypeConfigApiConfig[];
        authenticationKeys: outputs.fabric.GetConnectionASideAccessPointProfileAccessPointTypeConfigAuthenticationKey[];
        bandwidthAlertThreshold: number;
        connectionLabel: string;
        connectionRedundancyRequired: boolean;
        enableAutoGenerateServiceKey: boolean;
        linkProtocolConfigs: outputs.fabric.GetConnectionASideAccessPointProfileAccessPointTypeConfigLinkProtocolConfig[];
        supportedBandwidths: number[];
        type: string;
        uuid: string;
    }

    export interface GetConnectionASideAccessPointProfileAccessPointTypeConfigApiConfig {
        allowOverSubscription: boolean;
        apiAvailable: boolean;
        bandwidthFromApi: boolean;
        equinixManagedPort: boolean;
        equinixManagedVlan: boolean;
        integrationId: string;
        overSubscriptionLimit: number;
    }

    export interface GetConnectionASideAccessPointProfileAccessPointTypeConfigAuthenticationKey {
        description: string;
        label: string;
        required: boolean;
    }

    export interface GetConnectionASideAccessPointProfileAccessPointTypeConfigLinkProtocolConfig {
        encapsulation: string;
        encapsulationStrategy: string;
        reuseVlanSTag: boolean;
    }

    export interface GetConnectionASideAccessPointRouter {
        href: string;
        state: string;
        uuid: string;
    }

    export interface GetConnectionASideAccessPointVirtualDevice {
        href: string;
        type: string;
        uuid: string;
    }

    export interface GetConnectionASideServiceToken {
        description: string;
        href: string;
        type: string;
        uuid: string;
    }

    export interface GetConnectionAccount {
        accountName: string;
        accountNumber: number;
        globalCustId: string;
        globalOrgId: string;
        globalOrganizationName: string;
        orgId: number;
        organizationName: string;
    }

    export interface GetConnectionAdditionalInfo {
        key: string;
        value: string;
    }

    export interface GetConnectionChangeLog {
        createdBy: string;
        createdByEmail: string;
        createdByFullName: string;
        createdDateTime: string;
        deletedBy: string;
        deletedByEmail: string;
        deletedByFullName: string;
        deletedDateTime: string;
        updatedBy: string;
        updatedByEmail: string;
        updatedByFullName: string;
        updatedDateTime: string;
    }

    export interface GetConnectionNotification {
        emails: string[];
        sendInterval: string;
        type: string;
    }

    export interface GetConnectionOperation {
        equinixStatus: string;
        errors: outputs.fabric.GetConnectionOperationError[];
        providerStatus: string;
    }

    export interface GetConnectionOperationError {
        additionalInfos: outputs.fabric.GetConnectionOperationErrorAdditionalInfo[];
        correlationId: string;
        details: string;
        errorCode: string;
        errorMessage: string;
        help: string;
    }

    export interface GetConnectionOperationErrorAdditionalInfo {
        property: string;
        reason: string;
    }

    export interface GetConnectionOrder {
        billingTier: string;
        orderId: string;
        orderNumber: string;
        purchaseOrderNumber: string;
    }

    export interface GetConnectionProject {
        /**
         * Unique Resource URL
         */
        href: string;
        /**
         * Project Id
         */
        projectId: string;
    }

    export interface GetConnectionRedundancy {
        group: string;
        priority: string;
    }

    export interface GetConnectionZSide {
        accessPoint: outputs.fabric.GetConnectionZSideAccessPoint;
        serviceToken: outputs.fabric.GetConnectionZSideServiceToken;
    }

    export interface GetConnectionZSideAccessPoint {
        accounts: outputs.fabric.GetConnectionZSideAccessPointAccount[];
        authenticationKey: string;
        /**
         * @deprecated router attribute will be returned instead
         */
        gateways: outputs.fabric.GetConnectionZSideAccessPointGateway[];
        interfaces: outputs.fabric.GetConnectionZSideAccessPointInterface[];
        linkProtocols: outputs.fabric.GetConnectionZSideAccessPointLinkProtocol[];
        locations: outputs.fabric.GetConnectionZSideAccessPointLocation[];
        peeringType: string;
        ports: outputs.fabric.GetConnectionZSideAccessPointPort[];
        profiles: outputs.fabric.GetConnectionZSideAccessPointProfile[];
        providerConnectionId: string;
        /**
         * CloudRouter; Replaces `gateway` attribute (Set of Object)
         */
        routers: outputs.fabric.GetConnectionZSideAccessPointRouter[];
        sellerRegion: string;
        type: string;
        virtualDevices: outputs.fabric.GetConnectionZSideAccessPointVirtualDevice[];
    }

    export interface GetConnectionZSideAccessPointAccount {
        accountName: string;
        accountNumber: number;
        globalCustId: string;
        globalOrgId: string;
        globalOrganizationName: string;
        orgId: number;
        organizationName: string;
    }

    export interface GetConnectionZSideAccessPointGateway {
        href: string;
        state: string;
        uuid: string;
    }

    export interface GetConnectionZSideAccessPointInterface {
        id: string;
        type: string;
        uuid: string;
    }

    export interface GetConnectionZSideAccessPointLinkProtocol {
        type: string;
        vlanCTag: number;
        vlanSTag: number;
        vlanTag: number;
    }

    export interface GetConnectionZSideAccessPointLocation {
        href: string;
        ibx: string;
        metroCode: string;
        metroName: string;
        region: string;
    }

    export interface GetConnectionZSideAccessPointPort {
        href: string;
        name: string;
        redundancies: outputs.fabric.GetConnectionZSideAccessPointPortRedundancy[];
        uuid: string;
    }

    export interface GetConnectionZSideAccessPointPortRedundancy {
        priority: string;
    }

    export interface GetConnectionZSideAccessPointProfile {
        accessPointTypeConfigs: outputs.fabric.GetConnectionZSideAccessPointProfileAccessPointTypeConfig[];
        description: string;
        href: string;
        name: string;
        type: string;
        uuid: string;
    }

    export interface GetConnectionZSideAccessPointProfileAccessPointTypeConfig {
        allowBandwidthAutoApproval: boolean;
        allowBandwidthUpgrade: boolean;
        allowCustomBandwidth: boolean;
        allowRemoteConnections: boolean;
        apiConfigs: outputs.fabric.GetConnectionZSideAccessPointProfileAccessPointTypeConfigApiConfig[];
        authenticationKeys: outputs.fabric.GetConnectionZSideAccessPointProfileAccessPointTypeConfigAuthenticationKey[];
        bandwidthAlertThreshold: number;
        connectionLabel: string;
        connectionRedundancyRequired: boolean;
        enableAutoGenerateServiceKey: boolean;
        linkProtocolConfigs: outputs.fabric.GetConnectionZSideAccessPointProfileAccessPointTypeConfigLinkProtocolConfig[];
        supportedBandwidths: number[];
        type: string;
        uuid: string;
    }

    export interface GetConnectionZSideAccessPointProfileAccessPointTypeConfigApiConfig {
        allowOverSubscription: boolean;
        apiAvailable: boolean;
        bandwidthFromApi: boolean;
        equinixManagedPort: boolean;
        equinixManagedVlan: boolean;
        integrationId: string;
        overSubscriptionLimit: number;
    }

    export interface GetConnectionZSideAccessPointProfileAccessPointTypeConfigAuthenticationKey {
        description: string;
        label: string;
        required: boolean;
    }

    export interface GetConnectionZSideAccessPointProfileAccessPointTypeConfigLinkProtocolConfig {
        encapsulation: string;
        encapsulationStrategy: string;
        reuseVlanSTag: boolean;
    }

    export interface GetConnectionZSideAccessPointRouter {
        href: string;
        state: string;
        uuid: string;
    }

    export interface GetConnectionZSideAccessPointVirtualDevice {
        href: string;
        type: string;
        uuid: string;
    }

    export interface GetConnectionZSideServiceToken {
        description: string;
        href: string;
        type: string;
        uuid: string;
    }

    export interface GetPortAccount {
        accountName: string;
        accountNumber: number;
        globalCustId: string;
        globalOrgId: string;
        globalOrganizationName: string;
        orgId: number;
        organizationName: string;
    }

    export interface GetPortChangeLog {
        createdBy: string;
        createdByEmail: string;
        createdByFullName: string;
        createdDateTime: string;
        deletedBy: string;
        deletedByEmail: string;
        deletedByFullName: string;
        deletedDateTime: string;
        updatedBy: string;
        updatedByEmail: string;
        updatedByFullName: string;
        updatedDateTime: string;
    }

    export interface GetPortDevice {
        name: string;
        redundancies: outputs.fabric.GetPortDeviceRedundancy[];
    }

    export interface GetPortDeviceRedundancy {
        group: string;
        priority: string;
    }

    export interface GetPortEncapsulation {
        tagProtocolId: string;
        type: string;
    }

    export interface GetPortLocation {
        href: string;
        ibx: string;
        metroCode: string;
        metroName: string;
        region: string;
    }

    export interface GetPortOperation {
        connectionCount: number;
        opStatusChangedAt: string;
        operationalStatus: string;
    }

    export interface GetPortRedundancy {
        enabled: boolean;
        group: string;
        priority: string;
    }

    export interface GetPortsDatum {
        accounts: outputs.fabric.GetPortsDatumAccount[];
        availableBandwidth: number;
        bandwidth: number;
        changeLogs: outputs.fabric.GetPortsDatumChangeLog[];
        description: string;
        devices: outputs.fabric.GetPortsDatumDevice[];
        encapsulations: outputs.fabric.GetPortsDatumEncapsulation[];
        href: string;
        lagEnabled: boolean;
        locations: outputs.fabric.GetPortsDatumLocation[];
        name: string;
        operations: outputs.fabric.GetPortsDatumOperation[];
        redundancies: outputs.fabric.GetPortsDatumRedundancy[];
        serviceType: string;
        state: string;
        type: string;
        usedBandwidth: number;
        uuid?: string;
    }

    export interface GetPortsDatumAccount {
        accountName: string;
        accountNumber: number;
        globalCustId: string;
        globalOrgId: string;
        globalOrganizationName: string;
        orgId: number;
        organizationName: string;
    }

    export interface GetPortsDatumChangeLog {
        createdBy: string;
        createdByEmail: string;
        createdByFullName: string;
        createdDateTime: string;
        deletedBy: string;
        deletedByEmail: string;
        deletedByFullName: string;
        deletedDateTime: string;
        updatedBy: string;
        updatedByEmail: string;
        updatedByFullName: string;
        updatedDateTime: string;
    }

    export interface GetPortsDatumDevice {
        name: string;
        redundancies: outputs.fabric.GetPortsDatumDeviceRedundancy[];
    }

    export interface GetPortsDatumDeviceRedundancy {
        group: string;
        priority: string;
    }

    export interface GetPortsDatumEncapsulation {
        tagProtocolId: string;
        type: string;
    }

    export interface GetPortsDatumLocation {
        href: string;
        ibx: string;
        metroCode: string;
        metroName: string;
        region: string;
    }

    export interface GetPortsDatumOperation {
        connectionCount: number;
        opStatusChangedAt: string;
        operationalStatus: string;
    }

    export interface GetPortsDatumRedundancy {
        enabled: boolean;
        group: string;
        priority: string;
    }

    export interface GetPortsFilter {
        /**
         * Query Parameter to Get Ports By Name
         */
        name?: string;
    }

    export interface GetRoutingProtocolBfd {
        /**
         * Bidirectional Forwarding Detection enablement
         */
        enabled: boolean;
        /**
         * Interval range between the received BFD control packets
         */
        interval?: string;
    }

    export interface GetRoutingProtocolBgpIpv4 {
        /**
         * Customer side peering ip
         */
        customerPeerIp: string;
        /**
         * Admin status for the BGP session
         */
        enabled?: boolean;
        /**
         * Equinix side peering ip
         */
        equinixPeerIp: string;
    }

    export interface GetRoutingProtocolBgpIpv6 {
        /**
         * Customer side peering ip
         */
        customerPeerIp: string;
        /**
         * Admin status for the BGP session
         */
        enabled?: boolean;
        /**
         * Equinix side peering ip
         */
        equinixPeerIp: string;
    }

    export interface GetRoutingProtocolChange {
        href: string;
        type: string;
        uuid: string;
    }

    export interface GetRoutingProtocolChangeLog {
        createdBy: string;
        createdByEmail: string;
        createdByFullName: string;
        createdDateTime: string;
        deletedBy: string;
        deletedByEmail: string;
        deletedByFullName: string;
        deletedDateTime: string;
        updatedBy: string;
        updatedByEmail: string;
        updatedByFullName: string;
        updatedDateTime: string;
    }

    export interface GetRoutingProtocolDirectIpv4 {
        /**
         * Equinix side Interface IP address
         */
        equinixIfaceIp: string;
    }

    export interface GetRoutingProtocolDirectIpv6 {
        /**
         * Equinix side Interface IP address
         */
        equinixIfaceIp?: string;
    }

    export interface GetRoutingProtocolOperation {
        errors: outputs.fabric.GetRoutingProtocolOperationError[];
    }

    export interface GetRoutingProtocolOperationError {
        additionalInfos: outputs.fabric.GetRoutingProtocolOperationErrorAdditionalInfo[];
        correlationId: string;
        details: string;
        errorCode: string;
        errorMessage: string;
        help: string;
    }

    export interface GetRoutingProtocolOperationErrorAdditionalInfo {
        property: string;
        reason: string;
    }

    export interface GetServiceProfileAccessPointTypeConfig {
        allowBandwidthAutoApproval: boolean;
        allowBandwidthUpgrade: boolean;
        allowCustomBandwidth: boolean;
        allowRemoteConnections: boolean;
        apiConfigs: outputs.fabric.GetServiceProfileAccessPointTypeConfigApiConfig[];
        authenticationKeys: outputs.fabric.GetServiceProfileAccessPointTypeConfigAuthenticationKey[];
        bandwidthAlertThreshold: number;
        connectionLabel: string;
        connectionRedundancyRequired: boolean;
        enableAutoGenerateServiceKey: boolean;
        linkProtocolConfigs: outputs.fabric.GetServiceProfileAccessPointTypeConfigLinkProtocolConfig[];
        supportedBandwidths: number[];
        type: string;
        uuid: string;
    }

    export interface GetServiceProfileAccessPointTypeConfigApiConfig {
        allowOverSubscription: boolean;
        apiAvailable: boolean;
        bandwidthFromApi: boolean;
        equinixManagedPort: boolean;
        equinixManagedVlan: boolean;
        integrationId: string;
        overSubscriptionLimit: number;
    }

    export interface GetServiceProfileAccessPointTypeConfigAuthenticationKey {
        description: string;
        label: string;
        required: boolean;
    }

    export interface GetServiceProfileAccessPointTypeConfigLinkProtocolConfig {
        encapsulation: string;
        encapsulationStrategy: string;
        reuseVlanSTag: boolean;
    }

    export interface GetServiceProfileAccount {
        accountName: string;
        accountNumber: number;
        globalCustId: string;
        globalOrgId: string;
        globalOrganizationName: string;
        orgId: number;
        organizationName: string;
        ucmId: string;
    }

    export interface GetServiceProfileChangeLog {
        createdBy: string;
        createdByEmail: string;
        createdByFullName: string;
        createdDateTime: string;
        deletedBy: string;
        deletedByEmail: string;
        deletedByFullName: string;
        deletedDateTime: string;
        updatedBy: string;
        updatedByEmail: string;
        updatedByFullName: string;
        updatedDateTime: string;
    }

    export interface GetServiceProfileCustomField {
        captureInEmail: boolean;
        dataType: string;
        description: string;
        label: string;
        options: string[];
        required: boolean;
    }

    export interface GetServiceProfileMarketingInfo {
        logo: string;
        processSteps: outputs.fabric.GetServiceProfileMarketingInfoProcessStep[];
        promotion: boolean;
    }

    export interface GetServiceProfileMarketingInfoProcessStep {
        description: string;
        subTitle: string;
        title: string;
    }

    export interface GetServiceProfileMetro {
        code: string;
        displayName: string;
        ibxs: string[];
        inTrail: boolean;
        name: string;
        sellerRegions: {[key: string]: string};
    }

    export interface GetServiceProfileNotification {
        emails: string[];
        sendInterval: string;
        type: string;
    }

    export interface GetServiceProfilePort {
        crossConnectId: string;
        locations: outputs.fabric.GetServiceProfilePortLocation[];
        sellerRegion: string;
        sellerRegionDescription: string;
        type: string;
        uuid: string;
    }

    export interface GetServiceProfilePortLocation {
        ibx: string;
        metroCode: string;
        metroName: string;
        region: string;
    }

    export interface GetServiceProfileProject {
        href: string;
        projectId: string;
    }

    export interface GetServiceProfilesDatum {
        accessPointTypeConfigs: outputs.fabric.GetServiceProfilesDatumAccessPointTypeConfig[];
        accounts: outputs.fabric.GetServiceProfilesDatumAccount[];
        allowedEmails: string[];
        changeLogs: outputs.fabric.GetServiceProfilesDatumChangeLog[];
        customFields: outputs.fabric.GetServiceProfilesDatumCustomField[];
        description: string;
        href: string;
        marketingInfos: outputs.fabric.GetServiceProfilesDatumMarketingInfo[];
        metros: outputs.fabric.GetServiceProfilesDatumMetro[];
        name: string;
        notifications: outputs.fabric.GetServiceProfilesDatumNotification[];
        ports: outputs.fabric.GetServiceProfilesDatumPort[];
        projects: outputs.fabric.GetServiceProfilesDatumProject[];
        selfProfile: boolean;
        state?: string;
        tags: string[];
        type: string;
        uuid?: string;
        visibility: string;
    }

    export interface GetServiceProfilesDatumAccessPointTypeConfig {
        allowBandwidthAutoApproval: boolean;
        allowBandwidthUpgrade: boolean;
        allowCustomBandwidth: boolean;
        allowRemoteConnections: boolean;
        apiConfigs: outputs.fabric.GetServiceProfilesDatumAccessPointTypeConfigApiConfig[];
        authenticationKeys: outputs.fabric.GetServiceProfilesDatumAccessPointTypeConfigAuthenticationKey[];
        bandwidthAlertThreshold: number;
        connectionLabel: string;
        connectionRedundancyRequired: boolean;
        enableAutoGenerateServiceKey: boolean;
        linkProtocolConfigs: outputs.fabric.GetServiceProfilesDatumAccessPointTypeConfigLinkProtocolConfig[];
        supportedBandwidths: number[];
        type: string;
        uuid: string;
    }

    export interface GetServiceProfilesDatumAccessPointTypeConfigApiConfig {
        allowOverSubscription: boolean;
        apiAvailable: boolean;
        bandwidthFromApi: boolean;
        equinixManagedPort: boolean;
        equinixManagedVlan: boolean;
        integrationId: string;
        overSubscriptionLimit: number;
    }

    export interface GetServiceProfilesDatumAccessPointTypeConfigAuthenticationKey {
        description: string;
        label: string;
        required: boolean;
    }

    export interface GetServiceProfilesDatumAccessPointTypeConfigLinkProtocolConfig {
        encapsulation: string;
        encapsulationStrategy: string;
        reuseVlanSTag: boolean;
    }

    export interface GetServiceProfilesDatumAccount {
        accountName: string;
        accountNumber: number;
        globalCustId: string;
        globalOrgId: string;
        globalOrganizationName: string;
        orgId: number;
        organizationName: string;
        ucmId: string;
    }

    export interface GetServiceProfilesDatumChangeLog {
        createdBy: string;
        createdByEmail: string;
        createdByFullName: string;
        createdDateTime: string;
        deletedBy: string;
        deletedByEmail: string;
        deletedByFullName: string;
        deletedDateTime: string;
        updatedBy: string;
        updatedByEmail: string;
        updatedByFullName: string;
        updatedDateTime: string;
    }

    export interface GetServiceProfilesDatumCustomField {
        captureInEmail: boolean;
        dataType: string;
        description: string;
        label: string;
        options: string[];
        required: boolean;
    }

    export interface GetServiceProfilesDatumMarketingInfo {
        logo: string;
        processSteps: outputs.fabric.GetServiceProfilesDatumMarketingInfoProcessStep[];
        promotion: boolean;
    }

    export interface GetServiceProfilesDatumMarketingInfoProcessStep {
        description: string;
        subTitle: string;
        title: string;
    }

    export interface GetServiceProfilesDatumMetro {
        code: string;
        displayName: string;
        ibxs: string[];
        inTrail: boolean;
        name: string;
        sellerRegions: {[key: string]: string};
    }

    export interface GetServiceProfilesDatumNotification {
        emails: string[];
        sendInterval: string;
        type: string;
    }

    export interface GetServiceProfilesDatumPort {
        crossConnectId: string;
        locations: outputs.fabric.GetServiceProfilesDatumPortLocation[];
        sellerRegion: string;
        sellerRegionDescription: string;
        type: string;
        uuid: string;
    }

    export interface GetServiceProfilesDatumPortLocation {
        ibx: string;
        metroCode: string;
        metroName: string;
        region: string;
    }

    export interface GetServiceProfilesDatumProject {
        href: string;
        projectId: string;
    }

    export interface GetServiceProfilesFilter {
        /**
         * Possible operator to use on filters = - equal
         */
        operator?: string;
        /**
         * Search Criteria for Service Profile - /name, /uuid, /state, /metros/code, /visibility, /type
         */
        property?: string;
        /**
         * Values
         */
        values?: string[];
    }

    export interface GetServiceProfilesSort {
        /**
         * Priority type- DESC, ASC
         */
        direction?: string;
        /**
         * Search operation sort criteria /name /state /changeLog/createdDateTime /changeLog/updatedDateTime
         */
        property?: string;
    }

    export interface RoutingProtocolBfd {
        /**
         * Bidirectional Forwarding Detection enablement
         */
        enabled: boolean;
        /**
         * Interval range between the received BFD control packets
         */
        interval?: string;
    }

    export interface RoutingProtocolBgpIpv4 {
        /**
         * Customer side peering ip
         */
        customerPeerIp: string;
        /**
         * Admin status for the BGP session
         */
        enabled?: boolean;
        /**
         * Equinix side peering ip
         */
        equinixPeerIp: string;
    }

    export interface RoutingProtocolBgpIpv6 {
        /**
         * Customer side peering ip
         */
        customerPeerIp: string;
        /**
         * Admin status for the BGP session
         */
        enabled?: boolean;
        /**
         * Equinix side peering ip
         */
        equinixPeerIp: string;
    }

    export interface RoutingProtocolChange {
        href: string;
        type: string;
        uuid: string;
    }

    export interface RoutingProtocolChangeLog {
        createdBy: string;
        createdByEmail: string;
        createdByFullName: string;
        createdDateTime: string;
        deletedBy: string;
        deletedByEmail: string;
        deletedByFullName: string;
        deletedDateTime: string;
        updatedBy: string;
        updatedByEmail: string;
        updatedByFullName: string;
        updatedDateTime: string;
    }

    export interface RoutingProtocolDirectIpv4 {
        /**
         * Equinix side Interface IP address
         */
        equinixIfaceIp: string;
    }

    export interface RoutingProtocolDirectIpv6 {
        /**
         * Equinix side Interface IP address
         */
        equinixIfaceIp?: string;
    }

    export interface RoutingProtocolOperation {
        errors: outputs.fabric.RoutingProtocolOperationError[];
    }

    export interface RoutingProtocolOperationError {
        additionalInfos: outputs.fabric.RoutingProtocolOperationErrorAdditionalInfo[];
        correlationId: string;
        details: string;
        errorCode: string;
        errorMessage: string;
        help: string;
    }

    export interface RoutingProtocolOperationErrorAdditionalInfo {
        property: string;
        reason: string;
    }

    export interface ServiceProfileAccessPointTypeConfig {
        /**
         * Setting to enable or disable the ability of the buyer to change connection bandwidth without approval of the seller
         */
        allowBandwidthAutoApproval?: boolean;
        /**
         * Availability of a bandwidth upgrade. The default is false
         */
        allowBandwidthUpgrade?: boolean;
        /**
         * Setting to enable or disable the ability of the buyer to customize the bandwidth
         */
        allowCustomBandwidth?: boolean;
        /**
         * Setting to allow or prohibit remote connections to the service profile
         */
        allowRemoteConnections?: boolean;
        /**
         * Api configuration details
         */
        apiConfig?: outputs.fabric.ServiceProfileAccessPointTypeConfigApiConfig;
        /**
         * Authentication key details
         */
        authenticationKey?: outputs.fabric.ServiceProfileAccessPointTypeConfigAuthenticationKey;
        /**
         * Percentage of port bandwidth at which an allocation alert is generated
         */
        bandwidthAlertThreshold?: number;
        /**
         * Custom name for Connection
         */
        connectionLabel?: string;
        /**
         * Mandate redundant connections
         */
        connectionRedundancyRequired?: boolean;
        /**
         * Enable auto generate service key
         */
        enableAutoGenerateServiceKey?: boolean;
        /**
         * Link protocol configuration details
         */
        linkProtocolConfig?: outputs.fabric.ServiceProfileAccessPointTypeConfigLinkProtocolConfig;
        /**
         * Supported bandwidths
         */
        supportedBandwidths?: number[];
        /**
         * Type of access point type config - VD, COLO
         */
        type: string;
        /**
         * Colo/Port Uuid
         */
        uuid: string;
    }

    export interface ServiceProfileAccessPointTypeConfigApiConfig {
        /**
         * Setting showing that oversubscription support is available (true) or not (false). The default is false
         */
        allowOverSubscription?: boolean;
        /**
         * Setting indicating whether the API is available (true) or not (false)
         */
        apiAvailable?: boolean;
        /**
         * Bandwidth from api
         */
        bandwidthFromApi?: boolean;
        /**
         * Setting indicating that the port is managed by Equinix (true) or not (false)
         */
        equinixManagedPort?: boolean;
        /**
         * Setting indicating that the VLAN is managed by Equinix (true) or not (false)
         */
        equinixManagedVlan?: boolean;
        /**
         * Integration id
         */
        integrationId?: string;
        /**
         * A cap on over subscription
         */
        overSubscriptionLimit?: number;
    }

    export interface ServiceProfileAccessPointTypeConfigAuthenticationKey {
        /**
         * Description
         */
        description?: string;
        /**
         * Label
         */
        label?: string;
        /**
         * Required
         */
        required?: boolean;
    }

    export interface ServiceProfileAccessPointTypeConfigLinkProtocolConfig {
        /**
         * Port Encapsulation
         */
        encapsulation?: string;
        /**
         * Encapsulation strategy
         */
        encapsulationStrategy?: string;
        /**
         * Reuse vlan sTag
         */
        reuseVlanSTag?: boolean;
    }

    export interface ServiceProfileAccount {
        /**
         * Account Name
         */
        accountName?: string;
        /**
         * Account Number
         */
        accountNumber?: number;
        /**
         * Global Customer organization identifier
         */
        globalCustId?: string;
        /**
         * Global organization identifier
         */
        globalOrgId?: string;
        /**
         * Global organization name
         */
        globalOrganizationName?: string;
        /**
         * Customer organization identifier
         */
        orgId?: number;
        /**
         * Customer organization name
         */
        organizationName?: string;
        /**
         * Enterprise datastore id
         */
        ucmId?: string;
    }

    export interface ServiceProfileChangeLog {
        createdBy: string;
        createdByEmail: string;
        createdByFullName: string;
        createdDateTime: string;
        deletedBy: string;
        deletedByEmail: string;
        deletedByFullName: string;
        deletedDateTime: string;
        updatedBy: string;
        updatedByEmail: string;
        updatedByFullName: string;
        updatedDateTime: string;
    }

    export interface ServiceProfileCustomField {
        /**
         * Required field
         */
        captureInEmail?: boolean;
        /**
         * Data type
         */
        dataType: string;
        /**
         * Description
         */
        description?: string;
        /**
         * Label
         */
        label: string;
        /**
         * Options
         */
        options?: string[];
        /**
         * Required field
         */
        required: boolean;
    }

    export interface ServiceProfileMarketingInfo {
        /**
         * Logo
         */
        logo?: string;
        /**
         * Process Step
         */
        processSteps?: outputs.fabric.ServiceProfileMarketingInfoProcessStep[];
        /**
         * Promotion
         */
        promotion?: boolean;
    }

    export interface ServiceProfileMarketingInfoProcessStep {
        /**
         * Description
         */
        description?: string;
        /**
         * Sub Title
         */
        subTitle?: string;
        /**
         * Title
         */
        title?: string;
    }

    export interface ServiceProfileMetro {
        /**
         * Metro Code - Example SV
         */
        code?: string;
        /**
         * Display Name
         */
        displayName?: string;
        /**
         * IBX- Equinix International Business Exchange list
         */
        ibxs?: string[];
        /**
         * In Trail
         */
        inTrail?: boolean;
        /**
         * Metro Name
         */
        name?: string;
        /**
         * Seller Regions
         */
        sellerRegions?: {[key: string]: string};
    }

    export interface ServiceProfileNotification {
        /**
         * Array of contact emails
         */
        emails: string[];
        /**
         * Send interval
         */
        sendInterval?: string;
        /**
         * Notification Type - ALL,CONNECTION*APPROVAL,SALES*REP_NOTIFICATIONS, NOTIFICATIONS
         */
        type: string;
    }

    export interface ServiceProfilePort {
        /**
         * Cross Connect Id
         */
        crossConnectId?: string;
        /**
         * Colo/Port Location
         */
        location?: outputs.fabric.ServiceProfilePortLocation;
        /**
         * Seller Region
         */
        sellerRegion?: string;
        /**
         * Seller Region details
         */
        sellerRegionDescription?: string;
        /**
         * Colo/Port Type
         */
        type: string;
        /**
         * Colo/Port Uuid
         */
        uuid: string;
    }

    export interface ServiceProfilePortLocation {
        /**
         * IBX Code
         */
        ibx: string;
        /**
         * Access point metro code
         */
        metroCode: string;
        /**
         * Access point metro name
         */
        metroName: string;
        /**
         * Access point region
         */
        region: string;
    }

    export interface ServiceProfileProject {
        /**
         * Unique Resource URL
         */
        href: string;
        /**
         * Project Id
         */
        projectId: string;
    }

    export interface ServiceProfileVirtualDevice {
        /**
         * Device Interface Uuid
         */
        interfaceUuid?: string;
        /**
         * Device Location
         */
        location?: outputs.fabric.ServiceProfileVirtualDeviceLocation;
        /**
         * Virtual Device Type
         */
        type: string;
        /**
         * Virtual Device Uuid
         */
        uuid: string;
    }

    export interface ServiceProfileVirtualDeviceLocation {
        /**
         * IBX Code
         */
        ibx: string;
        /**
         * Access point metro code
         */
        metroCode: string;
        /**
         * Access point metro name
         */
        metroName: string;
        /**
         * Access point region
         */
        region: string;
    }

}

export namespace metal {
    export interface DeviceBehavior {
        /**
         * List of attributes that are allowed to change without recreating the instance. Supported attributes: `customData`, `userData`"
         */
        allowChanges?: string[];
    }

    export interface DeviceIpAddress {
        /**
         * CIDR suffix for IP address block to be assigned, i.e. amount of addresses.
         */
        cidr?: number;
        /**
         * List of UUIDs of IP block reservations
         * from which the public IPv4 address should be taken.
         *
         * You can supply one `ipAddress` block per IP address type. If you use the `ipAddress` you must
         * always pass a block for `privateIpv4`.
         *
         * To learn more about using the reserved IP addresses for new devices, see the examples in the
         * equinix.metal.ReservedIpBlock documentation.
         */
        reservationIds?: string[];
        /**
         * One of `privateIpv4`, `publicIpv4`, `publicIpv6`.
         */
        type: string;
    }

    export interface DeviceNetwork {
        /**
         * IPv4 or IPv6 address string.
         */
        address: string;
        /**
         * CIDR suffix for IP address block to be assigned, i.e. amount of addresses.
         */
        cidr: number;
        /**
         * IP version. One of `4`, `6`.
         */
        family: number;
        /**
         * Address of router.
         */
        gateway: string;
        /**
         * Whether the address is routable from the Internet.
         */
        public: boolean;
    }

    export interface DevicePort {
        /**
         * Whether this port is part of a bond in bonded network setup.
         */
        bonded: boolean;
        /**
         * ID of the port.
         */
        id: string;
        /**
         * MAC address assigned to the port.
         */
        mac: string;
        /**
         * Name of the port (e.g. `eth0`, or `bond0`).
         */
        name: string;
        /**
         * One of `privateIpv4`, `publicIpv4`, `publicIpv6`.
         */
        type: string;
    }

    export interface DeviceReinstall {
        /**
         * Whether the OS disk should be filled with `00h` bytes before reinstall.
         * Defaults to `false`.
         */
        deprovisionFast?: boolean;
        /**
         * Whether the provider should favour reinstall over destroy and create. Defaults to
         * `false`.
         */
        enabled?: boolean;
        /**
         * Whether the non-OS disks should be kept or wiped during reinstall.
         * Defaults to `false`.
         */
        preserveData?: boolean;
    }

    export interface GetDeviceBgpNeighborsBgpNeighbor {
        /**
         * IP address version, 4 or 6.
         */
        addressFamily: number;
        /**
         * Local autonomous system number.
         */
        customerAs: number;
        /**
         * Local used peer IP address.
         */
        customerIp: string;
        /**
         * Whether BGP session is password enabled.
         */
        md5Enabled: boolean;
        /**
         * BGP session password in plaintext (not a checksum).
         */
        md5Password: string;
        /**
         * Whether the neighbor is in EBGP multihop session.
         */
        multihop: boolean;
        /**
         * Peer AS number (different than customerAs for EBGP).
         */
        peerAs: number;
        /**
         * Array of IP addresses of this neighbor's peers.
         */
        peerIps?: string[];
        /**
         * Array of incoming routes.
         */
        routesIns: outputs.metal.GetDeviceBgpNeighborsBgpNeighborRoutesIn[];
        /**
         * Array of outgoing routes in the same format.
         */
        routesOuts: outputs.metal.GetDeviceBgpNeighborsBgpNeighborRoutesOut[];
    }

    export interface GetDeviceBgpNeighborsBgpNeighborRoutesIn {
        /**
         * (bool) Whether the route is exact.
         */
        exact: boolean;
        /**
         * CIDR expression of route (IP/mask).
         */
        route: string;
    }

    export interface GetDeviceBgpNeighborsBgpNeighborRoutesOut {
        /**
         * (bool) Whether the route is exact.
         */
        exact: boolean;
        /**
         * CIDR expression of route (IP/mask).
         */
        route: string;
    }

    export interface GetDeviceNetwork {
        /**
         * IPv4 or IPv6 address string.
         */
        address: string;
        /**
         * Bit length of the network mask of the address.
         */
        cidr: number;
        /**
         * IP version. One of `4`, `6`.
         */
        family: number;
        /**
         * Address of router.
         */
        gateway: string;
        /**
         * Whether the address is routable from the Internet.
         */
        public: boolean;
    }

    export interface GetDevicePort {
        /**
         * Whether this port is part of a bond in bonded network setup.
         */
        bonded: boolean;
        /**
         * ID of the port.
         */
        id: string;
        /**
         * MAC address assigned to the port.
         */
        mac: string;
        /**
         * Name of the port (e.g. `eth0`, or `bond0`).
         */
        name: string;
        /**
         * Type of the port (e.g. `NetworkPort` or `NetworkBondPort`).
         */
        type: string;
    }

    export interface GetDevicesDevice {
        accessPrivateIpv4: string;
        accessPublicIpv4: string;
        accessPublicIpv6: string;
        alwaysPxe: boolean;
        billingCycle: string;
        description: string;
        deviceId: string;
        /**
         * @deprecated Use metro instead of facility.  For more information, read the migration guide: https://registry.terraform.io/providers/equinix/equinix/latest/docs/guides/migration_guide_facilities_to_metros_devices
         */
        facility: string;
        hardwareReservationId: string;
        hostname: string;
        ipxeScriptUrl: string;
        metro: string;
        networkType: string;
        networks: outputs.metal.GetDevicesDeviceNetwork[];
        operatingSystem: string;
        plan: string;
        ports: outputs.metal.GetDevicesDevicePort[];
        /**
         * ID of project containing the devices. Exactly one of `projectId` and `organizationId` must be set.
         */
        projectId: string;
        rootPassword: string;
        sosHostname: string;
        sshKeyIds: string[];
        state: string;
        storage: string;
        tags: string[];
    }

    export interface GetDevicesDeviceNetwork {
        address: string;
        cidr: number;
        family: number;
        gateway: string;
        public: boolean;
    }

    export interface GetDevicesDevicePort {
        bonded: boolean;
        id: string;
        mac: string;
        name: string;
        type: string;
    }

    export interface GetDevicesFilter {
        /**
         * If is set to true, the values are joined with an AND, and the requests returns only the results that match all specified values. Default is `false`.
         *
         * All fields in the `devices` block defined below can be used as attribute for both `sort` and `filter` blocks.
         */
        all?: boolean;
        /**
         * The attribute used to filter. Filter attributes are case-sensitive
         */
        attribute: string;
        /**
         * The type of comparison to apply. One of: `in` , `re`, `substring`, `lessThan`, `lessThanOrEqual`, `greaterThan`, `greaterThanOrEqual`. Default is `in`.
         */
        matchBy?: string;
        /**
         * The filter values. Filter values are case-sensitive. If you specify multiple values for a filter, the values are joined with an OR by default, and the request returns all results that match any of the specified values
         */
        values: string[];
    }

    export interface GetDevicesSort {
        /**
         * The attribute used to filter. Filter attributes are case-sensitive
         */
        attribute: string;
        direction?: string;
    }

    export interface GetFacilityCapacity {
        /**
         * Device plan that must be available in selected location.
         */
        plan: string;
        /**
         * Minimun number of devices that must be available in selected location.
         * Default is `1`.
         */
        quantity?: number;
    }

    export interface GetInterconnectionPort {
        /**
         * Port UUID.
         */
        id: string;
        /**
         * Port link status.
         */
        linkStatus: string;
        /**
         * Port name.
         */
        name: string;
        /**
         * Port role - primary or secondary.
         */
        role: string;
        /**
         * Port speed in bits per second.
         */
        speed: number;
        /**
         * Port status.
         */
        status: string;
        /**
         * List of IDs of virtual cicruits attached to this port.
         */
        virtualCircuitIds: any[];
    }

    export interface GetInterconnectionServiceToken {
        /**
         * Expiration date of the service token.
         */
        expiresAt: string;
        /**
         * Port UUID.
         */
        id: string;
        /**
         * Maximum allowed speed for the service token, string like in the `speed` attribute.
         */
        maxAllowedSpeed: string;
        /**
         * Port role - primary or secondary.
         */
        role: string;
        state: string;
        /**
         * Token type, `aSide` or `zSide`.
         */
        type: string;
    }

    export interface GetMetroCapacity {
        /**
         * Device plan that must be available in selected location.
         */
        plan: string;
        /**
         * Minimum number of devices that must be available in selected location.
         * Default is `1`.
         */
        quantity?: number;
    }

    export interface GetOrganizationAddress {
        /**
         * Postal address.
         */
        address: string;
        /**
         * City name.
         */
        city: string;
        /**
         * Two letter country code (ISO 3166-1 alpha-2), e.g. US.
         */
        country: string;
        /**
         * State name.
         */
        state: string;
        /**
         * Zip Code.
         */
        zipCode: string;
    }

    export interface GetPlansFilter {
        /**
         * If is set to true, the values are joined with an AND, and the requests returns only the results that match all specified values. Default is `false`.
         *
         * All fields in the `plans` block defined below can be used as attribute for both `sort` and `filter` blocks.
         */
        all?: boolean;
        /**
         * The attribute used to filter. Filter attributes are case-sensitive
         */
        attribute: string;
        /**
         * The type of comparison to apply. One of: `in` , `re`, `substring`, `lessThan`, `lessThanOrEqual`, `greaterThan`, `greaterThanOrEqual`. Default is `in`.
         */
        matchBy?: string;
        /**
         * The filter values. Filter values are case-sensitive. If you specify multiple values for a filter, the values are joined with an OR by default, and the request returns all results that match any of the specified values
         */
        values: string[];
    }

    export interface GetPlansPlan {
        /**
         * list of metros where the plan is available
         */
        availableInMetros: string[];
        /**
         * (**Deprecated**) list of facilities where the plan is available
         *
         * @deprecated Use available_in_metros instead.  For more information, read the migration guide: https://registry.terraform.io/providers/equinix/equinix/latest/docs/guides/migration_guide_facilities_to_metros_devices
         */
        availableIns: string[];
        /**
         * plan class
         */
        class: string;
        /**
         * list of deployment types, e.g. on_demand, spot_market
         */
        deploymentTypes: string[];
        /**
         * description of the plan
         */
        description: string;
        /**
         * id of the plan
         */
        id: string;
        /**
         * flag showing if it's a legacy plan
         */
        legacy: boolean;
        /**
         * plan line, e.g. baremetal
         */
        line: string;
        /**
         * name of the plan
         */
        name: string;
        /**
         * plan hourly price
         */
        pricingHour: number;
        /**
         * plan monthly price
         */
        pricingMonth: number;
        /**
         * plan slug
         */
        slug: string;
    }

    export interface GetPlansSort {
        /**
         * The attribute used to filter. Filter attributes are case-sensitive
         */
        attribute: string;
        /**
         * Sort results in ascending or descending order. Strings are sorted in alphabetical order. One of: asc, desc
         */
        direction?: string;
    }

    export interface GetProjectBgpConfig {
        /**
         * Autonomous System Number for local BGP deployment.
         */
        asn: number;
        /**
         * One of `private`, `public`.
         */
        deploymentType: string;
        /**
         * The maximum number of route filters allowed per server.
         */
        maxPrefix: number;
        /**
         * Password for BGP session in plaintext (not a checksum).
         */
        md5?: string;
        /**
         * Status of BGP configuration in the project.
         */
        status: string;
    }

    export interface InterconnectionPort {
        id: string;
        linkStatus: string;
        /**
         * Name of the connection resource
         */
        name: string;
        role: string;
        /**
         * Connection speed - one of 50Mbps, 200Mbps, 500Mbps, 1Gbps, 2Gbps, 5Gbps, 10Gbps.
         */
        speed: number;
        /**
         * Status of the connection resource.
         */
        status: string;
        virtualCircuitIds: any[];
    }

    export interface InterconnectionServiceToken {
        expiresAt: string;
        id: string;
        maxAllowedSpeed: string;
        role: string;
        state: string;
        /**
         * Connection type - dedicated or shared.
         */
        type: string;
    }

    export interface OrganizationAddress {
        /**
         * Postal address.
         */
        address: string;
        /**
         * City name.
         */
        city: string;
        /**
         * Two letter country code (ISO 3166-1 alpha-2), e.g. US.
         */
        country: string;
        /**
         * State name.
         */
        state?: string;
        /**
         * Zip Code.
         */
        zipCode: string;
    }

    export interface ProjectBgpConfig {
        /**
         * Autonomous System Number for local BGP deployment.
         */
        asn: number;
        /**
         * `local` or `global`, the `local` is likely to be usable immediately, the
         * `global` will need to be reviewed by Equinix Metal engineers.
         */
        deploymentType: string;
        /**
         * The maximum number of route filters allowed per server.
         */
        maxPrefix: number;
        /**
         * Password for BGP session in plaintext (not a checksum).
         */
        md5?: string;
        /**
         * status of BGP configuration in the project.
         */
        status: string;
    }

    export interface SpotMarketRequestInstanceParameters {
        alwaysPxe?: boolean;
        billingCycle: string;
        customdata?: string;
        description?: string;
        features?: string[];
        hostname: string;
        ipxeScriptUrl?: string;
        /**
         * Blocks deletion of the SpotMarketRequest device until the lock is disabled.
         */
        locked?: boolean;
        operatingSystem: string;
        plan: string;
        projectSshKeys?: string[];
        tags?: string[];
        terminationTime: string;
        /**
         * @deprecated Use instance_parameters.termination_time instead
         */
        termintationTime: string;
        userSshKeys?: string[];
        userdata?: string;
    }

}

export namespace networkedge {
    export interface AclTemplateDeviceDetail {
        /**
         * Device ACL provisioning status where template was applied. One of `PROVISIONING`,
         * `PROVISIONED`.
         */
        aclStatus: string;
        /**
         * ACL template name.
         */
        name: string;
        /**
         * Device uuid.
         */
        uuid: string;
    }

    export interface AclTemplateInboundRule {
        /**
         * Inbound rule description, up to 200 characters.
         */
        description?: string;
        /**
         * Inbound traffic destination ports. Allowed values are a comma separated
         * list of ports, e.g., `20,22,23`, port range, e.g., `1023-1040` or word `any`.
         */
        dstPort: string;
        /**
         * Inbound traffic protocol. One of `IP`, `TCP`, `UDP`.
         */
        protocol: string;
        sequenceNumber: number;
        /**
         * @deprecated Source Type will not be returned
         */
        sourceType: string;
        /**
         * Inbound traffic source ports. Allowed values are a comma separated list
         * of ports, e.g., `20,22,23`, port range, e.g., `1023-1040` or word `any`.
         */
        srcPort: string;
        /**
         * Inbound traffic source IP subnet in CIDR format.
         */
        subnet?: string;
        /**
         * Inbound traffic source IP subnets in CIDR format.
         *
         * @deprecated Use Subnet instead
         */
        subnets?: string[];
    }

    export interface DeviceClusterDetails {
        /**
         * The ID of the cluster.
         */
        clusterId: string;
        /**
         * The name of the cluster device
         */
        clusterName: string;
        /**
         * An object that has `node0` configuration.
         * See Cluster Details - Nodes below for more details.
         */
        node0: outputs.networkedge.DeviceClusterDetailsNode0;
        /**
         * An object that has `node1` configuration.
         * See Cluster Details - Nodes below for more details.
         */
        node1: outputs.networkedge.DeviceClusterDetailsNode1;
        /**
         * The number of nodes in the cluster.
         */
        numOfNodes: number;
    }

    export interface DeviceClusterDetailsNode0 {
        /**
         * Identifier of a license file that will be applied on the device.
         */
        licenseFileId?: string;
        /**
         * License Token applicable for some device types in BYOL licensing
         * mode.
         */
        licenseToken?: string;
        /**
         * Device name.
         */
        name: string;
        /**
         * Device unique identifier.
         */
        uuid: string;
        /**
         * Map of vendor specific configuration parameters for a device
         * (controller1, activationKey, managementType, siteId, systemIpAddress)
         * * `ssh-key` - (Optional) Definition of SSH key that will be provisioned
         * on a device (max one key).  See SSH Key below for more details.
         */
        vendorConfiguration?: outputs.networkedge.DeviceClusterDetailsNode0VendorConfiguration;
    }

    export interface DeviceClusterDetailsNode0VendorConfiguration {
        /**
         * Activation key. This is required for Velocloud clusters.
         */
        activationKey?: string;
        /**
         * The administrative password of the device. You can use it to log in
         * to the console. This field is not available for all device types.
         */
        adminPassword: string;
        /**
         * System IP Address. Mandatory for the Fortinet SDWAN cluster device.
         */
        controller1?: string;
        /**
         * Controller fqdn. This is required for Velocloud clusters.
         */
        controllerFqdn?: string;
        /**
         * Hostname. This is necessary for Palo Alto, Juniper, and Fortinet clusters.
         */
        hostname?: string;
        /**
         * The CLI password of the device. This field is relevant only for the
         * Velocloud SDWAN cluster.
         */
        rootPassword?: string;
    }

    export interface DeviceClusterDetailsNode1 {
        /**
         * Identifier of a license file that will be applied on the device.
         */
        licenseFileId?: string;
        /**
         * License Token applicable for some device types in BYOL licensing
         * mode.
         */
        licenseToken?: string;
        /**
         * Device name.
         */
        name: string;
        /**
         * Device unique identifier.
         */
        uuid: string;
        /**
         * Map of vendor specific configuration parameters for a device
         * (controller1, activationKey, managementType, siteId, systemIpAddress)
         * * `ssh-key` - (Optional) Definition of SSH key that will be provisioned
         * on a device (max one key).  See SSH Key below for more details.
         */
        vendorConfiguration?: outputs.networkedge.DeviceClusterDetailsNode1VendorConfiguration;
    }

    export interface DeviceClusterDetailsNode1VendorConfiguration {
        /**
         * Activation key. This is required for Velocloud clusters.
         */
        activationKey?: string;
        /**
         * The administrative password of the device. You can use it to log in
         * to the console. This field is not available for all device types.
         */
        adminPassword: string;
        /**
         * System IP Address. Mandatory for the Fortinet SDWAN cluster device.
         */
        controller1?: string;
        /**
         * Controller fqdn. This is required for Velocloud clusters.
         */
        controllerFqdn?: string;
        /**
         * Hostname. This is necessary for Palo Alto, Juniper, and Fortinet clusters.
         */
        hostname?: string;
        /**
         * The CLI password of the device. This field is relevant only for the
         * Velocloud SDWAN cluster.
         */
        rootPassword?: string;
    }

    export interface DeviceInterface {
        /**
         * interface management type (Equinix Managed or empty).
         */
        assignedType: string;
        /**
         * interface identifier.
         */
        id: number;
        /**
         * interface IP address.
         */
        ipAddress: string;
        /**
         * interface MAC address.
         */
        macAddress: string;
        /**
         * Device name.
         */
        name: string;
        /**
         * interface operational status. One of `up`, `down`.
         */
        operationalStatus: string;
        /**
         * interface status. One of `AVAILABLE`, `RESERVED`, `ASSIGNED`.
         */
        status: string;
        /**
         * interface type.
         */
        type: string;
    }

    export interface DeviceLinkDevice {
        /**
         * Device ASN number. Not required for self configured devices.
         */
        asn?: number;
        /**
         * Device identifier.
         */
        id: string;
        /**
         * Device network interface identifier to use for device link
         * connection.
         */
        interfaceId?: number;
        /**
         * IP address from device link subnet that was assigned to the device
         */
        ipAddress: string;
        /**
         * device link provisioning status on a given device. One of `PROVISIONING`,
         * `PROVISIONED`, `DEPROVISIONING`, `DEPROVISIONED`, `FAILED`.
         */
        status: string;
    }

    export interface DeviceLinkLink {
        /**
         * billing account number to be used for
         * connection charges
         */
        accountNumber: string;
        /**
         * connection destination metro code.
         */
        dstMetroCode: string;
        /**
         * connection destination zone code is not required.
         *
         * @deprecated DestinationZoneCode is not required
         */
        dstZoneCode?: string;
        /**
         * connection source metro code.
         */
        srcMetroCode: string;
        /**
         * connection source zone code is not required.
         *
         * @deprecated SourceZoneCode is not required
         */
        srcZoneCode?: string;
        /**
         * connection throughput.
         */
        throughput: string;
        /**
         * connection throughput unit (Mbps or Gbps).
         */
        throughputUnit: string;
    }

    export interface DeviceSecondaryDevice {
        /**
         * Billing account number for secondary device.
         */
        accountNumber: string;
        /**
         * Identifier of a WAN interface ACL template that will be applied
         * on a secondary device.
         */
        aclTemplateId?: string;
        /**
         * Additional Internet bandwidth, in Mbps, for a secondary
         * device.
         */
        additionalBandwidth: number;
        /**
         * (Autonomous System Number) Unique identifier for a network on the internet.
         */
        asn: number;
        /**
         * Identifier of a cloud init file that will be applied on a secondary device.
         */
        cloudInitFileId?: string;
        /**
         * Secondary device hostname.
         */
        hostname?: string;
        /**
         * Device location Equinix Business Exchange name.
         */
        ibx: string;
        /**
         * List of device interfaces. See Interface Attribute below
         * for more details.
         */
        interfaces: outputs.networkedge.DeviceSecondaryDeviceInterface[];
        /**
         * Path to the license file that will be uploaded and applied on a
         * secondary device. Applicable for some device types in BYOL licensing mode.
         */
        licenseFile?: string;
        /**
         * Identifier of a license file that will be applied on a secondary device.
         */
        licenseFileId: string;
        /**
         * Device license registration status. Possible values are `APPLYING_LICENSE`,
         * `REGISTERED`, `APPLIED`, `WAITING_FOR_CLUSTER_SETUP`, `REGISTRATION_FAILED`.
         */
        licenseStatus: string;
        /**
         * License Token can be provided for some device types o the device.
         */
        licenseToken?: string;
        /**
         * Metro location of a secondary device.
         */
        metroCode: string;
        /**
         * Identifier of an MGMT interface ACL template that will be
         * applied on a secondary device.
         * * `ssh-key` - (Optional) Up to one definition of SSH key that will be provisioned on a secondary
         * device.
         */
        mgmtAclTemplateUuid?: string;
        /**
         * Secondary device name.
         */
        name: string;
        /**
         * List of email addresses that will receive notifications about
         * secondary device.
         */
        notifications: string[];
        /**
         * Device redundancy type applicable for HA devices, either
         * primary or secondary.
         */
        redundancyType: string;
        /**
         * Unique identifier for a redundant device applicable for HA devices.
         */
        redundantId: string;
        /**
         * Device location region.
         */
        region: string;
        /**
         * IP address of SSH enabled interface on the device.
         */
        sshIpAddress: string;
        /**
         * FQDN of SSH enabled interface on the device.
         */
        sshIpFqdn: string;
        sshKey?: outputs.networkedge.DeviceSecondaryDeviceSshKey;
        /**
         * interface status. One of `AVAILABLE`, `RESERVED`, `ASSIGNED`.
         */
        status: string;
        /**
         * Device unique identifier.
         */
        uuid: string;
        /**
         * Key/Value pairs of vendor specific configuration parameters
         * for a secondary device. Key values are `controller1`, `activationKey`, `managementType`, `siteId`,
         * `systemIpAddress`.
         */
        vendorConfiguration: {[key: string]: string};
        wanInterfaceId?: string;
        /**
         * Device location zone code.
         */
        zoneCode: string;
    }

    export interface DeviceSecondaryDeviceInterface {
        /**
         * interface management type (Equinix Managed or empty).
         */
        assignedType: string;
        /**
         * interface identifier.
         */
        id: number;
        /**
         * interface IP address.
         */
        ipAddress: string;
        /**
         * interface MAC address.
         */
        macAddress: string;
        /**
         * Device name.
         */
        name: string;
        /**
         * interface operational status. One of `up`, `down`.
         */
        operationalStatus: string;
        /**
         * interface status. One of `AVAILABLE`, `RESERVED`, `ASSIGNED`.
         */
        status: string;
        /**
         * interface type.
         */
        type: string;
    }

    export interface DeviceSecondaryDeviceSshKey {
        keyName: string;
        /**
         * username associated with given key.
         */
        username: string;
    }

    export interface DeviceSshKey {
        keyName: string;
        /**
         * username associated with given key.
         */
        username: string;
    }

    export interface GetDeviceClusterDetail {
        /**
         * The id of the cluster
         */
        clusterId: string;
        clusterName: string;
        node0s: outputs.networkedge.GetDeviceClusterDetailNode0[];
        node1s: outputs.networkedge.GetDeviceClusterDetailNode1[];
        /**
         * The number of nodes in the cluster
         */
        numOfNodes: number;
    }

    export interface GetDeviceClusterDetailNode0 {
        /**
         * Unique identifier of applied license file
         */
        licenseFileId: string;
        licenseToken: string;
        /**
         * Name of an existing Equinix Network Edge device
         */
        name: string;
        /**
         * UUID of an existing Equinix Network Edge device
         */
        uuid: string;
        vendorConfigurations: outputs.networkedge.GetDeviceClusterDetailNode0VendorConfiguration[];
    }

    export interface GetDeviceClusterDetailNode0VendorConfiguration {
        activationKey: string;
        adminPassword: string;
        controller1: string;
        controllerFqdn: string;
        hostname: string;
        rootPassword: string;
    }

    export interface GetDeviceClusterDetailNode1 {
        /**
         * Unique identifier of applied license file
         */
        licenseFileId: string;
        licenseToken: string;
        /**
         * Name of an existing Equinix Network Edge device
         */
        name: string;
        /**
         * UUID of an existing Equinix Network Edge device
         */
        uuid: string;
        vendorConfigurations: outputs.networkedge.GetDeviceClusterDetailNode1VendorConfiguration[];
    }

    export interface GetDeviceClusterDetailNode1VendorConfiguration {
        activationKey: string;
        adminPassword: string;
        controller1: string;
        controllerFqdn: string;
        hostname: string;
        rootPassword: string;
    }

    export interface GetDeviceInterface {
        assignedType: string;
        id: number;
        ipAddress: string;
        macAddress: string;
        /**
         * Name of an existing Equinix Network Edge device
         */
        name: string;
        operationalStatus: string;
        /**
         * Device provisioning status
         * * INITIALIZING
         * * PROVISIONING
         * * PROVISIONED  (**NOTE: By default data source will only return devices in this state.  To include other states see `validStateList`**)
         * * WAITING_FOR_PRIMARY
         * * WAITING_FOR_SECONDARY
         * * WAITING_FOR_REPLICA_CLUSTER_NODES
         * * CLUSTER_SETUP_IN_PROGRESS
         * * FAILED
         * * DEPROVISIONING
         * * DEPROVISIONED
         */
        status: string;
        type: string;
    }

    export interface GetDeviceSecondaryDevice {
        accountNumber: string;
        /**
         * Unique identifier of applied ACL template
         */
        aclTemplateId: string;
        additionalBandwidth: number;
        /**
         * Autonomous system number
         */
        asn: number;
        cloudInitFileId: string;
        hostname: string;
        /**
         * Device location Equinix Business Exchange name
         */
        ibx: string;
        /**
         * List of device interfaces
         * * `interface.#.id` - interface identifier
         * * `interface.#.name` - interface name
         * * `interface.#.status` -  interface status (AVAILABLE, RESERVED, ASSIGNED)
         * * `interface.#.operational_status` - interface operational status (up or down)
         * * `interface.#.mac_address` - interface MAC address
         * * `interface.#.ip_address` - interface IP address
         * * `interface.#.assigned_type` - interface management type (Equinix Managed or empty)
         * * `interface.#.type` - interface type
         */
        interfaces: outputs.networkedge.GetDeviceSecondaryDeviceInterface[];
        licenseFile: string;
        /**
         * Unique identifier of applied license file
         */
        licenseFileId: string;
        /**
         * Device license registration status
         * * APPLYING_LICENSE
         * * REGISTERED
         * * APPLIED
         * * WAITING_FOR_CLUSTER_SETUP
         * * REGISTRATION_FAILED
         * * NA
         */
        licenseStatus: string;
        licenseToken: string;
        metroCode: string;
        mgmtAclTemplateUuid: string;
        /**
         * Name of an existing Equinix Network Edge device
         */
        name: string;
        notifications: string[];
        /**
         * Device redundancy type applicable for HA devices, either
         * primary or secondary
         */
        redundancyType: string;
        /**
         * Unique identifier for a redundant device applicable for HA devices
         */
        redundantId: string;
        /**
         * Device location region
         */
        region: string;
        /**
         * IP address of SSH enabled interface on the device
         */
        sshIpAddress: string;
        /**
         * FQDN of SSH enabled interface on the device
         */
        sshIpFqdn: string;
        sshKeys: outputs.networkedge.GetDeviceSecondaryDeviceSshKey[];
        /**
         * Device provisioning status
         * * INITIALIZING
         * * PROVISIONING
         * * PROVISIONED  (**NOTE: By default data source will only return devices in this state.  To include other states see `validStateList`**)
         * * WAITING_FOR_PRIMARY
         * * WAITING_FOR_SECONDARY
         * * WAITING_FOR_REPLICA_CLUSTER_NODES
         * * CLUSTER_SETUP_IN_PROGRESS
         * * FAILED
         * * DEPROVISIONING
         * * DEPROVISIONED
         */
        status: string;
        /**
         * UUID of an existing Equinix Network Edge device
         */
        uuid: string;
        vendorConfiguration: {[key: string]: string};
        wanInterfaceId: string;
        /**
         * Device location zone code
         */
        zoneCode: string;
    }

    export interface GetDeviceSecondaryDeviceInterface {
        assignedType: string;
        id: number;
        ipAddress: string;
        macAddress: string;
        /**
         * Name of an existing Equinix Network Edge device
         */
        name: string;
        operationalStatus: string;
        /**
         * Device provisioning status
         * * INITIALIZING
         * * PROVISIONING
         * * PROVISIONED  (**NOTE: By default data source will only return devices in this state.  To include other states see `validStateList`**)
         * * WAITING_FOR_PRIMARY
         * * WAITING_FOR_SECONDARY
         * * WAITING_FOR_REPLICA_CLUSTER_NODES
         * * CLUSTER_SETUP_IN_PROGRESS
         * * FAILED
         * * DEPROVISIONING
         * * DEPROVISIONED
         */
        status: string;
        type: string;
    }

    export interface GetDeviceSecondaryDeviceSshKey {
        keyName: string;
        username: string;
    }

    export interface GetDeviceSshKey {
        keyName: string;
        username: string;
    }

}
