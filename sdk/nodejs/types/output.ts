// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";
import * as enums from "../types/enums";

export namespace fabric {
    export interface ConnectionASide {
        /**
         * Point of access details
         */
        accessPoints?: outputs.fabric.ConnectionASideAccessPoint[];
        /**
         * Connection side additional information
         */
        additionalInfos?: outputs.fabric.ConnectionASideAdditionalInfo[];
        /**
         * For service token based connections, Service tokens authorize users to access protected resources and services. Resource owners can distribute the tokens to trusted partners and vendors, allowing selected third parties to work directly with Equinix network assets
         */
        serviceTokens?: outputs.fabric.ConnectionASideServiceToken[];
    }

    export interface ConnectionASideAccessPoint {
        /**
         * Customer account information that is associated with this connection
         */
        accounts: outputs.fabric.ConnectionASideAccessPointAccount[];
        authenticationKey?: string;
        gateways?: outputs.fabric.ConnectionASideAccessPointGateway[];
        interfaces?: outputs.fabric.ConnectionASideAccessPointInterface[];
        linkProtocols?: any;
        locations: outputs.fabric.ConnectionASideAccessPointLocation[];
        peeringType?: string;
        ports?: outputs.fabric.ConnectionASideAccessPointPort[];
        profiles?: any;
        providerConnectionId?: string;
        routingProtocols?: outputs.fabric.ConnectionASideAccessPointRoutingProtocol[];
        sellerRegion?: string;
        /**
         * Defines the connection type like VG*VC, EVPL*VC, EPL*VC, EC*VC, GW*VC, ACCESS*EPL_VC
         */
        type?: string;
        virtualDevices?: outputs.fabric.ConnectionASideAccessPointVirtualDevice[];
    }

    export interface ConnectionASideAccessPointAccount {
        accountName: string;
        accountNumber: number;
        globalCustId: string;
        globalOrgId: string;
        globalOrganizationName: string;
        orgId: number;
        organizationName: string;
    }

    export interface ConnectionASideAccessPointGateway {
        /**
         * Connection URI information
         */
        href: string;
        uuid?: string;
    }

    export interface ConnectionASideAccessPointInterface {
        /**
         * The ID of this resource.
         */
        id: string;
        /**
         * Defines the connection type like VG*VC, EVPL*VC, EPL*VC, EC*VC, GW*VC, ACCESS*EPL_VC
         */
        type?: string;
        uuid?: string;
    }

    export interface ConnectionASideAccessPointLocation {
        ibx: string;
        metroCode: string;
        metroName: string;
        region: string;
    }

    export interface ConnectionASideAccessPointPort {
        /**
         * Connection URI information
         */
        href: string;
        /**
         * Connection name. An alpha-numeric 24 characters string which can include only hyphens and underscores
         */
        name: string;
        /**
         * Redundancy Information
         */
        redundancies: outputs.fabric.ConnectionASideAccessPointPortRedundancy[];
        uuid: string;
    }

    export interface ConnectionASideAccessPointPortRedundancy {
        /**
         * Priority type- PRIMARY, SECONDARY
         */
        priority: string;
    }

    export interface ConnectionASideAccessPointRoutingProtocol {
        /**
         * Connection overall state
         */
        state?: string;
        /**
         * Defines the connection type like VG*VC, EVPL*VC, EPL*VC, EC*VC, GW*VC, ACCESS*EPL_VC
         */
        type?: string;
        uuid?: string;
    }

    export interface ConnectionASideAccessPointVirtualDevice {
        /**
         * Connection URI information
         */
        href: string;
        /**
         * Defines the connection type like VG*VC, EVPL*VC, EPL*VC, EC*VC, GW*VC, ACCESS*EPL_VC
         */
        type?: string;
        uuid?: string;
    }

    export interface ConnectionASideAdditionalInfo {
        /**
         * Additional information key
         */
        key?: string;
        /**
         * Additional information value
         */
        value?: string;
    }

    export interface ConnectionASideServiceToken {
        description: string;
        /**
         * Connection URI information
         */
        href: string;
        /**
         * Defines the connection type like VG*VC, EVPL*VC, EPL*VC, EC*VC, GW*VC, ACCESS*EPL_VC
         */
        type?: string;
        uuid?: string;
    }

    export interface ConnectionAccount {
        accountName: string;
        accountNumber: number;
        globalCustId: string;
        globalOrgId: string;
        globalOrganizationName: string;
        orgId: number;
        organizationName: string;
    }

    export interface ConnectionAdditionalInfo {
        /**
         * Additional information key
         */
        key?: string;
        /**
         * Additional information value
         */
        value?: string;
    }

    export interface ConnectionChangeLog {
        createdBy: string;
        createdByEmail: string;
        createdByFullName: string;
        createdDateTime: string;
        deletedBy: string;
        deletedByEmail: string;
        deletedByFullName: string;
        deletedDateTime: string;
        updatedBy: string;
        updatedByEmail: string;
        updatedByFullName: string;
        updatedDateTime: string;
    }

    export interface ConnectionNotification {
        /**
         * Array of contact emails
         */
        emails: string[];
        /**
         * Send interval
         */
        sendInterval?: string;
        /**
         * Notification Type - ALL,CONNECTION*APPROVAL,SALES*REP_NOTIFICATIONS, NOTIFICATIONS
         */
        type: string;
    }

    export interface ConnectionOperation {
        equinixStatus: string;
        errors: outputs.fabric.ConnectionOperationError[];
        providerStatus: string;
    }

    export interface ConnectionOperationError {
        /**
         * Connection additional information
         */
        additionalInfos: outputs.fabric.ConnectionOperationErrorAdditionalInfo[];
        correlationId: string;
        details: string;
        errorCode: string;
        errorMessage: string;
        help: string;
    }

    export interface ConnectionOperationErrorAdditionalInfo {
        property: string;
        reason: string;
    }

    export interface ConnectionOrder {
        /**
         * Billing tier for connection bandwidth
         */
        billingTier?: string;
        /**
         * Order Identification
         */
        orderId: string;
        /**
         * Order Reference Number
         */
        orderNumber: string;
        /**
         * Purchase order number
         */
        purchaseOrderNumber?: string;
    }

    export interface ConnectionProject {
        /**
         * Unique Resource URL
         */
        href: string;
        /**
         * Project Id
         */
        projectId: string;
    }

    export interface ConnectionRedundancy {
        /**
         * Redundancy group identifier
         */
        group: string;
        /**
         * Priority type- PRIMARY, SECONDARY
         */
        priority?: string;
    }

    export interface ConnectionZSide {
        /**
         * Point of access details
         */
        accessPoints?: outputs.fabric.ConnectionZSideAccessPoint[];
        /**
         * Connection side additional information
         */
        additionalInfos?: outputs.fabric.ConnectionZSideAdditionalInfo[];
        /**
         * For service token based connections, Service tokens authorize users to access protected resources and services. Resource owners can distribute the tokens to trusted partners and vendors, allowing selected third parties to work directly with Equinix network assets
         */
        serviceTokens?: outputs.fabric.ConnectionZSideServiceToken[];
    }

    export interface ConnectionZSideAccessPoint {
        /**
         * Customer account information that is associated with this connection
         */
        accounts: outputs.fabric.ConnectionZSideAccessPointAccount[];
        authenticationKey?: string;
        gateways?: outputs.fabric.ConnectionZSideAccessPointGateway[];
        interfaces?: outputs.fabric.ConnectionZSideAccessPointInterface[];
        linkProtocols?: any;
        locations: outputs.fabric.ConnectionZSideAccessPointLocation[];
        peeringType?: string;
        ports?: outputs.fabric.ConnectionZSideAccessPointPort[];
        profiles?: any;
        providerConnectionId?: string;
        routingProtocols?: outputs.fabric.ConnectionZSideAccessPointRoutingProtocol[];
        sellerRegion?: string;
        /**
         * Defines the connection type like VG*VC, EVPL*VC, EPL*VC, EC*VC, GW*VC, ACCESS*EPL_VC
         */
        type?: string;
        virtualDevices?: outputs.fabric.ConnectionZSideAccessPointVirtualDevice[];
    }

    export interface ConnectionZSideAccessPointAccount {
        accountName: string;
        accountNumber: number;
        globalCustId: string;
        globalOrgId: string;
        globalOrganizationName: string;
        orgId: number;
        organizationName: string;
    }

    export interface ConnectionZSideAccessPointGateway {
        /**
         * Connection URI information
         */
        href: string;
        uuid?: string;
    }

    export interface ConnectionZSideAccessPointInterface {
        /**
         * The ID of this resource.
         */
        id: string;
        /**
         * Defines the connection type like VG*VC, EVPL*VC, EPL*VC, EC*VC, GW*VC, ACCESS*EPL_VC
         */
        type?: string;
        uuid?: string;
    }

    export interface ConnectionZSideAccessPointLocation {
        ibx: string;
        metroCode: string;
        metroName: string;
        region: string;
    }

    export interface ConnectionZSideAccessPointPort {
        /**
         * Connection URI information
         */
        href: string;
        /**
         * Connection name. An alpha-numeric 24 characters string which can include only hyphens and underscores
         */
        name: string;
        /**
         * Redundancy Information
         */
        redundancies: outputs.fabric.ConnectionZSideAccessPointPortRedundancy[];
        uuid: string;
    }

    export interface ConnectionZSideAccessPointPortRedundancy {
        /**
         * Priority type- PRIMARY, SECONDARY
         */
        priority: string;
    }

    export interface ConnectionZSideAccessPointRoutingProtocol {
        /**
         * Connection overall state
         */
        state?: string;
        /**
         * Defines the connection type like VG*VC, EVPL*VC, EPL*VC, EC*VC, GW*VC, ACCESS*EPL_VC
         */
        type?: string;
        uuid?: string;
    }

    export interface ConnectionZSideAccessPointVirtualDevice {
        /**
         * Connection URI information
         */
        href: string;
        /**
         * Defines the connection type like VG*VC, EVPL*VC, EPL*VC, EC*VC, GW*VC, ACCESS*EPL_VC
         */
        type?: string;
        uuid?: string;
    }

    export interface ConnectionZSideAdditionalInfo {
        /**
         * Additional information key
         */
        key?: string;
        /**
         * Additional information value
         */
        value?: string;
    }

    export interface ConnectionZSideServiceToken {
        description: string;
        /**
         * Connection URI information
         */
        href: string;
        /**
         * Defines the connection type like VG*VC, EVPL*VC, EPL*VC, EC*VC, GW*VC, ACCESS*EPL_VC
         */
        type?: string;
        uuid?: string;
    }

    export interface GetConnectionASide {
        accessPoints: outputs.fabric.GetConnectionASideAccessPoint[];
        serviceTokens: outputs.fabric.GetConnectionASideServiceToken[];
    }

    export interface GetConnectionASideAccessPoint {
        /**
         * Customer account information that is associated with this connection
         */
        accounts: outputs.fabric.GetConnectionASideAccessPointAccount[];
        authenticationKey: string;
        gateways: outputs.fabric.GetConnectionASideAccessPointGateway[];
        interfaces: outputs.fabric.GetConnectionASideAccessPointInterface[];
        linkProtocols: outputs.fabric.GetConnectionASideAccessPointLinkProtocol[];
        locations: outputs.fabric.GetConnectionASideAccessPointLocation[];
        peeringType: string;
        ports: outputs.fabric.GetConnectionASideAccessPointPort[];
        profiles: outputs.fabric.GetConnectionASideAccessPointProfile[];
        providerConnectionId: string;
        sellerRegion: string;
        /**
         * Defines the connection type like VG*VC, EVPL*VC, EPL*VC, EC*VC, GW*VC, ACCESS*EPL_VC
         */
        type: string;
        virtualDevices: outputs.fabric.GetConnectionASideAccessPointVirtualDevice[];
    }

    export interface GetConnectionASideAccessPointAccount {
        accountName: string;
        accountNumber: number;
        globalCustId: string;
        globalOrgId: string;
        globalOrganizationName: string;
        orgId: number;
        organizationName: string;
    }

    export interface GetConnectionASideAccessPointGateway {
        /**
         * Connection URI information
         */
        href: string;
        /**
         * Connection overall state
         */
        state: string;
        /**
         * Equinix-assigned connection identifier
         */
        uuid: string;
    }

    export interface GetConnectionASideAccessPointInterface {
        /**
         * The ID of this resource.
         */
        id: string;
        /**
         * Defines the connection type like VG*VC, EVPL*VC, EPL*VC, EC*VC, GW*VC, ACCESS*EPL_VC
         */
        type: string;
        /**
         * Equinix-assigned connection identifier
         */
        uuid: string;
    }

    export interface GetConnectionASideAccessPointLinkProtocol {
        /**
         * Defines the connection type like VG*VC, EVPL*VC, EPL*VC, EC*VC, GW*VC, ACCESS*EPL_VC
         */
        type: string;
        vlanCTag: number;
        vlanSTag: number;
        vlanTag: number;
    }

    export interface GetConnectionASideAccessPointLocation {
        /**
         * Connection URI information
         */
        href: string;
        ibx: string;
        metroCode: string;
        metroName: string;
        region: string;
    }

    export interface GetConnectionASideAccessPointPort {
        /**
         * Connection URI information
         */
        href: string;
        /**
         * Connection name. An alpha-numeric 24 characters string which can include only hyphens and underscores
         */
        name: string;
        /**
         * Redundancy Information
         */
        redundancies: outputs.fabric.GetConnectionASideAccessPointPortRedundancy[];
        /**
         * Equinix-assigned connection identifier
         */
        uuid: string;
    }

    export interface GetConnectionASideAccessPointPortRedundancy {
        priority: string;
    }

    export interface GetConnectionASideAccessPointProfile {
        accessPointTypeConfigs: outputs.fabric.GetConnectionASideAccessPointProfileAccessPointTypeConfig[];
        /**
         * Customer-provided connection description
         */
        description: string;
        /**
         * Connection URI information
         */
        href: string;
        /**
         * Connection name. An alpha-numeric 24 characters string which can include only hyphens and underscores
         */
        name: string;
        /**
         * Defines the connection type like VG*VC, EVPL*VC, EPL*VC, EC*VC, GW*VC, ACCESS*EPL_VC
         */
        type: string;
        /**
         * Equinix-assigned connection identifier
         */
        uuid: string;
    }

    export interface GetConnectionASideAccessPointProfileAccessPointTypeConfig {
        allowBandwidthAutoApproval: boolean;
        allowBandwidthUpgrade: boolean;
        allowCustomBandwidth: boolean;
        allowRemoteConnections: boolean;
        apiConfigs: outputs.fabric.GetConnectionASideAccessPointProfileAccessPointTypeConfigApiConfig[];
        authenticationKeys: outputs.fabric.GetConnectionASideAccessPointProfileAccessPointTypeConfigAuthenticationKey[];
        bandwidthAlertThreshold: number;
        connectionLabel: string;
        connectionRedundancyRequired: boolean;
        enableAutoGenerateServiceKey: boolean;
        linkProtocolConfigs: outputs.fabric.GetConnectionASideAccessPointProfileAccessPointTypeConfigLinkProtocolConfig[];
        supportedBandwidths: number[];
        /**
         * Defines the connection type like VG*VC, EVPL*VC, EPL*VC, EC*VC, GW*VC, ACCESS*EPL_VC
         */
        type: string;
        /**
         * Equinix-assigned connection identifier
         */
        uuid: string;
    }

    export interface GetConnectionASideAccessPointProfileAccessPointTypeConfigApiConfig {
        allowOverSubscription: boolean;
        apiAvailable: boolean;
        bandwidthFromApi: boolean;
        equinixManagedPort: boolean;
        equinixManagedVlan: boolean;
        integrationId: string;
        overSubscriptionLimit: number;
    }

    export interface GetConnectionASideAccessPointProfileAccessPointTypeConfigAuthenticationKey {
        /**
         * Customer-provided connection description
         */
        description: string;
        label: string;
        required: boolean;
    }

    export interface GetConnectionASideAccessPointProfileAccessPointTypeConfigLinkProtocolConfig {
        encapsulation: string;
        encapsulationStrategy: string;
        reuseVlanSTag: boolean;
    }

    export interface GetConnectionASideAccessPointVirtualDevice {
        /**
         * Connection URI information
         */
        href: string;
        /**
         * Defines the connection type like VG*VC, EVPL*VC, EPL*VC, EC*VC, GW*VC, ACCESS*EPL_VC
         */
        type: string;
        /**
         * Equinix-assigned connection identifier
         */
        uuid: string;
    }

    export interface GetConnectionASideServiceToken {
        /**
         * Customer-provided connection description
         */
        description: string;
        /**
         * Connection URI information
         */
        href: string;
        /**
         * Defines the connection type like VG*VC, EVPL*VC, EPL*VC, EC*VC, GW*VC, ACCESS*EPL_VC
         */
        type: string;
        /**
         * Equinix-assigned connection identifier
         */
        uuid: string;
    }

    export interface GetConnectionAccount {
        accountName: string;
        accountNumber: number;
        globalCustId: string;
        globalOrgId: string;
        globalOrganizationName: string;
        orgId: number;
        organizationName: string;
    }

    export interface GetConnectionAdditionalInfo {
        key: string;
        value: string;
    }

    export interface GetConnectionChangeLog {
        createdBy: string;
        createdByEmail: string;
        createdByFullName: string;
        createdDateTime: string;
        deletedBy: string;
        deletedByEmail: string;
        deletedByFullName: string;
        deletedDateTime: string;
        updatedBy: string;
        updatedByEmail: string;
        updatedByFullName: string;
        updatedDateTime: string;
    }

    export interface GetConnectionNotification {
        emails: string[];
        sendInterval: string;
        /**
         * Defines the connection type like VG*VC, EVPL*VC, EPL*VC, EC*VC, GW*VC, ACCESS*EPL_VC
         */
        type: string;
    }

    export interface GetConnectionOperation {
        equinixStatus: string;
        errors: outputs.fabric.GetConnectionOperationError[];
        providerStatus: string;
    }

    export interface GetConnectionOperationError {
        /**
         * Connection additional information
         */
        additionalInfos: outputs.fabric.GetConnectionOperationErrorAdditionalInfo[];
        correlationId: string;
        details: string;
        errorCode: string;
        errorMessage: string;
        help: string;
    }

    export interface GetConnectionOperationErrorAdditionalInfo {
        property: string;
        reason: string;
    }

    export interface GetConnectionOrder {
        billingTier: string;
        orderId: string;
        orderNumber: string;
        purchaseOrderNumber: string;
    }

    export interface GetConnectionProject {
        /**
         * Unique Resource URL
         */
        href: string;
        /**
         * Project Id
         */
        projectId: string;
    }

    export interface GetConnectionRedundancy {
        group: string;
        priority: string;
    }

    export interface GetConnectionZSide {
        accessPoints: outputs.fabric.GetConnectionZSideAccessPoint[];
        serviceTokens: outputs.fabric.GetConnectionZSideServiceToken[];
    }

    export interface GetConnectionZSideAccessPoint {
        /**
         * Customer account information that is associated with this connection
         */
        accounts: outputs.fabric.GetConnectionZSideAccessPointAccount[];
        authenticationKey: string;
        gateways: outputs.fabric.GetConnectionZSideAccessPointGateway[];
        interfaces: outputs.fabric.GetConnectionZSideAccessPointInterface[];
        linkProtocols: outputs.fabric.GetConnectionZSideAccessPointLinkProtocol[];
        locations: outputs.fabric.GetConnectionZSideAccessPointLocation[];
        peeringType: string;
        ports: outputs.fabric.GetConnectionZSideAccessPointPort[];
        profiles: outputs.fabric.GetConnectionZSideAccessPointProfile[];
        providerConnectionId: string;
        sellerRegion: string;
        /**
         * Defines the connection type like VG*VC, EVPL*VC, EPL*VC, EC*VC, GW*VC, ACCESS*EPL_VC
         */
        type: string;
        virtualDevices: outputs.fabric.GetConnectionZSideAccessPointVirtualDevice[];
    }

    export interface GetConnectionZSideAccessPointAccount {
        accountName: string;
        accountNumber: number;
        globalCustId: string;
        globalOrgId: string;
        globalOrganizationName: string;
        orgId: number;
        organizationName: string;
    }

    export interface GetConnectionZSideAccessPointGateway {
        /**
         * Connection URI information
         */
        href: string;
        /**
         * Connection overall state
         */
        state: string;
        /**
         * Equinix-assigned connection identifier
         */
        uuid: string;
    }

    export interface GetConnectionZSideAccessPointInterface {
        /**
         * The ID of this resource.
         */
        id: string;
        /**
         * Defines the connection type like VG*VC, EVPL*VC, EPL*VC, EC*VC, GW*VC, ACCESS*EPL_VC
         */
        type: string;
        /**
         * Equinix-assigned connection identifier
         */
        uuid: string;
    }

    export interface GetConnectionZSideAccessPointLinkProtocol {
        /**
         * Defines the connection type like VG*VC, EVPL*VC, EPL*VC, EC*VC, GW*VC, ACCESS*EPL_VC
         */
        type: string;
        vlanCTag: number;
        vlanSTag: number;
        vlanTag: number;
    }

    export interface GetConnectionZSideAccessPointLocation {
        /**
         * Connection URI information
         */
        href: string;
        ibx: string;
        metroCode: string;
        metroName: string;
        region: string;
    }

    export interface GetConnectionZSideAccessPointPort {
        /**
         * Connection URI information
         */
        href: string;
        /**
         * Connection name. An alpha-numeric 24 characters string which can include only hyphens and underscores
         */
        name: string;
        /**
         * Redundancy Information
         */
        redundancies: outputs.fabric.GetConnectionZSideAccessPointPortRedundancy[];
        /**
         * Equinix-assigned connection identifier
         */
        uuid: string;
    }

    export interface GetConnectionZSideAccessPointPortRedundancy {
        priority: string;
    }

    export interface GetConnectionZSideAccessPointProfile {
        accessPointTypeConfigs: outputs.fabric.GetConnectionZSideAccessPointProfileAccessPointTypeConfig[];
        /**
         * Customer-provided connection description
         */
        description: string;
        /**
         * Connection URI information
         */
        href: string;
        /**
         * Connection name. An alpha-numeric 24 characters string which can include only hyphens and underscores
         */
        name: string;
        /**
         * Defines the connection type like VG*VC, EVPL*VC, EPL*VC, EC*VC, GW*VC, ACCESS*EPL_VC
         */
        type: string;
        /**
         * Equinix-assigned connection identifier
         */
        uuid: string;
    }

    export interface GetConnectionZSideAccessPointProfileAccessPointTypeConfig {
        allowBandwidthAutoApproval: boolean;
        allowBandwidthUpgrade: boolean;
        allowCustomBandwidth: boolean;
        allowRemoteConnections: boolean;
        apiConfigs: outputs.fabric.GetConnectionZSideAccessPointProfileAccessPointTypeConfigApiConfig[];
        authenticationKeys: outputs.fabric.GetConnectionZSideAccessPointProfileAccessPointTypeConfigAuthenticationKey[];
        bandwidthAlertThreshold: number;
        connectionLabel: string;
        connectionRedundancyRequired: boolean;
        enableAutoGenerateServiceKey: boolean;
        linkProtocolConfigs: outputs.fabric.GetConnectionZSideAccessPointProfileAccessPointTypeConfigLinkProtocolConfig[];
        supportedBandwidths: number[];
        /**
         * Defines the connection type like VG*VC, EVPL*VC, EPL*VC, EC*VC, GW*VC, ACCESS*EPL_VC
         */
        type: string;
        /**
         * Equinix-assigned connection identifier
         */
        uuid: string;
    }

    export interface GetConnectionZSideAccessPointProfileAccessPointTypeConfigApiConfig {
        allowOverSubscription: boolean;
        apiAvailable: boolean;
        bandwidthFromApi: boolean;
        equinixManagedPort: boolean;
        equinixManagedVlan: boolean;
        integrationId: string;
        overSubscriptionLimit: number;
    }

    export interface GetConnectionZSideAccessPointProfileAccessPointTypeConfigAuthenticationKey {
        /**
         * Customer-provided connection description
         */
        description: string;
        label: string;
        required: boolean;
    }

    export interface GetConnectionZSideAccessPointProfileAccessPointTypeConfigLinkProtocolConfig {
        encapsulation: string;
        encapsulationStrategy: string;
        reuseVlanSTag: boolean;
    }

    export interface GetConnectionZSideAccessPointVirtualDevice {
        /**
         * Connection URI information
         */
        href: string;
        /**
         * Defines the connection type like VG*VC, EVPL*VC, EPL*VC, EC*VC, GW*VC, ACCESS*EPL_VC
         */
        type: string;
        /**
         * Equinix-assigned connection identifier
         */
        uuid: string;
    }

    export interface GetConnectionZSideServiceToken {
        /**
         * Customer-provided connection description
         */
        description: string;
        /**
         * Connection URI information
         */
        href: string;
        /**
         * Defines the connection type like VG*VC, EVPL*VC, EPL*VC, EC*VC, GW*VC, ACCESS*EPL_VC
         */
        type: string;
        /**
         * Equinix-assigned connection identifier
         */
        uuid: string;
    }

    export interface GetPortsData {
        accounts: outputs.fabric.GetPortsDataAccount[];
        availableBandwidth: number;
        bandwidth: number;
        changeLogs: outputs.fabric.GetPortsDataChangeLog[];
        description: string;
        devices: outputs.fabric.GetPortsDataDevice[];
        encapsulations: outputs.fabric.GetPortsDataEncapsulation[];
        href: string;
        lags: outputs.fabric.GetPortsDataLag[];
        locations: outputs.fabric.GetPortsDataLocation[];
        name: string;
        operations: outputs.fabric.GetPortsDataOperation[];
        redundancies: outputs.fabric.GetPortsDataRedundancy[];
        serviceType: string;
        state: string;
        type: string;
        usedBandwidth: number;
        uuid?: string;
    }

    export interface GetPortsDataAccount {
        accountName: string;
        accountNumber: number;
        globalCustId: string;
        globalOrgId: string;
        globalOrganizationName: string;
        orgId: number;
        organizationName: string;
    }

    export interface GetPortsDataChangeLog {
        createdBy: string;
        createdByEmail: string;
        createdByFullName: string;
        createdDateTime: string;
        deletedBy: string;
        deletedByEmail: string;
        deletedByFullName: string;
        deletedDateTime: string;
        updatedBy: string;
        updatedByEmail: string;
        updatedByFullName: string;
        updatedDateTime: string;
    }

    export interface GetPortsDataDevice {
        name: string;
        redundancies: outputs.fabric.GetPortsDataDeviceRedundancy[];
    }

    export interface GetPortsDataDeviceRedundancy {
        group: string;
        priority: string;
    }

    export interface GetPortsDataEncapsulation {
        tagProtocolId: string;
        type: string;
    }

    export interface GetPortsDataLag {
        enabled: boolean;
        /**
         * The ID of this resource.
         */
        id: string;
        memberStatus: string;
        name: string;
    }

    export interface GetPortsDataLocation {
        href: string;
        ibx: string;
        metroCode: string;
        metroName: string;
        region: string;
    }

    export interface GetPortsDataOperation {
        connectionCount: number;
        opStatusChangedAt: string;
        operationalStatus: string;
    }

    export interface GetPortsDataRedundancy {
        enabled: boolean;
        group: number;
        priority: string;
    }

    export interface GetPortsFilter {
        /**
         * Query Parameter to Get Ports By Name
         */
        name?: string;
    }

    export interface GetServiceProfileAccessPointTypeConfig {
        allowBandwidthAutoApproval: boolean;
        allowBandwidthUpgrade: boolean;
        allowCustomBandwidth: boolean;
        allowRemoteConnections: boolean;
        apiConfigs: outputs.fabric.GetServiceProfileAccessPointTypeConfigApiConfig[];
        authenticationKeys: outputs.fabric.GetServiceProfileAccessPointTypeConfigAuthenticationKey[];
        bandwidthAlertThreshold: number;
        connectionLabel: string;
        connectionRedundancyRequired: boolean;
        enableAutoGenerateServiceKey: boolean;
        linkProtocolConfigs: outputs.fabric.GetServiceProfileAccessPointTypeConfigLinkProtocolConfig[];
        supportedBandwidths: number[];
        /**
         * Service profile type - L2*PROFILE, L3*PROFILE, ECIA*PROFILE, ECMC*PROFILE
         */
        type: string;
        /**
         * Equinix assigned service profile identifier
         */
        uuid: string;
    }

    export interface GetServiceProfileAccessPointTypeConfigApiConfig {
        allowOverSubscription: boolean;
        apiAvailable: boolean;
        bandwidthFromApi: boolean;
        equinixManagedPort: boolean;
        equinixManagedVlan: boolean;
        integrationId: string;
        overSubscriptionLimit: number;
    }

    export interface GetServiceProfileAccessPointTypeConfigAuthenticationKey {
        /**
         * User-provided service description
         */
        description: string;
        label: string;
        required: boolean;
    }

    export interface GetServiceProfileAccessPointTypeConfigLinkProtocolConfig {
        encapsulation: string;
        encapsulationStrategy: string;
        reuseVlanSTag: boolean;
    }

    export interface GetServiceProfileAccount {
        accountName: string;
        accountNumber: number;
        globalCustId: string;
        globalOrgId: string;
        globalOrganizationName: string;
        orgId: number;
        organizationName: string;
        ucmId: string;
    }

    export interface GetServiceProfileChangeLog {
        createdBy: string;
        createdByEmail: string;
        createdByFullName: string;
        createdDateTime: string;
        deletedBy: string;
        deletedByEmail: string;
        deletedByFullName: string;
        deletedDateTime: string;
        updatedBy: string;
        updatedByEmail: string;
        updatedByFullName: string;
        updatedDateTime: string;
    }

    export interface GetServiceProfileCustomField {
        captureInEmail: boolean;
        dataType: string;
        /**
         * User-provided service description
         */
        description: string;
        label: string;
        options: string[];
        required: boolean;
    }

    export interface GetServiceProfileMarketingInfo {
        logo: string;
        processSteps: outputs.fabric.GetServiceProfileMarketingInfoProcessStep[];
        promotion: boolean;
    }

    export interface GetServiceProfileMarketingInfoProcessStep {
        /**
         * User-provided service description
         */
        description: string;
        subTitle: string;
        title: string;
    }

    export interface GetServiceProfileMetro {
        code: string;
        displayName: string;
        ibxs: string[];
        inTrail: boolean;
        /**
         * Customer-assigned service profile name
         */
        name: string;
        sellerRegions: {[key: string]: string};
    }

    export interface GetServiceProfileNotification {
        emails: string[];
        sendInterval: string;
        /**
         * Service profile type - L2*PROFILE, L3*PROFILE, ECIA*PROFILE, ECMC*PROFILE
         */
        type: string;
    }

    export interface GetServiceProfilePort {
        crossConnectId: string;
        locations: outputs.fabric.GetServiceProfilePortLocation[];
        sellerRegion: string;
        sellerRegionDescription: string;
        /**
         * Service profile type - L2*PROFILE, L3*PROFILE, ECIA*PROFILE, ECMC*PROFILE
         */
        type: string;
        /**
         * Equinix assigned service profile identifier
         */
        uuid: string;
    }

    export interface GetServiceProfilePortLocation {
        ibx: string;
        metroCode: string;
        metroName: string;
        region: string;
    }

    export interface GetServiceProfileProject {
        /**
         * Service Profile URI response attribute
         */
        href: string;
        projectId: string;
    }

    export interface GetServiceProfilesData {
        accessPointTypeConfigs: outputs.fabric.GetServiceProfilesDataAccessPointTypeConfig[];
        accounts: outputs.fabric.GetServiceProfilesDataAccount[];
        allowedEmails: string[];
        changeLogs: outputs.fabric.GetServiceProfilesDataChangeLog[];
        customFields: outputs.fabric.GetServiceProfilesDataCustomField[];
        description: string;
        href: string;
        marketingInfos: outputs.fabric.GetServiceProfilesDataMarketingInfo[];
        metros: outputs.fabric.GetServiceProfilesDataMetro[];
        name: string;
        notifications: outputs.fabric.GetServiceProfilesDataNotification[];
        ports: outputs.fabric.GetServiceProfilesDataPort[];
        projects: outputs.fabric.GetServiceProfilesDataProject[];
        selfProfile: boolean;
        state?: string;
        tags: string[];
        type: string;
        uuid?: string;
        visibility: string;
    }

    export interface GetServiceProfilesDataAccessPointTypeConfig {
        allowBandwidthAutoApproval: boolean;
        allowBandwidthUpgrade: boolean;
        allowCustomBandwidth: boolean;
        allowRemoteConnections: boolean;
        apiConfigs: outputs.fabric.GetServiceProfilesDataAccessPointTypeConfigApiConfig[];
        authenticationKeys: outputs.fabric.GetServiceProfilesDataAccessPointTypeConfigAuthenticationKey[];
        bandwidthAlertThreshold: number;
        connectionLabel: string;
        connectionRedundancyRequired: boolean;
        enableAutoGenerateServiceKey: boolean;
        linkProtocolConfigs: outputs.fabric.GetServiceProfilesDataAccessPointTypeConfigLinkProtocolConfig[];
        supportedBandwidths: number[];
        type: string;
        uuid: string;
    }

    export interface GetServiceProfilesDataAccessPointTypeConfigApiConfig {
        allowOverSubscription: boolean;
        apiAvailable: boolean;
        bandwidthFromApi: boolean;
        equinixManagedPort: boolean;
        equinixManagedVlan: boolean;
        integrationId: string;
        overSubscriptionLimit: number;
    }

    export interface GetServiceProfilesDataAccessPointTypeConfigAuthenticationKey {
        description: string;
        label: string;
        required: boolean;
    }

    export interface GetServiceProfilesDataAccessPointTypeConfigLinkProtocolConfig {
        encapsulation: string;
        encapsulationStrategy: string;
        reuseVlanSTag: boolean;
    }

    export interface GetServiceProfilesDataAccount {
        accountName: string;
        accountNumber: number;
        globalCustId: string;
        globalOrgId: string;
        globalOrganizationName: string;
        orgId: number;
        organizationName: string;
        ucmId: string;
    }

    export interface GetServiceProfilesDataChangeLog {
        createdBy: string;
        createdByEmail: string;
        createdByFullName: string;
        createdDateTime: string;
        deletedBy: string;
        deletedByEmail: string;
        deletedByFullName: string;
        deletedDateTime: string;
        updatedBy: string;
        updatedByEmail: string;
        updatedByFullName: string;
        updatedDateTime: string;
    }

    export interface GetServiceProfilesDataCustomField {
        captureInEmail: boolean;
        dataType: string;
        description: string;
        label: string;
        options: string[];
        required: boolean;
    }

    export interface GetServiceProfilesDataMarketingInfo {
        logo: string;
        processSteps: outputs.fabric.GetServiceProfilesDataMarketingInfoProcessStep[];
        promotion: boolean;
    }

    export interface GetServiceProfilesDataMarketingInfoProcessStep {
        description: string;
        subTitle: string;
        title: string;
    }

    export interface GetServiceProfilesDataMetro {
        code: string;
        displayName: string;
        ibxs: string[];
        inTrail: boolean;
        name: string;
        sellerRegions: {[key: string]: string};
    }

    export interface GetServiceProfilesDataNotification {
        emails: string[];
        sendInterval: string;
        type: string;
    }

    export interface GetServiceProfilesDataPort {
        crossConnectId: string;
        locations: outputs.fabric.GetServiceProfilesDataPortLocation[];
        sellerRegion: string;
        sellerRegionDescription: string;
        type: string;
        uuid: string;
    }

    export interface GetServiceProfilesDataPortLocation {
        ibx: string;
        metroCode: string;
        metroName: string;
        region: string;
    }

    export interface GetServiceProfilesDataProject {
        href: string;
        projectId: string;
    }

    export interface GetServiceProfilesFilter {
        /**
         * Possible operator to use on filters = - equal
         */
        operator?: string;
        /**
         * Search Criteria for Service Profile - /name, /uuid, /state, /metros/code, /visibility, /type
         */
        property?: string;
        /**
         * Values
         */
        values?: string[];
    }

    export interface GetServiceProfilesSort {
        /**
         * Priority type- DESC, ASC
         */
        direction?: string;
        /**
         * Search operation sort criteria /name /state /changeLog/createdDateTime /changeLog/updatedDateTime
         */
        property?: string;
    }

    export interface ServiceProfileAccessPointTypeConfig {
        /**
         * Setting to enable or disable the ability of the buyer to change connection bandwidth without approval of the seller
         */
        allowBandwidthAutoApproval?: boolean;
        /**
         * Availability of a bandwidth upgrade. The default is false
         */
        allowBandwidthUpgrade?: boolean;
        /**
         * Setting to enable or disable the ability of the buyer to customize the bandwidth
         */
        allowCustomBandwidth?: boolean;
        /**
         * Setting to allow or prohibit remote connections to the service profile
         */
        allowRemoteConnections?: boolean;
        /**
         * Api configuration details
         */
        apiConfigs?: outputs.fabric.ServiceProfileAccessPointTypeConfigApiConfig[];
        /**
         * Authentication key details
         */
        authenticationKeys?: outputs.fabric.ServiceProfileAccessPointTypeConfigAuthenticationKey[];
        /**
         * Percentage of port bandwidth at which an allocation alert is generated
         */
        bandwidthAlertThreshold?: number;
        /**
         * Custom name for Connection
         */
        connectionLabel?: string;
        /**
         * Mandate redundant connections
         */
        connectionRedundancyRequired?: boolean;
        /**
         * Enable auto generate service key
         */
        enableAutoGenerateServiceKey?: boolean;
        /**
         * Link protocol configuration details
         */
        linkProtocolConfigs?: outputs.fabric.ServiceProfileAccessPointTypeConfigLinkProtocolConfig[];
        /**
         * Supported bandwidths
         */
        supportedBandwidths?: number[];
        /**
         * Type of access point type config - VD, COLO
         */
        type: string;
        /**
         * Colo/Port Uuid
         */
        uuid: string;
    }

    export interface ServiceProfileAccessPointTypeConfigApiConfig {
        allowOverSubscription?: boolean;
        apiAvailable?: boolean;
        bandwidthFromApi?: boolean;
        equinixManagedPort?: boolean;
        equinixManagedVlan?: boolean;
        integrationId?: string;
        overSubscriptionLimit?: number;
    }

    export interface ServiceProfileAccessPointTypeConfigAuthenticationKey {
        /**
         * User-provided service description
         */
        description?: string;
        label?: string;
        required?: boolean;
    }

    export interface ServiceProfileAccessPointTypeConfigLinkProtocolConfig {
        encapsulation?: string;
        encapsulationStrategy?: string;
        reuseVlanSTag?: boolean;
    }

    export interface ServiceProfileAccount {
        /**
         * Account Name
         */
        accountName?: string;
        /**
         * Account Number
         */
        accountNumber?: number;
        /**
         * Global Customer organization identifier
         */
        globalCustId?: string;
        /**
         * Global organization identifier
         */
        globalOrgId?: string;
        /**
         * Global organization name
         */
        globalOrganizationName?: string;
        /**
         * Customer organization identifier
         */
        orgId?: number;
        /**
         * Customer organization name
         */
        organizationName?: string;
        /**
         * Enterprise datastore id
         */
        ucmId?: string;
    }

    export interface ServiceProfileChangeLog {
        createdBy: string;
        createdByEmail: string;
        createdByFullName: string;
        createdDateTime: string;
        deletedBy: string;
        deletedByEmail: string;
        deletedByFullName: string;
        deletedDateTime: string;
        updatedBy: string;
        updatedByEmail: string;
        updatedByFullName: string;
        updatedDateTime: string;
    }

    export interface ServiceProfileCustomField {
        /**
         * Required field
         */
        captureInEmail?: boolean;
        /**
         * Data type
         */
        dataType: string;
        /**
         * Description
         */
        description?: string;
        /**
         * Label
         */
        label: string;
        /**
         * Options
         */
        options?: string[];
        /**
         * Required field
         */
        required: boolean;
    }

    export interface ServiceProfileMarketingInfo {
        /**
         * Logo
         */
        logo?: string;
        /**
         * Process Step
         */
        processSteps?: outputs.fabric.ServiceProfileMarketingInfoProcessStep[];
        /**
         * Promotion
         */
        promotion?: boolean;
    }

    export interface ServiceProfileMarketingInfoProcessStep {
        /**
         * User-provided service description
         */
        description?: string;
        subTitle?: string;
        title?: string;
    }

    export interface ServiceProfileMetro {
        /**
         * Metro Code - Example SV
         */
        code?: string;
        /**
         * Display Name
         */
        displayName?: string;
        /**
         * IBX- Equinix International Business Exchange list
         */
        ibxs?: string[];
        /**
         * In Trail
         */
        inTrail?: boolean;
        /**
         * Metro Name
         */
        name?: string;
        /**
         * Seller Regions
         */
        sellerRegions?: {[key: string]: string};
    }

    export interface ServiceProfileNotification {
        /**
         * Array of contact emails
         */
        emails: string[];
        /**
         * Send interval
         */
        sendInterval?: string;
        /**
         * Notification Type - ALL,CONNECTION*APPROVAL,SALES*REP_NOTIFICATIONS, NOTIFICATIONS
         */
        type: string;
    }

    export interface ServiceProfilePort {
        /**
         * Cross Connect Id
         */
        crossConnectId?: string;
        /**
         * Colo/Port Location
         */
        locations?: outputs.fabric.ServiceProfilePortLocation[];
        /**
         * Seller Region
         */
        sellerRegion?: string;
        /**
         * Seller Region details
         */
        sellerRegionDescription?: string;
        /**
         * Colo/Port Type
         */
        type: string;
        /**
         * Colo/Port Uuid
         */
        uuid: string;
    }

    export interface ServiceProfilePortLocation {
        ibx: string;
        metroCode: string;
        metroName: string;
        region: string;
    }

    export interface ServiceProfileProject {
        /**
         * Unique Resource URL
         */
        href: string;
        /**
         * Project Id
         */
        projectId: string;
    }

    export interface ServiceProfileVirtualDevice {
        /**
         * Device Interface Uuid
         */
        interfaceUuid?: string;
        /**
         * Device Location
         */
        locations?: outputs.fabric.ServiceProfileVirtualDeviceLocation[];
        /**
         * Virtual Device Type
         */
        type: string;
        /**
         * Virtual Device Uuid
         */
        uuid: string;
    }

    export interface ServiceProfileVirtualDeviceLocation {
        ibx: string;
        metroCode: string;
        metroName: string;
        region: string;
    }

}

export namespace metal {
    export interface ConnectionPort {
        id: string;
        linkStatus: string;
        /**
         * Name of the connection resource
         */
        name: string;
        role: string;
        /**
         * Connection speed - one of 50Mbps, 200Mbps, 500Mbps, 1Gbps, 2Gbps, 5Gbps, 10Gbps.
         */
        speed: number;
        /**
         * Status of the connection resource.
         */
        status: string;
        virtualCircuitIds: any[];
    }

    export interface ConnectionServiceToken {
        expiresAt: string;
        id: string;
        maxAllowedSpeed: string;
        role: string;
        state: string;
        /**
         * Connection type - dedicated or shared.
         */
        type: string;
    }

    export interface DeviceBehavior {
        /**
         * List of attributes that are allowed to change without recreating the instance. Supported attributes: `customData`, `userData`"
         */
        allowChanges?: string[];
    }

    export interface DeviceIpAddress {
        /**
         * CIDR suffix for IP address block to be assigned, i.e. amount of addresses.
         */
        cidr?: number;
        /**
         * List of UUIDs of IP block reservations
         * from which the public IPv4 address should be taken.
         */
        reservationIds?: string[];
        /**
         * One of `privateIpv4`, `publicIpv4`, `publicIpv6`.
         */
        type: string;
    }

    export interface DeviceNetwork {
        /**
         * IPv4 or IPv6 address string.
         */
        address: string;
        /**
         * CIDR suffix for IP address block to be assigned, i.e. amount of addresses.
         */
        cidr: number;
        /**
         * IP version. One of `4`, `6`.
         */
        family: number;
        /**
         * Address of router.
         */
        gateway: string;
        /**
         * Whether the address is routable from the Internet.
         */
        public: boolean;
    }

    export interface DevicePort {
        /**
         * Whether this port is part of a bond in bonded network setup.
         */
        bonded: boolean;
        /**
         * ID of the port.
         */
        id: string;
        /**
         * MAC address assigned to the port.
         */
        mac: string;
        /**
         * Name of the port (e.g. `eth0`, or `bond0`).
         */
        name: string;
        /**
         * One of `privateIpv4`, `publicIpv4`, `publicIpv6`.
         */
        type: string;
    }

    export interface DeviceReinstall {
        /**
         * Whether the OS disk should be filled with `00h` bytes before reinstall.
         * Defaults to `false`.
         */
        deprovisionFast?: boolean;
        /**
         * Whether the provider should favour reinstall over destroy and create. Defaults to
         * `false`.
         */
        enabled?: boolean;
        /**
         * Whether the non-OS disks should be kept or wiped during reinstall.
         * Defaults to `false`.
         */
        preserveData?: boolean;
    }

    export interface GetConnectionPort {
        /**
         * Port UUID.
         */
        id: string;
        /**
         * Port link status.
         */
        linkStatus: string;
        /**
         * Port name.
         */
        name: string;
        /**
         * Port role - primary or secondary.
         */
        role: string;
        /**
         * Port speed in bits per second.
         */
        speed: number;
        /**
         * Port status.
         */
        status: string;
        /**
         * List of IDs of virtual cicruits attached to this port.
         */
        virtualCircuitIds: any[];
    }

    export interface GetConnectionServiceToken {
        /**
         * Expiration date of the service token.
         */
        expiresAt: string;
        /**
         * Port UUID.
         */
        id: string;
        /**
         * Maximum allowed speed for the service token, string like in the `speed` attribute.
         */
        maxAllowedSpeed: string;
        /**
         * Port role - primary or secondary.
         */
        role: string;
        state: string;
        /**
         * Token type, `aSide` or `zSide`.
         */
        type: string;
    }

    export interface GetDeviceBgpNeighborsBgpNeighbor {
        /**
         * IP address version, 4 or 6.
         */
        addressFamily: number;
        /**
         * Local autonomous system number.
         */
        customerAs: number;
        /**
         * Local used peer IP address.
         */
        customerIp: string;
        /**
         * Whether BGP session is password enabled.
         */
        md5Enabled: boolean;
        /**
         * BGP session password in plaintext (not a checksum).
         */
        md5Password: string;
        /**
         * Whether the neighbor is in EBGP multihop session.
         */
        multihop: boolean;
        /**
         * Peer AS number (different than customerAs for EBGP).
         */
        peerAs: number;
        /**
         * Array of IP addresses of this neighbor's peers.
         */
        peerIps?: string[];
        /**
         * Array of incoming routes.
         */
        routesIns: outputs.metal.GetDeviceBgpNeighborsBgpNeighborRoutesIn[];
        /**
         * Array of outgoing routes in the same format.
         */
        routesOuts: outputs.metal.GetDeviceBgpNeighborsBgpNeighborRoutesOut[];
    }

    export interface GetDeviceBgpNeighborsBgpNeighborRoutesIn {
        /**
         * (bool) Whether the route is exact.
         */
        exact: boolean;
        /**
         * CIDR expression of route (IP/mask).
         */
        route: string;
    }

    export interface GetDeviceBgpNeighborsBgpNeighborRoutesOut {
        /**
         * (bool) Whether the route is exact.
         */
        exact: boolean;
        /**
         * CIDR expression of route (IP/mask).
         */
        route: string;
    }

    export interface GetDeviceNetwork {
        /**
         * IPv4 or IPv6 address string.
         */
        address: string;
        /**
         * Bit length of the network mask of the address.
         */
        cidr: number;
        /**
         * IP version. One of `4`, `6`.
         */
        family: number;
        /**
         * Address of router.
         */
        gateway: string;
        /**
         * Whether the address is routable from the Internet.
         */
        public: boolean;
    }

    export interface GetDevicePort {
        /**
         * Whether this port is part of a bond in bonded network setup.
         */
        bonded: boolean;
        /**
         * ID of the port.
         */
        id: string;
        /**
         * MAC address assigned to the port.
         */
        mac: string;
        /**
         * Name of the port (e.g. `eth0`, or `bond0`).
         */
        name: string;
        /**
         * Type of the port (e.g. `NetworkPort` or `NetworkBondPort`).
         */
        type: string;
    }

    export interface GetFacilityCapacity {
        /**
         * Device plan that must be available in selected location.
         */
        plan: string;
        /**
         * Minimun number of devices that must be available in selected location.
         * Default is `1`.
         */
        quantity?: number;
    }

    export interface GetMetroCapacity {
        /**
         * Device plan that must be available in selected location.
         */
        plan: string;
        /**
         * Minimun number of devices that must be available in selected location.
         * Default is `1`.
         */
        quantity?: number;
    }

    export interface GetOrganizationAddress {
        /**
         * Postal address.
         */
        address: string;
        /**
         * City name.
         */
        city: string;
        /**
         * Two letter country code (ISO 3166-1 alpha-2), e.g. US.
         */
        country: string;
        /**
         * State name.
         */
        state: string;
        /**
         * Zip Code.
         */
        zipCode: string;
    }

    export interface GetPlansFilter {
        /**
         * If is set to true, the values are joined with an AND, and the requests returns only the results that match all specified values. Default is `false`.
         */
        all?: boolean;
        /**
         * The attribute used to filter. Filter attributes are case-sensitive
         */
        attribute: string;
        /**
         * The type of comparison to apply. One of: `in` , `re`, `substring`, `lessThan`, `lessThanOrEqual`, `greaterThan`, `greaterThanOrEqual`. Default is `in`.
         */
        matchBy?: string;
        /**
         * The filter values. Filter values are case-sensitive. If you specify multiple values for a filter, the values are joined with an OR by default, and the request returns all results that match any of the specified values
         */
        values: string[];
    }

    export interface GetPlansPlan {
        /**
         * list of facilities where the plan is available
         */
        availableInMetros: string[];
        /**
         * list of facilities where the plan is available
         */
        availableIns: string[];
        /**
         * plan class
         */
        class: string;
        /**
         * list of deployment types, e.g. on_demand, spot_market
         */
        deploymentTypes: string[];
        /**
         * description of the plan
         */
        description: string;
        /**
         * id of the plan
         */
        id: string;
        /**
         * flag showing if it's a legacy plan
         */
        legacy: boolean;
        /**
         * plan line, e.g. baremetal
         */
        line: string;
        /**
         * name of the plan
         */
        name: string;
        /**
         * plan hourly price
         */
        pricingHour: number;
        /**
         * plan monthly price
         */
        pricingMonth: number;
        /**
         * plan slug
         */
        slug: string;
    }

    export interface GetPlansSort {
        /**
         * The attribute used to filter. Filter attributes are case-sensitive
         */
        attribute: string;
        /**
         * Sort results in ascending or descending order. Strings are sorted in alphabetical order. One of: asc, desc
         */
        direction?: string;
    }

    export interface GetProjectBgpConfig {
        /**
         * Autonomous System Number for local BGP deployment.
         */
        asn: number;
        /**
         * One of `private`, `public`.
         */
        deploymentType: string;
        /**
         * The maximum number of route filters allowed per server.
         */
        maxPrefix: number;
        /**
         * Password for BGP session in plaintext (not a checksum).
         */
        md5?: string;
        /**
         * Status of BGP configuration in the project.
         */
        status: string;
    }

    export interface OrganizationAddress {
        /**
         * Postal address.
         */
        address: string;
        /**
         * City name.
         */
        city: string;
        /**
         * Two letter country code (ISO 3166-1 alpha-2), e.g. US.
         */
        country: string;
        /**
         * State name.
         */
        state?: string;
        /**
         * Zip Code.
         */
        zipCode: string;
    }

    export interface ProjectBgpConfig {
        /**
         * Autonomous System Number for local BGP deployment.
         */
        asn: number;
        /**
         * `private` or `public`, the `private` is likely to be usable immediately, the
         * `public` will need to be reviewed by Equinix Metal engineers.
         */
        deploymentType: string;
        /**
         * The maximum number of route filters allowed per server.
         */
        maxPrefix: number;
        /**
         * Password for BGP session in plaintext (not a checksum).
         */
        md5?: string;
        /**
         * status of BGP configuration in the project.
         */
        status: string;
    }

    export interface SpotMarketRequestInstanceParameters {
        alwaysPxe?: boolean;
        billingCycle: string;
        customdata?: string;
        description?: string;
        features?: string[];
        hostname: string;
        ipxeScriptUrl?: string;
        /**
         * Blocks deletion of the SpotMarketRequest device until the lock is disabled.
         */
        locked?: boolean;
        operatingSystem: string;
        plan: string;
        projectSshKeys?: string[];
        tags?: string[];
        termintationTime: string;
        userSshKeys?: string[];
        userdata?: string;
    }

}

export namespace networkedge {
    export interface AclTemplateDeviceDetail {
        /**
         * Device ACL provisioning status where template was applied. One of `PROVISIONING`,
         * `PROVISIONED`.
         */
        aclStatus: string;
        /**
         * ACL template name.
         */
        name: string;
        /**
         * Device uuid.
         */
        uuid: string;
    }

    export interface AclTemplateInboundRule {
        /**
         * Inbound rule description, up to 200 characters.
         */
        description?: string;
        /**
         * Inbound traffic destination ports. Allowed values are a comma separated
         * list of ports, e.g., `20,22,23`, port range, e.g., `1023-1040` or word `any`.
         */
        dstPort: string;
        /**
         * Inbound traffic protocol. One of `IP`, `TCP`, `UDP`.
         */
        protocol: string;
        sequenceNumber: number;
        /**
         * @deprecated Source Type will not be returned
         */
        sourceType: string;
        /**
         * Inbound traffic source ports. Allowed values are a comma separated list
         * of ports, e.g., `20,22,23`, port range, e.g., `1023-1040` or word `any`.
         */
        srcPort: string;
        /**
         * Inbound traffic source IP subnet in CIDR format.
         */
        subnet?: string;
        /**
         * Inbound traffic source IP subnets in CIDR format.
         *
         * @deprecated Use Subnet instead
         */
        subnets?: string[];
    }

    export interface DeviceClusterDetails {
        /**
         * The ID of the cluster.
         */
        clusterId: string;
        /**
         * The name of the cluster device
         */
        clusterName: string;
        /**
         * An object that has `node0` configuration.
         * See Cluster Details - Nodes below for more details.
         */
        node0: outputs.networkedge.DeviceClusterDetailsNode0;
        /**
         * An object that has `node1` configuration.
         * See Cluster Details - Nodes below for more details.
         */
        node1: outputs.networkedge.DeviceClusterDetailsNode1;
        /**
         * The number of nodes in the cluster.
         */
        numOfNodes: number;
    }

    export interface DeviceClusterDetailsNode0 {
        /**
         * Identifier of a license file that will be applied on the device.
         */
        licenseFileId?: string;
        /**
         * License Token applicable for some device types in BYOL licensing
         * mode.
         */
        licenseToken?: string;
        /**
         * Device name.
         */
        name: string;
        /**
         * Device unique identifier.
         */
        uuid: string;
        /**
         * Map of vendor specific configuration parameters for a device
         * (controller1, activationKey, managementType, siteId, systemIpAddress)
         * * `ssh-key` - (Optional) Definition of SSH key that will be provisioned
         * on a device (max one key).  See SSH Key below for more details.
         */
        vendorConfiguration?: outputs.networkedge.DeviceClusterDetailsNode0VendorConfiguration;
    }

    export interface DeviceClusterDetailsNode0VendorConfiguration {
        /**
         * Activation key. This is required for Velocloud clusters.
         */
        activationKey?: string;
        /**
         * The administrative password of the device. You can use it to log in
         * to the console. This field is not available for all device types.
         */
        adminPassword: string;
        /**
         * System IP Address. Mandatory for the Fortinet SDWAN cluster device.
         */
        controller1?: string;
        /**
         * Controller fqdn. This is required for Velocloud clusters.
         */
        controllerFqdn?: string;
        /**
         * Hostname. This is necessary for Palo Alto, Juniper, and Fortinet clusters.
         */
        hostname?: string;
        /**
         * The CLI password of the device. This field is relevant only for the
         * Velocloud SDWAN cluster.
         */
        rootPassword?: string;
    }

    export interface DeviceClusterDetailsNode1 {
        /**
         * Identifier of a license file that will be applied on the device.
         */
        licenseFileId?: string;
        /**
         * License Token applicable for some device types in BYOL licensing
         * mode.
         */
        licenseToken?: string;
        /**
         * Device name.
         */
        name: string;
        /**
         * Device unique identifier.
         */
        uuid: string;
        /**
         * Map of vendor specific configuration parameters for a device
         * (controller1, activationKey, managementType, siteId, systemIpAddress)
         * * `ssh-key` - (Optional) Definition of SSH key that will be provisioned
         * on a device (max one key).  See SSH Key below for more details.
         */
        vendorConfiguration?: outputs.networkedge.DeviceClusterDetailsNode1VendorConfiguration;
    }

    export interface DeviceClusterDetailsNode1VendorConfiguration {
        /**
         * Activation key. This is required for Velocloud clusters.
         */
        activationKey?: string;
        /**
         * The administrative password of the device. You can use it to log in
         * to the console. This field is not available for all device types.
         */
        adminPassword: string;
        /**
         * System IP Address. Mandatory for the Fortinet SDWAN cluster device.
         */
        controller1?: string;
        /**
         * Controller fqdn. This is required for Velocloud clusters.
         */
        controllerFqdn?: string;
        /**
         * Hostname. This is necessary for Palo Alto, Juniper, and Fortinet clusters.
         */
        hostname?: string;
        /**
         * The CLI password of the device. This field is relevant only for the
         * Velocloud SDWAN cluster.
         */
        rootPassword?: string;
    }

    export interface DeviceInterface {
        /**
         * interface management type (Equinix Managed or empty).
         */
        assignedType: string;
        /**
         * interface identifier.
         */
        id: number;
        /**
         * interface IP address.
         */
        ipAddress: string;
        /**
         * interface MAC address.
         */
        macAddress: string;
        /**
         * Device name.
         */
        name: string;
        /**
         * interface operational status. One of `up`, `down`.
         */
        operationalStatus: string;
        /**
         * interface status. One of `AVAILABLE`, `RESERVED`, `ASSIGNED`.
         */
        status: string;
        /**
         * interface type.
         */
        type: string;
    }

    export interface DeviceLinkDevice {
        /**
         * Device ASN number. Not required for self configured devices.
         */
        asn?: number;
        /**
         * Device identifier.
         */
        id: string;
        /**
         * Device network interface identifier to use for device link
         * connection.
         */
        interfaceId?: number;
        /**
         * IP address from device link subnet that was assigned to the device
         */
        ipAddress: string;
        /**
         * device link provisioning status on a given device. One of `PROVISIONING`,
         * `PROVISIONED`, `DEPROVISIONING`, `DEPROVISIONED`, `FAILED`.
         */
        status: string;
    }

    export interface DeviceLinkLink {
        /**
         * billing account number to be used for
         * connection charges
         */
        accountNumber: string;
        /**
         * connection destination metro code.
         */
        dstMetroCode: string;
        /**
         * connection destination zone code is not required.
         *
         * @deprecated DestinationZoneCode is not required
         */
        dstZoneCode?: string;
        /**
         * connection source metro code.
         */
        srcMetroCode: string;
        /**
         * connection source zone code is not required.
         *
         * @deprecated SourceZoneCode is not required
         */
        srcZoneCode?: string;
        /**
         * connection throughput.
         */
        throughput: string;
        /**
         * connection throughput unit (Mbps or Gbps).
         */
        throughputUnit: string;
    }

    export interface DeviceSecondaryDevice {
        /**
         * Billing account number for secondary device.
         */
        accountNumber: string;
        /**
         * Identifier of a WAN interface ACL template that will be applied
         * on a secondary device.
         */
        aclTemplateId?: string;
        /**
         * Additional Internet bandwidth, in Mbps, for a secondary
         * device.
         */
        additionalBandwidth: number;
        /**
         * (Autonomous System Number) Unique identifier for a network on the internet.
         */
        asn: number;
        /**
         * Identifier of a cloud init file that will be applied on a secondary device.
         */
        cloudInitFileId?: string;
        /**
         * Secondary device hostname.
         */
        hostname?: string;
        /**
         * Device location Equinix Business Exchange name.
         */
        ibx: string;
        /**
         * List of device interfaces. See Interface Attribute below
         * for more details.
         */
        interfaces: outputs.networkedge.DeviceSecondaryDeviceInterface[];
        /**
         * Path to the license file that will be uploaded and applied on a
         * secondary device. Applicable for some device types in BYOL licensing mode.
         */
        licenseFile?: string;
        /**
         * Identifier of a license file that will be applied on a secondary device.
         */
        licenseFileId: string;
        /**
         * Device license registration status. Possible values are `APPLYING_LICENSE`,
         * `REGISTERED`, `APPLIED`, `WAITING_FOR_CLUSTER_SETUP`, `REGISTRATION_FAILED`.
         */
        licenseStatus: string;
        /**
         * License Token can be provided for some device types o the device.
         */
        licenseToken?: string;
        /**
         * Metro location of a secondary device.
         */
        metroCode: string;
        /**
         * Identifier of an MGMT interface ACL template that will be
         * applied on a secondary device.
         * * `ssh-key` - (Optional) Up to one definition of SSH key that will be provisioned on a secondary
         * device.
         */
        mgmtAclTemplateUuid?: string;
        /**
         * Secondary device name.
         */
        name: string;
        /**
         * List of email addresses that will receive notifications about
         * secondary device.
         */
        notifications: string[];
        /**
         * Device redundancy type applicable for HA devices, either
         * primary or secondary.
         */
        redundancyType: string;
        /**
         * Unique identifier for a redundant device applicable for HA devices.
         */
        redundantId: string;
        /**
         * Device location region.
         */
        region: string;
        /**
         * IP address of SSH enabled interface on the device.
         */
        sshIpAddress: string;
        /**
         * FQDN of SSH enabled interface on the device.
         */
        sshIpFqdn: string;
        sshKey?: outputs.networkedge.DeviceSecondaryDeviceSshKey;
        /**
         * interface status. One of `AVAILABLE`, `RESERVED`, `ASSIGNED`.
         */
        status: string;
        /**
         * Device unique identifier.
         */
        uuid: string;
        /**
         * Key/Value pairs of vendor specific configuration parameters
         * for a secondary device. Key values are `controller1`, `activationKey`, `managementType`, `siteId`,
         * `systemIpAddress`.
         */
        vendorConfiguration: {[key: string]: string};
        wanInterfaceId?: string;
        /**
         * Device location zone code.
         */
        zoneCode: string;
    }

    export interface DeviceSecondaryDeviceInterface {
        /**
         * interface management type (Equinix Managed or empty).
         */
        assignedType: string;
        /**
         * interface identifier.
         */
        id: number;
        /**
         * interface IP address.
         */
        ipAddress: string;
        /**
         * interface MAC address.
         */
        macAddress: string;
        /**
         * Device name.
         */
        name: string;
        /**
         * interface operational status. One of `up`, `down`.
         */
        operationalStatus: string;
        /**
         * interface status. One of `AVAILABLE`, `RESERVED`, `ASSIGNED`.
         */
        status: string;
        /**
         * interface type.
         */
        type: string;
    }

    export interface DeviceSecondaryDeviceSshKey {
        keyName: string;
        /**
         * username associated with given key.
         */
        username: string;
    }

    export interface DeviceSshKey {
        keyName: string;
        /**
         * username associated with given key.
         */
        username: string;
    }

    export interface GetDeviceClusterDetail {
        /**
         * The id of the cluster
         */
        clusterId: string;
        clusterName: string;
        node0s: outputs.networkedge.GetDeviceClusterDetailNode0[];
        node1s: outputs.networkedge.GetDeviceClusterDetailNode1[];
        /**
         * The number of nodes in the cluster
         */
        numOfNodes: number;
    }

    export interface GetDeviceClusterDetailNode0 {
        /**
         * Unique identifier of applied license file
         */
        licenseFileId: string;
        licenseToken: string;
        /**
         * Name of an existing Equinix Network Edge device
         */
        name: string;
        /**
         * UUID of an existing Equinix Network Edge device
         */
        uuid: string;
        vendorConfigurations: outputs.networkedge.GetDeviceClusterDetailNode0VendorConfiguration[];
    }

    export interface GetDeviceClusterDetailNode0VendorConfiguration {
        activationKey: string;
        adminPassword: string;
        controller1: string;
        controllerFqdn: string;
        hostname: string;
        rootPassword: string;
    }

    export interface GetDeviceClusterDetailNode1 {
        /**
         * Unique identifier of applied license file
         */
        licenseFileId: string;
        licenseToken: string;
        /**
         * Name of an existing Equinix Network Edge device
         */
        name: string;
        /**
         * UUID of an existing Equinix Network Edge device
         */
        uuid: string;
        vendorConfigurations: outputs.networkedge.GetDeviceClusterDetailNode1VendorConfiguration[];
    }

    export interface GetDeviceClusterDetailNode1VendorConfiguration {
        activationKey: string;
        adminPassword: string;
        controller1: string;
        controllerFqdn: string;
        hostname: string;
        rootPassword: string;
    }

    export interface GetDeviceInterface {
        assignedType: string;
        id: number;
        ipAddress: string;
        macAddress: string;
        /**
         * Name of an existing Equinix Network Edge device
         */
        name: string;
        operationalStatus: string;
        /**
         * Device provisioning status
         * * INITIALIZING
         * * PROVISIONING
         * * PROVISIONED  (**NOTE: By default data source will only return devices in this state.  To include other states see `validStateList`**)
         * * WAITING_FOR_PRIMARY
         * * WAITING_FOR_SECONDARY
         * * WAITING_FOR_REPLICA_CLUSTER_NODES
         * * CLUSTER_SETUP_IN_PROGRESS
         * * FAILED
         * * DEPROVISIONING
         * * DEPROVISIONED
         */
        status: string;
        type: string;
    }

    export interface GetDeviceSecondaryDevice {
        accountNumber: string;
        /**
         * Unique identifier of applied ACL template
         */
        aclTemplateId: string;
        additionalBandwidth: number;
        /**
         * Autonomous system number
         */
        asn: number;
        hostname: string;
        /**
         * Device location Equinix Business Exchange name
         */
        ibx: string;
        /**
         * List of device interfaces
         * * `interface.#.id` - interface identifier
         * * `interface.#.name` - interface name
         * * `interface.#.status` -  interface status (AVAILABLE, RESERVED, ASSIGNED)
         * * `interface.#.operational_status` - interface operational status (up or down)
         * * `interface.#.mac_address` - interface MAC address
         * * `interface.#.ip_address` - interface IP address
         * * `interface.#.assigned_type` - interface management type (Equinix Managed or empty)
         * * `interface.#.type` - interface type
         */
        interfaces: outputs.networkedge.GetDeviceSecondaryDeviceInterface[];
        licenseFile: string;
        /**
         * Unique identifier of applied license file
         */
        licenseFileId: string;
        /**
         * Device license registration status
         * * APPLYING_LICENSE
         * * REGISTERED
         * * APPLIED
         * * WAITING_FOR_CLUSTER_SETUP
         * * REGISTRATION_FAILED
         */
        licenseStatus: string;
        licenseToken: string;
        metroCode: string;
        mgmtAclTemplateUuid: string;
        /**
         * Name of an existing Equinix Network Edge device
         */
        name: string;
        notifications: string[];
        /**
         * Device redundancy type applicable for HA devices, either
         * primary or secondary
         */
        redundancyType: string;
        /**
         * Unique identifier for a redundant device applicable for HA devices
         */
        redundantId: string;
        /**
         * Device location region
         */
        region: string;
        /**
         * IP address of SSH enabled interface on the device
         */
        sshIpAddress: string;
        /**
         * FQDN of SSH enabled interface on the device
         */
        sshIpFqdn: string;
        sshKeys: outputs.networkedge.GetDeviceSecondaryDeviceSshKey[];
        /**
         * Device provisioning status
         * * INITIALIZING
         * * PROVISIONING
         * * PROVISIONED  (**NOTE: By default data source will only return devices in this state.  To include other states see `validStateList`**)
         * * WAITING_FOR_PRIMARY
         * * WAITING_FOR_SECONDARY
         * * WAITING_FOR_REPLICA_CLUSTER_NODES
         * * CLUSTER_SETUP_IN_PROGRESS
         * * FAILED
         * * DEPROVISIONING
         * * DEPROVISIONED
         */
        status: string;
        /**
         * UUID of an existing Equinix Network Edge device
         */
        uuid: string;
        vendorConfiguration: {[key: string]: string};
        wanInterfaceId: string;
        /**
         * Device location zone code
         */
        zoneCode: string;
    }

    export interface GetDeviceSecondaryDeviceInterface {
        assignedType: string;
        id: number;
        ipAddress: string;
        macAddress: string;
        /**
         * Name of an existing Equinix Network Edge device
         */
        name: string;
        operationalStatus: string;
        /**
         * Device provisioning status
         * * INITIALIZING
         * * PROVISIONING
         * * PROVISIONED  (**NOTE: By default data source will only return devices in this state.  To include other states see `validStateList`**)
         * * WAITING_FOR_PRIMARY
         * * WAITING_FOR_SECONDARY
         * * WAITING_FOR_REPLICA_CLUSTER_NODES
         * * CLUSTER_SETUP_IN_PROGRESS
         * * FAILED
         * * DEPROVISIONING
         * * DEPROVISIONED
         */
        status: string;
        type: string;
    }

    export interface GetDeviceSecondaryDeviceSshKey {
        keyName: string;
        username: string;
    }

    export interface GetDeviceSshKey {
        keyName: string;
        username: string;
    }

}
